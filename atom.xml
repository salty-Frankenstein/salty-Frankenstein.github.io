<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>地灵殿</title>
  
  <subtitle>Frankenstein&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://121.5.103.67/"/>
  <updated>2022-03-01T13:05:24.018Z</updated>
  <id>https://121.5.103.67/</id>
  
  <author>
    <name>Frankenstein</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【PL】Type-Level Programming with Match Types</title>
    <link href="https://121.5.103.67/2022/03/01/%E3%80%90PL%E3%80%91Type-Level-Programming-with-Match-Types/"/>
    <id>https://121.5.103.67/2022/03/01/【PL】Type-Level-Programming-with-Match-Types/</id>
    <published>2022-03-01T07:34:23.000Z</published>
    <updated>2022-03-01T13:05:24.018Z</updated>
    
    <content type="html"><![CDATA[<p>本文是POPL2022同名文章的中文翻译，無断転載禁止。</p><hr><blockquote><p>关于match types的Scala文档：<a href="https://docs.scala-lang.org/scala3/reference/new-types/match-types.html" target="_blank" rel="noopener">https://docs.scala-lang.org/scala3/reference/new-types/match-types.html</a></p></blockquote><p>Type-level programming在FP越来越流行，但type-level programming和subtyping的组合还没有充分的探索。这篇文章中的match types等价于类型层面的pattern matching，在基于system F$_{&lt;:}$的一个演算上形式化了match type这个feature，证明了它的soundness。在Scala3的reference compiler上实现了match types的系统。</p><a id="more"></a><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>原本只属于依值类型语言的特性开始飞入寻常百姓家，使用<em>类型层面计算</em>以增加类型系统的表达能力，表达类型层面上更多的constraints，提高软件的安全性。GHC Haskell一直是这个过程的前沿，并且已经提高了许多extension以支持type-level programming。虽然Haskell也不是唯一一个，但是这个潮流似乎局限于纯FPL。</p><blockquote><p> 事实上，Haskell语言是不支持dependent type的。<br> GHC Haskell中主要提供type-level programming功能的是<em>type families</em>和<em>data kinds</em>这两个拓展。type family提供了类型上的计算（类型上的pattern matching），data kinds提供了在type level定义data的能力（将value提升到type level的能力），可以实现一定的dependent type。</p></blockquote><p>我们认为type-level programming并不一定与其他编程范式不相容，当下的分裂格局主要源于学界的对这一领域的不重视。不幸的是，这个领域现有的研究都不能直接应用于有subtyping的语言。尽管subtyping和type-level programming结合在理论界通过依值类型系统被广泛研究，但在实践层面还有很多没有探索。</p><blockquote><p>Haskell所使用的Hindley-Milner类型系统与subtyping是不兼容的。</p></blockquote><p>一个例外是TypeScript，最近引入了一个叫<em>conditional type</em>的特性，一个基于subtyping的类型层面三目运算符。<code>S extends T ? Tt : Tf</code>在<code>S</code>是<code>T</code>的子类型时归约到<code>Tt</code>，在<code>S</code>不是<code>T</code>子类型时归约到<code>Tf</code>，否则如果无法给出结论，就不做归约。遗憾的是，归约这个conditional type的算法是既unsound又incomplete的。尽管它不sound（见6.5），TypeScript这个新特性的添加还是展现了这个需求的存在。</p><p>这篇文章展示了基于subtyping的type-level programming的另一种构造，称为<em>match types</em>。顾名思义，match types允许用户使用类型上的pattern matching来表达类型：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Elem</span>[<span class="type">X</span>] </span>= <span class="type">X</span> <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">String</span> =&gt; <span class="type">Char</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">List</span>[t] =&gt; <span class="type">Elem</span>[t]</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Any</span> =&gt; <span class="type">X</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将在第2节中解释这个例子，它定义了一个<code>Elem</code>类型，匹配类型参数<code>X</code>。我们已经在最新版本的Scala3（一个工业级的编译器）上实现了match types，已经获得了Scala社区的很大兴趣，并投入活跃使用。</p><p>这篇论文中，通过一个可以在System F$_{&lt;:}$上扩展了项和类型层面的pattern matching的一个类型系统的lens，我们探索了match types的理论基础。我们的形式化有两个目的：一、展示<em>如何</em>在Scala的类型系统中整合match types，并精确的描述在子类型关系上还需要作出的改变以确保这个整合的可能性。二、得益于标准的progress和perserve定理的类型安全证明，给了我们信心match types的设计是合理的并且它的实现是sound的。</p><p>Conditional types提供了<em>确凿的证据</em>表明我们的成果在Scala之外也是有价值的。我们的成果可以直接应用于Typescript的类型系统，并提供能修复引入conditional types带来的unsoundness的一个清晰的路线。进一步，我们希望match types可以为未来的有subtyping的语言的type-level programming特性的设计作为一个参考。</p><p>总结，这篇论文做了以下工作：</p><ul><li><p>通过一个例子介绍在Scala中的match types编程，并突出了它与type-level programming和subtyping的关系（2）</p></li><li><p>我们在self-contained calculus System FM中形式化了match types，并证明了它sound，提供了我们的理论基础的实现（3）</p></li><li><p>描述了我们实现的Scala编译器中的match types，讨论了挑战，以及这个实现和我们的形式化之间的联系（4）</p></li><li><p>通过一个案例分析评估了match types，呈现了Numpy库的一个类型安全版本（5）</p></li><li><p>我们的形式化的设计与先前的相关工作，重新审视了相关的Haskell中type families的大量工作，并讨论了Typescript中的conditional types的unsoundness（6）</p></li></ul><h2 id="2-Overview"><a href="#2-Overview" class="headerlink" title="2. Overview"></a>2. Overview</h2><p>这一节中，我们通过上文的一个例子，提供一个Scala中的match types的简要介绍：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Elem</span>[<span class="type">X</span>] </span>= <span class="type">X</span> <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">String</span> =&gt; <span class="type">Char</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">List</span>[t] =&gt; <span class="type">Elem</span>[t]</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Any</span> =&gt; <span class="type">X</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子定义了一个类型<code>Elem</code>，关于一个类型参数<code>X</code>。等号右边是通过一个在类型参数上的match定义的，<em>一个match type</em>。一个match type归约到右边的其中的一个，取决于它scrutinee的类型。例如，上面的类型归约到如下：</p><blockquote><p>没看到过scrutinee这个术语，下文解释了，见3.2，大概是被match的对象的意思。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Elem</span>[<span class="type">String</span>] =:= <span class="type">Char</span></span><br><span class="line"><span class="type">Elem</span>[<span class="type">Int</span>] =:= <span class="type">Int</span></span><br><span class="line"><span class="type">Elem</span>[<span class="type">List</span>[<span class="type">Int</span>]] =:= <span class="type">Int</span></span><br></pre></td></tr></table></figure><p>此处<code>S =:= T</code>表记类型<code>S</code>和<code>T</code>的相等性，定义为互为子类型。要归约一个match type，scrutinee与每个pattern通过<em>subtyping</em>关系一一比较。例如，尽管<code>String</code>既是<code>String</code>又是<code>Any</code>（Scala子类型格的top）的子类型，<code>Elem[String]</code>归约到<code>Char</code>因为它对应的case先出现。</p><p>当scrutinee类型是个<code>List</code>，match type <code>Elem</code>是在这个列表中的元素类型上的递归定义。因此，在这个例子中的<code>Elem[List[Int]]</code>首先归约到<code>Elem[Int]</code>，然后最后归约到<code>Int</code>。</p><h3 id="2-1-依值类型的一个轻量级形式"><a href="#2-1-依值类型的一个轻量级形式" class="headerlink" title="2.1 依值类型的一个轻量级形式"></a>2.1 依值类型的一个轻量级形式</h3><p>Match types可以提供一个轻量级形式的依值类型，因为一个term-level的pattern matching表达式可以在类型层面作为match type对应的被定型。考虑下面的函数定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">elem</span></span>[<span class="type">X</span>](x: <span class="type">X</span>): <span class="type">Elem</span>[<span class="type">X</span>] = x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> x: <span class="type">String</span> =&gt; x.charAt(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">case</span> x: <span class="type">List</span>[t] =&gt; elem(x.head)</span><br><span class="line">    <span class="keyword">case</span> x: <span class="type">Any</span> =&gt; x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个参数化类型X与Haskell中的forall类型的语义不同，Haskell中forall修饰的类型参数无法对类型的性质做假设，或者pattern matching之类的操作。例如，具有<code>forall a . a -&gt; a</code>签名的函数只有<code>id</code>一个。</p></blockquote><p>这个定义是良类型的，因为在<code>elem</code>体中的match表达式有和<code>Elem[x]</code>（函数的返回值类型）完全相同的scrutinee和pattern类型。</p><p>归功于Scala的类型推断，<code>elem</code>函数的一个调用得到一个返回值类型，依赖于一个term-level的参数。例如，表达式<code>elem(1)</code>，Scala编译器会给<code>elem</code>的类型参数推断出一个singleton type <code>X = 1</code>，于是这个表达式的类型是<code>Elem[1]</code>,（根据<code>Elem</code>的第三个pattern）归约到<code>Int</code>。类似的，在<code>elem(x)</code>中，编译器推断singleton type <code>X = x.type</code>，则这个表达式有类型<code>Elem[x.type]</code>，这可能会根据调用时x的类型进一步归约。</p><blockquote><p>关于singleton type：</p><ul><li><a href="https://docs.scala-lang.org/sips/42.type.html#inner-main" target="_blank" rel="noopener">https://docs.scala-lang.org/sips/42.type.html#inner-main</a></li><li><a href="https://stackoverflow.com/questions/33052086/what-is-a-singleton-type-exactly" target="_blank" rel="noopener">https://stackoverflow.com/questions/33052086/what-is-a-singleton-type-exactly</a></li></ul><blockquote><p>我感觉singleton type和GHC Haskell的DataKinds挺像的，是指每一个（字面量）值都有一个对应的singleton type，建立了值与类型之间的桥梁，也提供了dependent type的一个侧面。</p></blockquote><p>此处，<code>elem(1)</code>会给字面量<code>1</code>一个最紧的类型<code>1 : 1</code>（考虑子类型关系下，最松的是Any，就等于啥都没推断了）。</p></blockquote><p>在这两个例子中，singleton types创造了一个类型参数和一个项之间的依赖，由传递性，可以得到一个轻量级的依值类型，即项参数和函数返回类型的依赖关系。</p><h3 id="2-2-不相交性"><a href="#2-2-不相交性" class="headerlink" title="2.2 不相交性"></a>2.2 不相交性</h3><p>我们设计的match types在归约时会归纳一个额外的限制：scrutinee类型必须要与所有的case的类型不相交。非形式化的说，不相交就是两个类型没有相同的居留元。</p><p>举例介绍这个不相交性的重要性。考虑整数序列的类型<code>Seq[Int]</code>，则<code>Elem[Seq[Int]]</code>不会被归约：</p><ol><li>第一个case无法应用，因为<code>Seq[Int]</code>不是<code>String</code>的子类型</li><li>第二个case无法应用，因为<code>Seq[Int]</code>不是<code>List[Int]</code>的子类型（反过来倒是成立）</li><li>第三个case不作考虑，因为<code>Seq[Int]</code>与<code>List[Int]</code>并不具有不相交性。</li></ol><p>因此，归约算法会在第二个case卡住，于是整个type都不可归约。如果没有不相交性，那么<code>Elem[Seq[Int]]</code>会被归约到<code>Seq[Int]</code>（根据第三个case）。这是unsound的。因为例如表达式<code>elem[Seq[Int]](List(1,2,3))</code>会有类型<code>Seq[Int]</code>，但求值出来是整数<code>1</code>。</p><blockquote><p>这里还是没太懂这个case3是怎么来的。先往下看看rule吧</p></blockquote><h2 id="3-Formalization"><a href="#3-Formalization" class="headerlink" title="3. Formalization"></a>3. Formalization</h2><p>在这一节里，我们会形式化的描述System FM，这是System F&lt;:的一个对pattern matching、opaque class和match types的拓展。图1定义了FM的语法和求值关系。图2定义了FM的类型系统，包括三个关系：定型、子类型和类型不相交性。在3.1和3.2中讨论了与System F$_{&lt;:}$ 的区别。在3.3中提供了一个System FM的type safety的证明的提纲。在3.4中我们介绍一个System FM对在类型pattern中绑定pattern变量的支持的拓展。</p><blockquote><p>opaque class是啥？</p></blockquote><p><img src="https://www.z4a.net/images/2022/03/01/image-20220213230919735.png" alt="image-20220213230919735.png"></p><p><img src="https://www.z4a.net/images/2022/03/01/image-20220213231010496.png" alt="image-20220213231010496.png"></p><h3 id="3-1-类"><a href="#3-1-类" class="headerlink" title="3.1 类"></a>3.1 类</h3><p>System FM是由一个带类继承$\Psi$的类的集合$\text{C}$，和类的不相交性$\Xi$为参数的。其中，类继承是$\text{C}$上一个偏序关系，即自反、反对称和传递的。而类的不相交性是$\text{C}$上的一个对称关系。类之间的子类型是通过$\text{S-PSI}$规则由$\Psi$决定的。</p><p>继承和不相交性这两个参数可以理解为Scala中trait和类的架构的一种表示。比如，<code>trait C1; class C2 extends C1</code>在FM中被表示为$\Psi=\lbrace (\text{C}_1,\text{C}_2)\rbrace ;\ \Xi=\lbrace \rbrace $。这样的表示同时也建模了哪些类型不能有相同的实例。例如，<code>class C3; class C4</code>表示为$\Psi=\lbrace \rbrace ;\ \Xi=\lbrace (\text{C}_3,\text{C}_4),(\text{C}_4,\text{C}_3)\rbrace $，因为Scala不允许多继承。继承和不相交性必须具有一种一致性：$(\text{A},\text{B})\in \Xi$蕴含着不存在类$\text{C}$使得$(\text{C},\text{A})\in \Psi$且$(\text{C},\text{B})\in \Psi$。</p><blockquote><p>来自梁老师的勘误，局的应该是$\Psi=\lbrace (\text{C}_2,\text{C}_1)\rbrace $，C2是C1的子类</p><p>即如果A和B不相交，则不存在一个C类，使得C同时是A和B的子类，因为否则的话C的实例就同时是A和B的居留元了。</p></blockquote><p>$\text{C}$中的每个类有一个构造子（记作$\textit{new }\text{C}$），一个类型（记作$\text{C}$），和一个singleton type构造子（记作$\lbrace \textit{new }\text{C}\rbrace $）。类型$\text{C}$表示所有继承$\text{C}$ 的值，而singleton type构造子表示一个单个的值：即$\text{C}$构造子的调用。</p><blockquote><p>就是说类型C的居留元包括所有C或者C的子类型的构造子的调用，而C的singleton type的居留元只包括C构造子的调用。</p></blockquote><p>这样参数化的实现方式使我们可以对OO语言中的类继承架构建模，而不需要专门的类和数据类型定义的语法。尽管我们的方式可能过于简化，但它可以轻松地建模如多继承等高级OO特性。我们将在4.1节讨论把Scala的类型编码进System FM。</p><p>我们的类型系统是通过名字来引用这些类，所以会混淆结构上的（structural）和名义上的（nominal）类型。名字可以有效地提供一个运行时的标签（tag）和编译期的类型之间的一个直接的对应。我们之后会发现，运行时的tag已经足够进行运行时的类型测试，而且在pattern matching的求值过程中也起到了核心的作用。</p><h3 id="3-2-Matches"><a href="#3-2-Matches" class="headerlink" title="3.2 Matches"></a>3.2 Matches</h3><p>System FM同时支持term-level（match expressions）和term-level（match types）的pattern matching。不管是哪种Match，都由一个scrutinee，一个case的列表，和一个缺省表达式/类型组成。每个case由一个<em>type test</em>和一个对应的表达式/类型组成。在term level，type test是由一个对一个特定类的继承（关系）检查（也被称为typecase）组成的。在type level，type test对应着一个特定类型的子类型（关系）检查。这个区别反映了运行时（type test是通过类表实现的）和编译期（在类型系统的限度里比较类型）。我们将在4.6节讨论在运行时的Scala类型。</p><blockquote><p>见图1的语法：</p><ul><li><p>term level的match：$\text{t }match\lbrace \overline{\text{x:C}\Rightarrow\text{t}}\rbrace or\ \text{t}$</p></li><li><p>type level的match：$\text{T }match\lbrace \overline{\text{T}\Rightarrow\text{T}}\rbrace or\ \text{T}$</p></li></ul><p>scrutinee应该就是对应的match前的t和T。</p><p>在term level，type test（也就是type system要对这个match做的工作）是检查scrutinee与$\text{x:C}$，也就是那个t是否是C的一个子类型的居留元（就像动态指派一样）</p><p>而在type level，type test是检查那个T是否是$\Rightarrow$前的T的子类型（这理论上是个静态的事情）</p><p>正如最后一句所说。</p></blockquote><p>在这个文章中，我们使用简短的语法$t_s\ match\lbrace x_i:\text{C}_i\Rightarrow t_i\rbrace or\ t_d$表示一个任意数量的case，即$\exists n\in\mathbb{N}.\ t_s\ match\lbrace x_1:\text{C}_1\Rightarrow t_1;\dots;x_n:\text{C}_n\Rightarrow t_n\rbrace or\ t_d$。</p><p>Match expression和match type由$\text{T-MATCH}$定型规则相关联。这个规则对一个match expression的每个组成部分做定型，然后整合对应的match type。</p><p><strong>Example A.</strong> 例如，给定两个不相交的类A和B，和一个空的类继承架构（$\Psi=\text{Id},\ \Xi =\lbrace (\text{A},\text{B}),(\text{B},\text{A})\rbrace $），则下面的函数<br>$$<br>\text{f}=\lambda \text{X&lt;: Top.}\ \lambda\text{x:X.x }match{\text{a:A}\Rightarrow \text{foo;b:B}\Rightarrow \text{bar}}or\text{ buzz}<br>$$<br>可以被精确地定型为：<br>$$<br>\text{f}\ :\ \forall\text{X&lt;:Top. X}\to\text{X }match{\text{A}\Rightarrow\text{Foo;B}\Rightarrow\text{Bar}}or\text{ Buzz}<br>$$</p><blockquote><p>subtyping格的Top就是Any类型，即X可以是任意类型。</p><p>$\lambda$表示term-level的抽象，$\Pi/\forall$表示type-level的抽象。</p><p>定型的结果是将term-level的match变成了type-level。</p></blockquote><p>其中foo，bar和buzz分别是类型为Foo，Bar和Buzz的表达式。</p><p>match expression的cases是<em>顺序</em>求值的：scrutinee通过对每个case的type test一个接一个进行检查。整个表达式归约到第一个type test成功的对应表达式（$\text{E-MATCH2}$）。当没有成功的type test时，则归约到缺省的表达式（$\text{E-MATCH3/4/5}$）。例如，A中定义的函数f，表达式$(\text{f A }(\textit{new }\text{A}))$求值到foo，而$(\text{f B }(\textit{new }\text{B}))$求值到bar。</p><p><em>Match Type Reduction</em> 为了实现match type的归约，子类型关系包括5个规则：$\text{MATCH1/2/3/4/5}$。这些规则是用$=:=$的对表记的，其中$\text{S}=:=\text{T}$表示S和T互为子类型。更准确地说，图2中的$\text{S-MATCH1/2}$对应着两个有着相同的前提和对称的结论的typing rules，$\text{S-MATCH}3/4$也同理。</p><blockquote><p>通常来说我们好像觉得是先有相等关系再由偏序关系的三个性质，但仔细想想好像不是的。所谓的相等关系就是等价关系，也就是集合上的一个划分。偏序关系和等价关系不一定哪个更本质。</p><p>从子类型的语义上来说，子类型关系是一个在类型上的偏序关系。从它的subtyping rule中我们可以看到$&lt;:$的自反和传递性都是公理。</p><p>而反对称性是建立在一个对应的等价关系上的。要知道这个类型系统的$&lt;:$是否满足反对称性，就要知道$A&lt;:B\ \wedge\ B&lt;:A$是不是一个等价关系。这个可能就是这个类型系统需要保证的（需要证明的一个性质）。</p><p>而在证明了它是个等价关系之后，这个类型系统把$A&lt;:B\ \wedge\ B&lt;:A$记作了$A=:=B$，这就定义了这个类型系统上的<strong>一个</strong>相等性。</p><p>$=:=$是一种meta的表记，用$&lt;:$写的话就是4条rule，从定义上说$&lt;:$更本质。</p><p>这也是为什么在System F上没有定义类型的相等（或者说类型上的相等性就是identical）。</p></blockquote><p>match type归约的typing rule的最好解释是一个求值关系的推广。给定一个match type，$\text{M=T}_s\ match\lbrace \text{C}_i\Rightarrow \text{T}_i\rbrace or\ \text{T}_d$，M归约到$\text{T}_i$，当且仅当对于$\text{T}_s$中的每个值$\text{t}_s$，term level的表达式$\text{t}_s\ match\lbrace \text{x}_i:\text{C}_i\Rightarrow \text{t}_i\rbrace \ or\ \text{t}_d$求值到$\text{t}_i$。</p><p>$\text{S-MATCH1/2}$规则对应着一个match expression求值到它的第n个case（$\text{E-MATCH2}$）：<br>$$<br>\dfrac{\Gamma\vdash\text{T}_s&lt;:\text{S}_n\quad \forall m &lt; n.\Gamma\vdash \text{disj}(\text{T}_s,\text{S}_m)}{\Gamma\vdash\text{T}_s\ match{\text{S}_i\Rightarrow\text{T}_i}or\ \text{T}_d=:=\text{T}_n}\quad(\text{S-MATCH1/2})<br>$$<br>第一个前提确保了第n个case的type test会对所有的有$\text{T}_s$这个scrutinee type的值都成功。反之，第二个前提是一个不相交的判定，保证了有scrutinee type的value没有一个能通过在第n个case之前的type test。$\text{S-MATCH3/4}$规则对应着求值到缺省case（$\text{E-MATCH2}$），需要scrutinee type和每个type test类型之间不相交：<br>$$<br>\dfrac{\forall n.\Gamma\vdash\text{disj}(\text{T}_s,\text{S}_n)}{\Gamma\vdash\text{T}_s\ match{\text{S}_i\Rightarrow\text{T}_i}or\ \text{T}_d=:=\text{T}_d}\quad(\text{S-MATCH3/4})<br>$$<br>两个类之间的不相交性可以直接由使用了类不相交性$\Xi$的$\text{D-XI}$规则得到。另外，一个构造子singleton type和一个类之间的不相交性可以直接观察类继承关系$ \Psi$得到（$\text{D-PSI}$）。函数类型和universal类型与类不相交，因为他们居留着不同的值（$\text{D-ARROW,D-ALL}$），所以他们也永远不会匹配。最后是不相交性规则，$\text{D-SUB}$，说明了如果U和T不相交，那么所有U的子类型也和T不相交。</p><p><strong>Example B.</strong> 我们继续看Example A，展示怎么使用match type的归约规则来推出$(\text{f B (}new\text{ B)})$的类型是Bar。使用$\text{T-TAPP, T-APP}$，表达式可以被定型为：<br>$$<br>\text{f B (}new \text{ B)}\ :\ \text{B }match{\text{A}\Rightarrow\text{Foo};\text{B}\Rightarrow\text{Bar}}or\text{ Buzz}<br>$$<br>因为我们的例子假设了一个空的类继承关系，并且$\text{(A,B)}\in\Xi$，所以$\text{S-MATCH1}$规则得到：<br>$$<br>\emptyset\vdash\text{B}\ match{\text{A}\Rightarrow\text{Foo};\text{B}\Rightarrow\text{Bar}}or\ \text{Buzz&lt;:Bar}<br>$$<br>最后，使用$\text{T-SUB}$规则，我们得到$\text{(f B(}new\text{ B)):Bar}$。</p><p><em>子类型和不相交性</em>。有人可能有疑问如果我们把match type的归约规则简化一下，把前提$\Gamma\vdash\text{disj(T,C)}$换成看似等价的前提$\text{(T,C)}\notin\Psi$会怎么样。遗憾的，这样的话这个系统就会unsound了，举反例说明。假设Example A里面定义的函数f，加一个新的类E并且$\Psi=\lbrace \text{(E,A),(E,B)}\rbrace ,\Xi=\lbrace \rbrace $。现在考虑项$\text{(f B(}new\text{ E))}$。因为有$\emptyset\vdash\text{E&lt;:B}$， 这个函数应用是良类型的，并且由于$\text{(E,A)}\in\Psi$，会求值到foo。这样，term-level和type-level的归约就不一致了！当对更改后的$\text{S-MATCH1}$规则用$\text{(B,A)}\notin\Psi$，就会得到错误的结论$\text{(f B (}new\text{ E))}$有Bar的错误结论，导致了unsoundness。这会导致类型$\text{e : Bar}$和求值$\text{(e}\to\text{foo)}$之间的不一致，就破坏了类型系统的soundness。在System FM中，对$\text{(f B (}new\text{ E))}$定型得到的match type并不会归约，因为scrutinee type B与test A的第一个pattern type既不是不相交的，也不是子类型。在这个情况下，没有归约的match type会被赋值为”as is”（原样）。没有归约的类型的出现可以是一个程序错误，但也可以是因为一个match type的局部不可归约。例如，Example A中的f被定型为一个未归约的类型，但这个类型之后可以依赖于类型变量的实例化而被归约。</p><h3 id="3-3-类型安全"><a href="#3-3-类型安全" class="headerlink" title="3.3 类型安全"></a>3.3 类型安全</h3><p>我们通过通常的progress和preservation定理来展示System FM的类型安全。这一节提供了一个证明架构的概览并且描述了包括的引理和定理。详细的纸面证明详见这个文章的附录。也提供的Coq的机器证明。我们的机器证明使用的局部匿名的表示来对变量绑定做建模，并且简化了match type的表示使得每个match有且只有一个case。多个case的match可以通过嵌套在default case里来表示。</p><p><img src="https://www.z4a.net/images/2022/03/01/image-20220215153544744.png" alt="image-20220215153544744.png"></p><p>图3给出了一个证明架构的概览，展示了引理和定理之间的蕴含关系。基本的结构和System F$_{&lt;:}$的标准证明类似。接下来介绍我们的类型安全证明里面的引理和定理。</p><p><em>Preliminary Lemmas</em>。我们的证明从初等的引理开始：LEMMA3.1(PERMUTATION，排列引理)，LEMMA3.2（WEAKENING，弱化引理），LEMMA3.3（STRENGTHENING，强化引理），LEMMA3.4（SUBSTITUTION，置换引理）。我们省略了这些引理，因为它们是完全标准的，但相对冗长，因为它们跨越了我们系统的三种关系：定型、子类型和不相交性。像往常一样，他们的证明遵循推导的相互归纳。（？</p><p><em>Disjointness / Subtyping的互斥性（Exclusivity）</em>。接下来的非标准的引理可以防止$\text{S-MATCH1/2}$和$\text{S-MATCH3/4}$之间的存在交集的可能。</p><ul><li>LEMMA3.5 (Disjointness/subtyping exclusivity) 类型的不相交性和子类型关系是互斥的</li></ul><p>如果允许存在这种重叠，match types就可以有多种归约方式，系统就unsound了。我们用反证法证明了Lemma3.5。我们的证明把SystemFM的类型映射到一个新定义的集合$\text{P}=\lbrace \Lambda,\text{V}\rbrace \cup\text{C}$的一个非空子集中。$\text{P}$可以理解为一个FM类型上的等价类。我们展示了在FM中的子类型关系对应着$\text{P}$中的一个子集关系，而FM类型的不相交关系是$\text{P}$中的集合不相交关系。这个集合论的视角可以直接得出我们需要的结论。在我们的Coq实现中，我们直接把这个引理设为公理了，证明交给了纸面证明。</p><p><em>子类型的逆 Inversion of Subtyping</em>。接下来的Lemma3.6使我们能够实现子类型关系上的逆，这个对canonical form(Lemma3.7)和typing的逆（Lemma3.8）很重要。这个引理的陈述需要定义一个新的关系，记作$\Gamma\vdash\text{S}\rightleftharpoons \text{T}$，见图4的定义。它表述了存在一个证明，使得match type $\text{S}$和类型$\text{T}$互为子类型，并且满足一个额外的条件：这个证明过程是$\text{S-MATCH1/2}$，$\text{S-MATCH3/4}$和$\text{S-TRANS}$在两个方向上成对使用的。直观来说，$\Gamma\vdash S\rightleftharpoons T$比$\Gamma\vdash\text{S&lt;:T}$和$\Gamma\vdash\text{T&lt;:S}$这两个独立的证明派生要更好用，因为它允许两个subtyping方向的simultaneous induction（？）</p><p><img src="https://www.z4a.net/images/2022/03/01/image-20220216160821056.png" alt="image-20220216160821056.png"></p><blockquote><p>这里把1/2和3/4的$=:=$这个meta表记还原一下：<br>$$<br>\dfrac{\dfrac{\vdots}{\Gamma\vdash\text{S&lt;:T}}(\text{S-MATCH1})\quad\dfrac{\vdots}{\Gamma\vdash\text{T&lt;:S}}\text{(S-MATCH2)}}<br>{\Gamma\vdash\text{S}\rightleftharpoons \text{T}}\<br>\dfrac{\dfrac{\vdots}{\Gamma\vdash\text{S&lt;:T}}(\text{S-MATCH3})\quad\dfrac{\vdots}{\Gamma\vdash\text{T&lt;:S}}\text{(S-MATCH4)}}<br>{\Gamma\vdash\text{S}\rightleftharpoons \text{T}}<br>$$<br>就可以理解啥是“成对使用”了。那么为啥要成对使用呢？</p></blockquote><p><img src="https://www.z4a.net/images/2022/03/01/image-20220217133944242.png" alt="image-20220217133944242.png"></p><blockquote><p>如果$\Gamma$下可以定型左边这个match type和T是互为子类型的，那么下面有一个成立</p><p>(a) $\text{S}_s$是第n个pattern的子类型，并且对于所有n之前的pattern都和$\text{S}_s$都不相交，并且第n个pattern对应那个$\text{S}_n$（也是一个match type）然后也能定型为和T是互为子类型（大概就是归纳）</p><p>(b)  $\text{S}_s$是第n个pattern的子类型，并且对于所有n之前的pattern都和$\text{S}_s$都不相交，并且第n个pattern对应那个$\text{S}_n$就是T（这个等号没有定义，我怀疑就是指identical，这个大概是base case）</p><p>(c) $\text{S}_s$和所有的pattern都不相交（那么就归约到缺省），并且$\text{S}_d$（也是一个match type）然后也能定型为和T是互为子类型（大概就是归纳）</p><p>(d) $\text{S}_s$和所有的pattern都不相交（那么就归约到缺省），并且$\text{S}_d$就是T（这个大概是base case）</p><p>这个大概意思是一个类型T和一个match type如果互为子类型，那么有的性质（分类讨论）</p></blockquote><p><img src="https://www.z4a.net/images/2022/03/01/image-20220217134052055.png" alt="image-20220217134052055.png"></p><blockquote><p>如果$\Gamma$下可以定型S是X的子类型，或者S是T的子类型，其中T是一个match type然后T和X是互为子类型的，那么</p><p>(a) 要么S是一个match type然后存在某个Y和它互为子类型</p><p>(b) 要么S是一个类型变量</p></blockquote><p><img src="https://www.z4a.net/images/2022/03/01/image-20220217134120455.png" alt="image-20220217134120455.png"></p><blockquote><p>如果$\Gamma$下可以定型S是$T_1\to T_2$的子类型，或者S是T的子类型，其中T和$T_1\to T_2$是互为子类型的，那么下面有一个成立</p><p>(a) S是一个match type，存在S1S2，S和$S_1\to S_2$互为子类型，使得T1是S1的子类型，S2是T2的子类型</p><p>(b) S是一个match type，存在X，使得S和X互为子类型</p><p>(c) S是个类型变量</p><p>(d) S形如$S_1\to S_2$，T1是S1的子类型，S2是T2的子类型</p><p>这条处理函数类型</p></blockquote><p><img src="https://www.z4a.net/images/2022/03/01/image-20220217134132894.png" alt="image-20220217134132894.png"></p><blockquote><p>如果$\Gamma$下可以定型S是$\forall X&lt;:U_1.T_2$的子类型，或者S是T的子类型，其中T是一个match type，T和这个全称量化类型互为子类型，那么下面有一个成立</p><p>(a) S是一个match type,,,</p><p>这条处理全称量化类型</p></blockquote><p>Lemma3.6的第一条使用了$\rightleftharpoons$的结构提供了一种逆，我们用它来证明后续的几点。对比$\text{F}_{&lt;:}$类型安全证明中相应的inversion lemma，Lemma3.6的陈述和证明要更长更复杂。这个区别是不可避免的，因为match type的归约规则允许match expression作为归约的结果，使这个inversion变得复杂了。</p><p>类似于Subtyping的inversion，我们的canonical forms lemma是非标准的，因为它使用了它的前提的一个析取来解释match types。</p><p><img src="https://www.z4a.net/images/2022/03/01/image-20220217142102931.png" alt="image-20220217142102931.png"></p><blockquote><ol><li>如果$\Gamma$下可以定型t是T类型，其中T要么是个类型变量，要么是一个match type然后T和某个类型X互为子类型，那么t不是一个closed value</li><li>如果v是一个closed value，定型为要么是$T_1\to T_2$，要么是一个和$T_1\to T2$互为子类型的类型，那么v一定形如$\lambda x:S_1.t_2$</li><li>如果v是一个closed value，定型为要么是$\forall X&lt;:U_1.T_1$，要么是一个和他是互为子类型的类型，那么v一定形如$\lambda X&lt;:U_1.t2$</li></ol><p>value是特殊的term，closed value就是既close又value的term。</p></blockquote><p><em>Soundness的证明</em>。剩下的soundness的证明基本上是标准的。Lemma3.8和3.9是简单的typing rule的逆。在preservation的证明中需要Lemma3.9去从typing judgments中恢复subtyping的界。证明是通过derivation上的routine induction完成的。</p><p><img src="https://www.z4a.net/images/2022/03/01/image-20220217143059323.png" alt="image-20220217143059323.png"></p><blockquote><ol><li>如果$\Gamma$下可以定型$\lambda x:\text{S}_1.\text{s}_2$类型是T并且T是$U_1\to U_2$的子类型，那么U1是S1的子类型并且存在S2使得$\Gamma,x:S_1\vdash s_2:S_2$且S2是U2的子类型</li><li>如果$\Gamma$下可以定型$\lambda X&lt;:S_1.s_2:T$，并且T是$\forall X&lt;:U_1.U_2$的子类型，那么U1就是S1，并且存在S2使得$\Gamma,X&lt;:S_1\vdash s_2:S_2$并且$\Gamma,X&lt;:S_1\vdash S_2&lt;:U_2$</li></ol></blockquote><p><img src="https://www.z4a.net/images/2022/03/01/image-20220217143107956.png" alt="image-20220217143107956.png"></p><blockquote><ol><li>如果$\Gamma$下能定型new C是T类型，那么单例$\lbrace new C\rbrace $是T的子类型</li><li>如果$\Gamma$下能定型$\lambda x:T_1.t_2$是T类型，那么存在T2使得$T_1\to T_2$是T的子类型</li><li>如果$\Gamma$下能定型$\lambda X&lt;:U_1.t_2$是T类型，那么存在T2使得$\forall X&lt;:U_1.T_2$是T的子类型</li></ol></blockquote><p>有了这些引理，就可以直接得到progress和preservation了。</p><p><img src="https://www.z4a.net/images/2022/03/01/image-20220217150732069.png" alt="image-20220217150732069.png"></p><blockquote><p>懂的都懂</p></blockquote><h3 id="3-4-类型绑定扩展"><a href="#3-4-类型绑定扩展" class="headerlink" title="3.4 类型绑定扩展"></a>3.4 类型绑定扩展</h3><p>这一节，我们展示System FMB，是System FM拓展了在type pattern中绑定pattern variables的支持。FMB由两个参数组成，是两个类的集合A和B，分别表示非参数化和参数化的类。一个参数化的类，写作B T，恰好接受一个类型参数。我们精化C成为一个语法上的对象，定义为$C::=A|B\ T$。类继承关系$\Psi$和类不相交关系$\Xi$还是C上的二元关系不变。类继承架构上的一个泛型的实例化用$\Psi$中的一个元素表示，例如，<code>A1 extends B2[A3]</code>表示为$(A_1,B_2,A_3)\in \Psi$。泛型的继承用$\Psi$中的多个元素表示，例如，<code>B1[T] extends B2[T]</code>表示为$\forall T.(B_1\ T, B_2\ T)\in \Psi$。这个做法让我们可以复用FM中的大部分定义。确实，我们的形式化把C，$\Psi$和$\Xi$作为数学对象处理，然后这与FMB中的类的新定义是兼容的。</p><blockquote><p>原文注：这个限制一个类型参数是为了表示上的目的。System FMB的类型系统和类型安全的证明都可以轻松地运用到一个可以支持多个参数的绑定变量。</p></blockquote><p>在图5中，我们定义了System FMB的语法和规则，其中灰色的是较FM的改动。FMB对于match expression和match types的新语法在构造中增加了一个<em>pattern variable</em>。在$\text{t}_s\ match[X]\lbrace \text{x}_i:\text{C}_i\Rightarrow\text{t}_i\rbrace or\ \text{t}_d$中，pattern变量X现在可以在Ci pattern中绑定类型参数了。</p><p><img src="https://www.z4a.net/images/2022/03/01/image-20220217152919553.png" alt="image-20220217152919553.png"></p><p>$\text{S-MATCH3/4}$，$\text{S-MATCH5}$和$\text{T-MATCH}$需要很小的改动就可以在定型上下文中使用pattern variable了。注意到pattern variable是无条件出现在上下文中的，不论这些变量是否在对应的pattern中被使用了。</p><p>在新的子类型规则中，对于非缺省的match归约，$\text{BS-MATCH1/2}$，第一个前提实例化了pattern变量X到某一个类型U使得那个scrutinee类型是第n个pattern的一个子类型。</p><p>这里的U是完全不受约束的：任何X的实例，使得Ts是Sn的子类型的都是可以的。不相交性的judgment对于X，比起subtyping judgment（X&lt;:Top而不是X&lt;:U）使用了一个更弱的上界，这是因为scrutinee类型必须要和没匹配上的pattern类型对于X的所有可能的实例都不相交。在算法的系统中，U会在类型推断的时候通过约束的求解被计算出来。</p><p>对于非缺省match归约的新的求值规则（$\text{BE-MATCH2}$）使用了一个类似的机制：它先找<em>第一个case</em>使得可以实例化这个pattern variable让那个scrutinee继承自那个对应的pattern</p><p>第二个前提排除了一个全称量词覆盖了整个类型的不匹配的情况。一个具体的实现肯定会选择一个更高效的方式，比如把$\Psi$实现为一个lookup table。</p><p><strong>Exmaple C</strong>。考虑下面的类继承结构，有两个类Char和String，和一个单类型变量的类List，使得String继承了List Char：</p><p><img src="https://www.z4a.net/images/2022/03/01/image-20220217155111637.png" alt="image-20220217155111637.png"></p><p>这个f匹配了他的参数到List X这个pattern，其中X是个pattern variable。我们通过两个应用检查这个evaluation：</p><ol><li>$\text{f}(new\ \text{String})$，匹配List X的话X=Char，会通过$\text{BE-MATCH2}$（因为$(\text{String,List Char})\in\Psi$）求值到$[\text{X}\mapsto \text{Char}][x\mapsto new \text{ String}]\text{foo}$。</li><li>$\text{f}(new\ \text{List Top})$，也匹配List X，这次X=Top，然后通过$\text{BE-MATCH2}$求值到$[\text{X}\mapsto \text{Top}][x\mapsto new \text{ List Top}]\text{foo}$。这里$(\text{List Top, List Top})\in\Psi$是从$\Psi$的自反性得到的。</li></ol><p>我们通过使用System FM的纸面证明建立了System FMB的类型安全。需要做的改动很冗长，相对无趣，就是在context里维护一个额外的pattern variable。FMB 类型安全的主要内容是证明不需要对 BS-Match1/2 中的类型 U 进行额外的约束。因此，算法实现可以自由地使用任何机制来提出模式变量的实例化。</p><h2 id="4-实现"><a href="#4-实现" class="headerlink" title="4. 实现"></a>4. 实现</h2><p>Match types在Scala的参考编译器Dotty上实现了。这段解释了我们怎么把实现和3里面的形式化关联起来的。</p><p>就像System FM中的一样，在编译器中，match-type归约在子类型定型时出现。为了让子类型定型保持为一个算法，match type的归约规则从来不能引入新的match type，只能化简原来的程序。归约算法与第3段中的定型规则紧密的结合。scrutinee类型与每个pattern顺序地作比较。如果scrutinee类型是第一个pattern类型的子类型，那么归约。否则，如果scrutinee类型可以知道和第一个pattern类型不相交，那么这个算法会到下一个pattern，如果算法到了一个既不是子类型，又可以确定不是不相交的类型，那么就终止归约，留下原来的match type。</p><h3 id="4-1-Scala中的不相交性"><a href="#4-1-Scala中的不相交性" class="headerlink" title="4.1 Scala中的不相交性"></a>4.1 Scala中的不相交性</h3><p>分离编译是两个判断两个类型不相交的最大障碍。确实，在Scala中，所有的traits和类都是自动可以被继承的。因为Scala的程序是在一个开放世界假设下编译的，类型经常会是在当前的编译单元是不相交的，但在未来的某次编译中，为了潜在的扩展，编译器必须做保守估计。</p><p>分离编译就是为什么我们的形式化需要两个参数来表述类继承架构的原因。System FM的一个特定的实例化可以被理解为Scala类型系统对于某一特定编译单元的一个模型，其中C表示<em>目前已经</em>定义的类。类继承关系$\Psi$，对于所有子编译单元有效：新的定义不会改变之前定义的继承关系。然而，类继承关系$ \Psi $自己并不足以得到两个类的不相交性：新的类定义可能引入两个已经存在的类的交集。因此，我们的形式化使用了一个分开的参数（$ \Xi $）去描述类的不相交关系。对于分离编译，$\Xi$应该只包含那些即使考虑了潜在的对于类集合的扩充也仍然保持不相交的类的对。</p><p>感谢Scala提供了多种途径限制可扩展性。trait和类上的<em>sealed</em>和<em>final</em>表记直接限制了标注类型的可扩展性：sealed类型只能声明的在同一个文件里被扩展，于是提供了一个枚举所有子类的途径。因此，sealed trait和类的的不相交性可以通过遍历这个类型的每个可能的子类型来递归地计算。trait和类的主要区别是类最多只能继承一个父类。这个性质使编译器可以通过一个简单的检查断言两个类的不相交性：给定两个类A和B，如果A不是B的子类型，B也不是A的子类型，那么没有类可以同时继承这两者，所以他们就是不相交的。</p><p>作为一个例子，考虑下面的Scala定义（左边）和对应的System FM的实例化（右边）：</p><p><img src="https://www.z4a.net/images/2022/03/01/image-20220217163639531.png" alt="image-20220217163639531.png"></p><p>类和继承关系在两种表示中几乎是同构的。Scala的类与FM中的是一一对应的（首字母缩写），继承关系只包含了一个额外的R和V，通过传递性（$\Psi$的自反性和$\Xi$的对称性为了简便而省略了）。</p><p>P被声明是sealed，意味着在这个编译单元没有外部的定义了。所以，我们可以枚举所有的Part，得到其中没有一个是vehicles，所以$\text{(P,V)}\in\Xi$。注意如果W或者D不是final的话就不行了，因为扩展这些类可以间接创建新的Part。B和H都是类，并且互相没有继承，所以$\text{(B,H)}\in\Xi$，因为Scala最多只能继承一个类。然而V和H不能从这些定义中得出是否不相交的结论。如果需要这个结论的话，可以通过把V变成sealed或者把H变成final得到。</p><h3 id="4-2-空类型"><a href="#4-2-空类型" class="headerlink" title="4.2 空类型"></a>4.2 空类型</h3><p>与Scala相比System FM的一个重要的限制是不支持空类型。Scala子类型格的bottom，称为Nothing，提供了一个直接的方式去指代一个值的空集。交集类型同样提供了一种方式构造没有居留元的类型，因为Scala不禁止两个不相交类型的交。空类型在match type的归约时会有问题，因为它打破了一个基础的假设：两个类型不能既是子类型关系又不相交（Lemma3.5）。为了解决这个问题，我们的实现在做归约之前，在scrutinee类型上使用了一个额外的居留性检查。</p><p>为了展示为什么空类型会带来问题，我们可以构造一个例子，其中缺少了这个居留性检查，相同的match type可以在两个不同的上下文中归约到不同的结果：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">M</span>[<span class="type">X</span>] </span>= <span class="type">X</span> <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">Int</span> =&gt; <span class="type">String</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">String</span> =&gt; <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">X</span></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">f</span>(<span class="params">bad: <span class="type">M</span>[<span class="type">X</span> &amp; <span class="type">String</span>]</span>)</span>: <span class="type">Int</span> = bad</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">X</span> </span>= <span class="type">Int</span></span><br><span class="line">    <span class="comment">// f(bad: M[Int &amp; String]): Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，在C中的f的定义是type-check的，因为<code>X &amp; String</code>和<code>Int</code>是不相交的（因为String和Int是不相交的），而<code>M[X &amp; String]</code>归约到Int（M的第二个case）。D类通过给出X=Int精化了C的定义。unsoundness自己在D类的体中就体现出来了，其中<code>X &amp; String</code>是Int的一个子类型，而<code>M[X &amp; String]</code>归约到String（M的第一个case）。这样，就可以通过一个string参数调用f，会得到一个运行时错误。而检查scrutinee的居留性可以防止这个错误。在这个例子里，他会防止<code>M[Int &amp; String]</code>做归约，因为<code>Int &amp; String</code>没有居留元。</p><h3 id="4-3-空值"><a href="#4-3-空值" class="headerlink" title="4.3 空值"></a>4.3 空值</h3><p>在Scala3中，null不再在所有类型中居留了：nullable的类型需要额外的表记，形如<code>A | Null</code>。我们的子类型和不相交性的实现处理了和类型，所以不需要对空值做单独考虑。</p><h3 id="4-4-Variance"><a href="#4-4-Variance" class="headerlink" title="4.4 Variance"></a>4.4 Variance</h3><p>Scala支持在higher-kinded类型的参数上的variance。这些表记允许程序员特化表记的参数的子类型是如何影响higher-kinded类型的子类型的。例如，<code>type F[+T]</code>定义了一个类型F是它第一个类型参数的协变，意味着如果T1是T2的子类型，那么F[T1]是F[T2]的子类型。反变，写作<code>type G[-T]</code>，是相反的意思：如果T1是T2的子类型，那么G[T2]是G[T1]的子类型。</p><p>协变和反变的类型似乎总是有相交的，因为对于所有的类型X，都有<code>F[Nothing] &lt;: F[X]</code>和<code>G[Any] &lt;: G[X]</code>（其中Nothing和Any是Scala的bottom和top类型）</p><blockquote><p>这段我还没反应过来啥意思，看了后面的例子懂了：</p><p>就是实例化两个F[X]、F[Y]（或者G[X]、G[Y]）的话，就都有F[Nothing] &lt;: F[X]和F[Nothing] &lt;: F[Y]，也就是F[Nothing]的居留元也是F[X]，F[Y]的，这就相交了。</p><p>不过后面讲了，协变的话Nothing作参数的是不会实例化的，所有没有关系。</p></blockquote><p>然而，在协变参数的情况下，当这个类型变量对应着一个field或者构造子的参数的时候，可以做一个例外：Nothing的实例化可以被除外，因为没有任何的运行时程序可以给出一个Nothing类型的值。</p><blockquote><p>这里的实例化大概是<code>F[Nothing]</code>这个东西，就像Nothing一样可以不考虑了，因为不存在居留元。</p></blockquote><p>比如Scala中的tuple就是这一类的情况。<code>Tuple2</code>是二元组的类，定义如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple2</span>[+<span class="type">T1</span>, +<span class="type">T2</span>](<span class="params">_1: <span class="type">T1</span>, _2: <span class="type">T2</span></span>)</span></span><br></pre></td></tr></table></figure><p>给定两个这个类型的实例化，<code>Tuple2[Int, X]</code>和<code>Tuple2[String, X]</code>。尽管<code>Tuple2[Nothing, X]</code>是它们两个共同的子类型，因为这个类型没有居留元，所以结果是这两个类型还是不相交的。我们的不相交算法实现了这样的推理，得出现有的协变类型参数的不相交性。</p><h3 id="4-5-Pattern-Matching-Exhaustivity"><a href="#4-5-Pattern-Matching-Exhaustivity" class="headerlink" title="4.5 Pattern Matching Exhaustivity"></a>4.5 Pattern Matching Exhaustivity</h3><p>Scala编译器会检查pattern matching的穷尽性来避免由缺少了cases导致的运行时异常。穷尽性通过静态的类继承结构的知识（比如sealed和final表记）来检查在scrutinee类型的每个值是否都被pattern分句包括了。非穷尽的pattern被编译后会附加一个匹配所有情况然后抛出一个运行时异常。System FM使用缺省cases代替系统上的穷尽性检查和运行时异常。</p><h3 id="4-6-运行时的类型"><a href="#4-6-运行时的类型" class="headerlink" title="4.6 运行时的类型"></a>4.6 运行时的类型</h3><p>Scala的主要平台是Java虚拟机（JVM）。在JVM上，Scala使用<em>偏擦除（patial erasures）</em>，即部分的类型保留并翻译到JVM的类型系统，另外部分被擦除，来进行编译。例如，ground class会被直接编译到JVM的类，但类型参数和类型变量会被擦除，并被他们所绑定的东西代替。</p><p>擦除直接影响了可以在运行时完成的类型测试。例如，即使<code>case xs: List[Int] =&gt;</code>是一个符合语法的pattern，但这会产生一个编译器警告，因为Int类型参数会被擦除，而不能够在运行时被检查。</p><p>这个限制在我们形式化中通过match expression的求值规则和match types的归约规则的区别被反应出来了：求值是限制于静态定义的类（在$\text{E-MATCH2/3}$中的$(C,C_n)\in\Psi$），而match type的归约规则是使用子类型和类型不相交性（在$\text{S-MATCH1/2/3/4}$中的$\Gamma\vdash T_s&lt;:S_n$和$\Gamma\vdash disj(T_s,S_m)$）。</p><p>在System FMB中，match expression支持两种参数化pattern：既可以是实例化的（<code>match{xs:List Int}</code>，其中$Int\in A$），也可以是用一个绑定pattern变量（<code>match[X]{xs: List X}</code>，其中X是pattern variable）。在这个意义上，System FMB比Scala表达力更强，因为实例化的pattern在term level由于类型擦除而不可用了。</p><h3 id="4-7-不停机"><a href="#4-7-不停机" class="headerlink" title="4.7 不停机"></a>4.7 不停机</h3><p>不同于我们的演算，Scala的实现同样允许match types也递归定义。递归的match types会导致子类型检查无限循环。我们的实现并不检查match types的终止性，因为这样的检查会限制表达能力和便利性。我们通过一个储能机制检查在match type归约时的异常。编译器给定一个初始的能量，每次归约会消耗一个单位。如果编译器没能量了，就停止归约报错“递归超限”。目前的实现是使用一个固定的初始能量值。尽管这看起来对于大部分的实践已经足够，我们还是计划让它可以被设置。这个机制完全是标准的，也已经在很多其他的编程语言中的类型层面的无限递归上使用了。</p><h3 id="4-8-类型推断"><a href="#4-8-类型推断" class="headerlink" title="4.8 类型推断"></a>4.8 类型推断</h3><p>System FM的类型规则使得任何的match表达式会定型为一个match type，但在完整的Scala语言中不是这样。Scala的pattern matching支持很多种patterns，大多数并没有match type的对应。进一步的，为了保持向下兼容，不能默认把match expression定型成match types。取而代之的是，必须提供一个显式的类型注解。</p><h3 id="4-9-缓存"><a href="#4-9-缓存" class="headerlink" title="4.9 缓存"></a>4.9 缓存</h3><p>Scala的类型检查算法重度使用缓存来提高性能。而缓存match type归约结果的时候必须采取特别的注意，因为子类型和不相交性检查是上下文相关的。我们的实现对match types使用了一个上下文相关的缓存，可以使得这个结果在新的上下文是自动无效化。朴素的缓存出错的例子见6.4。</p><h3 id="4-10-实现的规模"><a href="#4-10-实现的规模" class="headerlink" title="4.10 实现的规模"></a>4.10 实现的规模</h3><p>我们的match type的实现对于Scala编译器总的改动大于1500行代码。</p><h2 id="5-案例研究：形状安全的numpy"><a href="#5-案例研究：形状安全的numpy" class="headerlink" title="5. 案例研究：形状安全的numpy"></a>5. 案例研究：形状安全的numpy</h2><p>在这段中，我们通过一个案例研究展示怎么使用match types来表达复杂的类型限制，可以在编译期避免特定的程序错误。为此，我们提供type-level实现的一个多维数组的库的概览，它可以模拟NumPy的API。我们库的目标是提供一个操作n维数组<em>形状</em>安全的接口，其中数组的形状和indice可以被编译期检查，而不是运行时错误。形状和下标的错误在多维数组中是一个广为人知的问题，且已经提出了多个解决方案，尤其是以type-level编程的库的形式出现。我们的库使用的match types提供一个NumPy-like的形状安全的接口。</p><p>Scala程序员使用特设的（ad-hoc）方法解决type-level编程问题已经有很长的历史了。这些解决方案有一些缺点，比如编译缓慢，使用也很累赘。Match types旨在简化type-level编程，提供first-class的语言支持。我们相信在这个案例里面展示的这个做法改进了现状，因为它没有使用元编程或者错综复杂的隐式编码来表达type-level的操作。</p><h3 id="5-1-Python中的形状错误"><a href="#5-1-Python中的形状错误" class="headerlink" title="5.1 Python中的形状错误"></a>5.1 Python中的形状错误</h3><p>在下面的Python代码的例子中，<code>img_batch</code>这个多维数组是25个随机生成的256*256的RGB图片。这个代码是要计算一个长为25的向量来储存这里面每个图片的平均灰度，并且生成一个5*5的图片来表示这个平均灰度的颜色。然而，这个代码存在一个形状错误然后会在运行时出错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img_batch = np.random.normal(size=(<span class="number">25</span>, <span class="number">256</span>, <span class="number">256</span>, <span class="number">3</span>))</span><br><span class="line">avg_colors = np.mean(img_batch, (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">avg_color_square = np.reshape(avg_colors, (<span class="number">5</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>这个错误是在np.mean的调用中出现的，它需要一个要做reduce操作的维度的列表作为参数。不幸的是，这个给np.mean的参数都少了一个，结果变成了长度为3（最后一个维度），而不是长度为25（第一个维度）；结果就变成了这25张图片的所有RGB分量的均值，而不是25张图片每张的平均灰度了。然后这个reshape操作会在运行时出错，因为它不能把一个3元素的数组转成一个25元素的矩阵。这个错误可能很难定位，因为NumPy的接口reduce维度的时候是基于下标的。想这样的运行时错误如果在很长的计算中出现会带来很大的困扰。</p><blockquote><p>研究了一下numpy里面的维度，就是mean是个array的reduce操作，给定一个维度，它可以把n维的变成n-1维。这里有一个25*256*256的数组，想要reduce成一个长度为25的，那就要是<code>np.mean(..., (1,2,3))</code>，把后三个维度reduce掉。所以这里的bug刚好差了一个维度。</p></blockquote><p>接下来，我们会展示如何使用match types避免这类的错误。在初步介绍了singleton type（5.2）之后，我们使用HList引入type level的多维数组形状（5.3）。在5.4中，我们展示了np.mean和np.reshape操作基于match types的type-level实现。最后，我们展示了这个新API怎么检查和报出上面这个Python例子的错误的。</p><h3 id="5-2-Singleton-Types"><a href="#5-2-Singleton-Types" class="headerlink" title="5.2 Singleton Types"></a>5.2 Singleton Types</h3><p>Scala支持Singleton types，是只有一个值的类型。比如，单例类型<code>1</code>表示包含整数1的类型。Scala标准库包括了几个预定义的match types来表达类型层面的算术计算。例如<code>type +[A &lt;: Int,B &lt;: Int]</code>表示两个整数单例类型的和。在内部，编译器对于这些算术运算时特判使用常量折叠的方式实现的。使用单例类型表示数字在实用性上是需要的，但在这个案例中不是必要的（比如用皮亚诺数字也是可以的）。</p><h3 id="5-3-Type-level数组形状"><a href="#5-3-Type-level数组形状" class="headerlink" title="5.3 Type-level数组形状"></a>5.3 Type-level数组形状</h3><p>多维数组的形状是一个维度长度的列表；我们说形状$(a_1,a_2,\dots,a_n)$有n维。比如，一个三乘四的矩阵是一个形状是$(3,4)$的二维数组。我们在type level用一个异质类型列表来表示多维数组的形状，称为Shape。我们把这个HList定义成一个有两个构造子的ADT：<code>#:</code>和<code>Ø</code>.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Shape</span> &#123;</span><br><span class="line"><span class="keyword">case</span> #:[<span class="type">H</span> &lt;: <span class="type">Int</span>, <span class="type">T</span> &lt;: <span class="type">Shape</span>](head: <span class="type">H</span>, tail: <span class="type">T</span>)</span><br><span class="line"><span class="keyword">case</span> Ø</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原文注：为了清楚起见，我们的表达省略的类型推断所必要的类型边界，比如在Shape类型的定义中</p><p>异质列表在Haskell的类型编程里面也介绍过，就是列表的元素的类型可以不同的，而取而代之的是这些类型是编码在列表的类型中的。虽然这里列表里面的值在term level看起来都是Int，但是type level上编码出类型（类似于一个依值类型），它其实每个元素的类型是不同的（不同的singleton type）。</p></blockquote><p>这个类型的定义使我们可以在term level写<code>#:(3, #:(4, Ø))</code>，也可以在type level写<code>#:[3, #:[4, Ø]]</code>。HList类型可以把<code>#:</code>写作中缀形式：<code>3 #: 4 #: Ø</code>。</p><p>为了表示n维数组，我们定义<code>NDArray</code>类型。这个类型以多维数组元素类型和多维数组的形状为参数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">NDArray</span>[<span class="type">T</span>, <span class="type">S</span> &lt;: <span class="type">Shape</span>]</span></span><br></pre></td></tr></table></figure><p>我们的目标是在多维数组上定义类型安全的操作，所以我们没有包括值层面上的T和S的定义，但在完整实现中是需要的。</p><p>为了构造多维数组，我们定义了<code>random_normal</code>，创建一个给定形状的多维数组，元素为随机的浮点数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_normal</span></span>[<span class="type">S</span> &lt;: <span class="type">Shape</span>](shape: <span class="type">S</span>): <span class="type">NDArray</span>[<span class="type">Float</span>, <span class="type">S</span>] = ???</span><br></pre></td></tr></table></figure><blockquote><p>原文注：这个片段使用了三个问号的操作符，是Scala标准的表示缺失实现的记法。</p></blockquote><h3 id="5-4-用Match-Types在形状上做计算"><a href="#5-4-用Match-Types在形状上做计算" class="headerlink" title="5.4 用Match Types在形状上做计算"></a>5.4 用Match Types在形状上做计算</h3><p>在类型层面编码多维数组的类型和形状使我们可以提供多维数组类型和形状安全的简单操作。例如，元素层面的哈达玛积积，写作<code>np.multiply(x, y)</code>，需要数组x和y形状和元素类型都相同。这个限制不需要match types，可以直接表示为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>[<span class="type">T</span>, <span class="type">S</span> &lt;: <span class="type">Shape</span>](x: <span class="type">NDArray</span>[<span class="type">T</span>, <span class="type">S</span>], y: <span class="type">NDArray</span>[<span class="type">T</span>, <span class="type">S</span>]): <span class="type">NDArray</span>[<span class="type">T</span>, <span class="type">S</span>] = ???</span><br></pre></td></tr></table></figure><p>然而，对于在数组形状上更复杂的限制，比如reshapes（5.4.1）和reduction（5.4.2）就需要用到match type了。</p><h4 id="5-4-1-Reshape"><a href="#5-4-1-Reshape" class="headerlink" title="5.4.1 Reshape"></a>5.4.1 Reshape</h4><p>在NumPy中经常用到的一个操作<code>np.reshape</code>，可以改变一个多维数组的形状，但是不改变它里面的值。NumPy API里面的限制是输出的形状的元素数量要和输入的一致。形状的元素数量是所有维度的大小的乘积；比如形状<code>2 #: 3 #: 4 #: Ø</code>就有$2\times 3\times 4=24$个元素。注意形状为<code>Ø</code>的数组是一个标量，所以只有一个元素。这样可以很自然的用match type表达：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">NumElements</span>[<span class="type">X</span> &lt;: <span class="type">Shape</span>] <span class="title">&lt;</span></span>: <span class="type">Int</span> =</span><br><span class="line">    <span class="type">X</span> <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> Ø =&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> head #: tail =&gt; head * <span class="type">NumElements</span>[tail]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>为了限制reshape只能用于有效的形状，类型系统必须要支持编码一个类型相等的限制。为此，我们利用了Scala的隐式参数，和Scala标准库中的<code>=:=</code>类型相等性限制。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reshape</span></span>[<span class="type">T</span>, <span class="type">From</span> &lt;: <span class="type">Shape</span>, <span class="type">To</span> &lt;: <span class="type">Shape</span>](array: <span class="type">NDArray</span>[<span class="type">T</span>, <span class="type">From</span>], newshape: <span class="type">To</span>)</span><br><span class="line">(<span class="keyword">implicit</span> ev: <span class="type">NumElements</span>[<span class="type">From</span>] =:= <span class="type">NumElements</span>[<span class="type">To</span>]): <span class="type">NDArray</span>[<span class="type">T</span>, <span class="type">To</span>] = ???</span><br></pre></td></tr></table></figure><blockquote><p>这个隐式类型参数和我接触过的依值类型编程语言Agda很像，就是像这样type level的一些限制，其实在类型推断的上下文里面都是有的，不用在调用的时候提供，但编译器推断的时候会自动填进去然后检查。这里的ev的类型就是这个限制的一个witness，就很像依值类型里面干的事情了。</p></blockquote><p>使用reshape的这个定义，编译器就会只接受能够证明新旧元素数量相等的那些调用了。这个例子表明了在有单例类型和隐式参数求解下如何使用match types表达强大的限制。</p><h4 id="5-4-2-Reduction"><a href="#5-4-2-Reduction" class="headerlink" title="5.4.2 Reduction"></a>5.4.2 Reduction</h4><p>NumPy API提供了很多函数在一个维度的集合上对一个多维数组进行reduce，比如<code>np.mean(ndarray, axes)</code>和<code>np.var(ndarray, axes)</code>。<code>axes</code>这个参数是一个维度的列表，列出结果中不再存在的那些维度。维度的列表可以是无序的和重复的，而超界的会产生一个错误。在Python API中，如果传一个<code>None</code>取而代之的话，就会对所有维度都reduce，也就是最后得到一个标量。注意到这与传入一个<code>Ø</code>相反，它表示不reduce任何维度。</p><p>这个行为就比之前的例子更复杂了，但仍然可以精确地用match type来表达。我们使用一个match type <code>Reduce</code>，计算这个操作之后的返回的形状。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mean</span></span>[<span class="type">T</span>, <span class="type">S</span> &lt;: <span class="type">Shape</span>, <span class="type">A</span> &lt;: <span class="type">Shape</span>](array: <span class="type">NDArray</span>[<span class="type">T</span>, <span class="type">S</span>], axes: <span class="type">A</span>): <span class="type">NDArray</span>[<span class="type">T</span>, </span><br><span class="line"><span class="type">Reduce</span>[<span class="type">S</span>, <span class="type">A</span>]] = ???</span><br></pre></td></tr></table></figure><p>我们实现给定一个列表的indice的reduction类似于两个嵌套的循环。外层的循环Loop遍历形状并计数当前的下标。内层的循环使用HList上的标准操作Contains和Remove（细节省略）。当Loop到了list的末尾，如果还有要去除的维度，这些就是对于原来的形状超界了：match types故意在这个情况下get stuck。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Reduce</span>[<span class="type">S</span> &lt;: <span class="type">Shape</span>, <span class="type">Axes</span> &lt;: <span class="type">None</span> | <span class="type">Shape</span>] <span class="title">&lt;</span></span>: <span class="type">Shape</span> =</span><br><span class="line">    <span class="type">Axes</span> <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt; Ø</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Shape</span> =&gt; <span class="type">Loop</span>[<span class="type">S</span>, <span class="type">Axes</span>, <span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Loop</span>[<span class="type">S</span> &lt;: <span class="type">Shape</span>, <span class="type">Axes</span> &lt;: <span class="type">Shape</span>, <span class="type">I</span> &lt;: <span class="type">Int</span>] <span class="title">&lt;</span></span>: <span class="type">Shape</span> =</span><br><span class="line">    <span class="type">S</span> <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> head #: tail =&gt; <span class="type">Contains</span>[<span class="type">Axes</span>, <span class="type">I</span>] <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="literal">true</span> =&gt; <span class="type">Loop</span>[tail, <span class="type">Remove</span>[<span class="type">Axes</span>, <span class="type">I</span>], <span class="type">I</span> + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">case</span> <span class="literal">false</span> =&gt; head #: <span class="type">Loop</span>[tail, <span class="type">Axes</span>, <span class="type">I</span> + <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Ø =&gt; <span class="type">Axes</span> <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> Ø =&gt; Ø</span><br><span class="line">            <span class="comment">// otherwise, do not reduce further</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-形状安全"><a href="#5-5-形状安全" class="headerlink" title="5.5 形状安全"></a>5.5 形状安全</h3><p>我们定义了<code>random_normal</code>，<code>reshape</code>和<code>mean</code>，就可以在Scala中重写原来Python的例子了：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> img_batch = random_normal(#:(<span class="number">25</span>, #:(<span class="number">256</span>, #:(<span class="number">256</span>, #:(<span class="number">3</span>, Ø)))))</span><br><span class="line"><span class="keyword">val</span> avg_colors = mean(img_batch, #:(<span class="number">0</span>, #:(<span class="number">1</span>, #:(<span class="number">2</span>, Ø))))</span><br><span class="line"><span class="keyword">val</span> avg_color_square = reshape(avg_colors, #:(<span class="number">5</span>, #:(<span class="number">5</span>, Ø)))</span><br></pre></td></tr></table></figure><p>和预料的一样，对mean的调用会返回一个形状<code>3 #: Ø</code>。因此，reshape的调用不会通过类型检查，因为形状的元素数量是3而不是25。如果我们把错误的地方修改成<code>1 #: 2 #: 3 #: Ø</code>，对reshape的调用就可以通过类型检查，avg_color的形状也是预期中的<code>25 #: Ø</code>。</p><h2 id="6-相关工作"><a href="#6-相关工作" class="headerlink" title="6. 相关工作"></a>6. 相关工作</h2><p>在这一段中，我们重新审视了现有的工作并把match types和dependently typed calculi with subtyping，intensional type analysis，Haskell中的type families和roles和TypeScript中的conditional types做了关联。</p><h3 id="6-1-Dependently-Typed-Calculi-with-Subtyping"><a href="#6-1-Dependently-Typed-Calculi-with-Subtyping" class="headerlink" title="6.1 Dependently Typed Calculi with Subtyping"></a>6.1 Dependently Typed Calculi with Subtyping</h3><p>对于把子类型和依值类型结合起来有很多的文献，因此有必要进行全面的调查。相反的，我们提供了我们的阅读之旅的一个浓缩的总结，并解释了是什么让我们决定使用System F&lt;:作为我们形式化的基础。</p><p>Dependently Typed Calculi典型地使用同一套语言来描述terms和types。这个归一化在有子类型的情况下同样经常使用。对于term/type有完整对称性的系统来说，这是一个自然的设计，因为这很简练并简化了元理论。遗憾的是，缺少term和type的区别使得这些系统对于我们的目的来说不现实，因为我们的研究是要在一个已有term和type区别的语言上做的。</p><p>单例类型在统一和分离的语法之间提供了一个有趣的中间地带，并且在依值类型和子类型的关联中经常被研究。单例类型提供了一种在type中引用term的机制，经常是通过一个类似于集合的语法。这个机制很吸引人，因为它允许类型系统设计者精心挑选可以在类型层面出现的项的构造。当term和type共享很多的构造子的时候，单例类型提供了我们一个清晰的概念。在我们对match types的研究中，对单例类型的最小化使用使得term和type语言共享一个构造子：match的构造子。目前尚不清楚这样做的好处是否会超过额外的复杂性。</p><p>Dependent Object Types（DOT）到目前为止Scala类型系统形式化的最重要的工作。DOT 不直接支持任何形式的type-level计算。我们考虑使用 DOT 作为我们工作的起点，除去最近简化 DOT 的soundness证明 ，扩展 DOT 仍然是一个太大的挑战，无法简洁地描述语言扩展。</p><p>在多次尝试在现有系统中形式化匹配类型之后，我们决定采用一种更简单的方法，在没有依值类型的系统中添加新的构造。毕竟，System FM 的主要目的是作为一种媒介来简明地<em>解释</em>我们的match types的类型检查算法。出于这个原因，我们将我们的工作建立在 System F&lt;: 之上，我们认为它应该是本节引用的系统中最简单、最熟悉的演算。</p><h3 id="6-2-Intensional-Type-Analysis"><a href="#6-2-Intensional-Type-Analysis" class="headerlink" title="6.2 Intensional Type Analysis"></a>6.2 Intensional Type Analysis</h3><p>在Intensional Type Analysis工作中，Harper and Morrisett引入了$\lambda_i^{ML}$演算支持类型的结构分析。在此之中，类型被表示成可以被“typecase”构造进行case analysis检查的一个表达式，term和type level都支持。Match types可以看成Intensional Type Analysis对于面向对象类继承结构和子类型的一个扩展。$\lambda_i^{ML}$的pattern是受限到一个固定的不相交集合的，而match types需要处理一个开放的类继承关系，而并不是所有的成员都是编译期知道的。这意味着pattern类型可能重叠，我们需要在scrutinee类型和每个pattern类型之间进行一个不相交性分析。不相交性使我们在有重叠pattern和抽象scrutinee类型时可以做安全的归约，同时保留了模式匹配的自然的顺序求值的顺序。</p><h3 id="6-3-Haskell的类型家族"><a href="#6-3-Haskell的类型家族" class="headerlink" title="6.3 Haskell的类型家族"></a>6.3 Haskell的类型家族</h3><p>Haskell的类型家族允许程序员可以使用模式匹配定义type-level的函数。默认情况下，类型家族是open的，意味着一个定义可以在多个文件和编译中蔓延。这个灵活性给类型家族带来了一个严格的限制：pattern不能重叠。这个限制的一个好处是它防止了类型家族做归约时候的二义性（pattern两两不相交），这对于分开的定义来说是必需的。Open的类型家族非常适合和类型类结合，因为这两个构造都是由不相交限制而开放定义的。</p><p>Closed的类型家族（CTFs）允许类型家族的重叠定义。不像open的变种，CTF的归约是顺序的，基于归一化和apartness检查。这样看来，CTFs和match types就很像了。事实上，如果我们把unification检查换成subtyping，把apartness检查换成不相交性，他们的归约算法和我们的完全一致，从一个高阶的角度来看的话。</p><p>默认情况下，Haskell会检查递归类型家族的停机性，但是这个检查也可以关掉来提高类型家族的表达能力。尽管目前的形式化没有包括不终止的类型家族，这个论文讨论了不停机性带来的soundness问题。这个问题只在pattern中存在重复类型绑定时出现。在Scala中，match types（和广义的模式匹配）不允许重复的绑定，所以不受这个问题的影响。</p><h3 id="6-4-Haskell中的类型角色"><a href="#6-4-Haskell中的类型角色" class="headerlink" title="6.4 Haskell中的类型角色"></a>6.4 Haskell中的类型角色</h3><p>Haskell中引入类型角色来解决一个持续了很长时间的，有open类型家族和newtype构造结合带来的unsoundness问题。我们理解类型角色是一个类型的注解来指定一个类型是否可以安全地名义上的和其他类型比较，还是说应该使用<em>representational equality(RE)</em> 。在RE中的representation是指一个类型在运行时的表示。具体来说，RE是newtype别名的析构。</p><p>如果没有类型角色的话，类型家族的归约会有unsoundness。这个例子翻译成Scala是这样的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">AgeClass</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Age</span></span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">addAge</span>(<span class="params">a: <span class="type">Age</span>, i: <span class="type">Int</span></span>)</span>: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">AgeObject</span> <span class="keyword">extends</span> <span class="title">AgeClass</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Age</span> </span>= <span class="type">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addAge</span></span>(a: <span class="type">Age</span>, i: <span class="type">Int</span>): <span class="type">Int</span> = a + i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Age在AgeClass里面是抽象的，在AgeObject里是具体的。在Haskell没有类型角色的情况下，如果这个例子和一个区分Int和Age的类型家族结合就会unsound。这样的类型家族在AgeClass中会reduce得不一样，因为类型不一样，而在AgeObject中因为两个类型是同义，所以会得到一个运行时错误。</p><p>幸运的是我们的match types没有这个问题。因为子类型（和不相交性）会保护我们的实现防止在Age是抽象的时候错误的区分Int和Age。考虑下面的match type（直接翻译自Haskell出错的例子）：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">M</span>[<span class="type">X</span>] </span>= <span class="type">X</span> <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">Age</span> =&gt; <span class="type">Char</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Int</span> =&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的算法在AgeClass不会把<code>M[Int]</code>reduce到Bool，因为这个归约需要提供Age和Int不相交，但是当Age是抽象类型的时候这个无法做到。</p><h3 id="6-5-TypeScript的Conditional-Types"><a href="#6-5-TypeScript的Conditional-Types" class="headerlink" title="6.5 TypeScript的Conditional Types"></a>6.5 TypeScript的Conditional Types</h3><p>TypeScript的conditional types是一个基于子类型的type-level三目运算符。Conditional types可以嵌套在pattern的序列中，让它可以和match types类似。</p><p>TypeScript语言specification简要地介绍了有类型变量时的归约conditional types的算法。给定一个类型<code>S extends T ? Tt : Tf</code>， TypeScript编译器首先将S和T中的类型参数换成<code>any</code>（TypeScript子类型格的top）。如果替换的结果类型不是子类型关系，那么整个condition归约到Tf。不幸的是，这个算法既unsound又incomplete。</p><p>Unsoundness是因为在反变的地方错误的拓宽了类型变量。尽管TypeScript不提供variance的标注，但函数类型对于返回类型是协变的，对于参数类型是反变的。Conditional type的unification算法错误近似了<code>X =&gt; string</code>到<code>any =&gt; string</code>，把前者合一到后者，会导致一个运行时错误。</p><p>Incompleteness是因为类型参数的近似不能作为类型参数的边界。考虑下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> M&lt;X&gt; = X <span class="keyword">extends</span> <span class="built_in">string</span> ? A : B</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>&lt;<span class="title">X</span> <span class="title">extends</span> <span class="title">string</span>&gt;: <span class="title">M</span>&lt;<span class="title">X</span>&gt; = <span class="title">new</span> <span class="title">A</span></span></span><br></pre></td></tr></table></figure><p>这里，TypeScript的归约算法不能识别<code>new A</code>可以被定型为<code>M&lt;X&gt;</code>，尽管<code>X</code>显然是<code>f</code>体中的<code>string</code>的一个子类型。</p><p>尽管情况令人担忧，但考虑到稳健性不是 TypeScript 类型系统的目标，它可能并没有看起来那么糟糕。尽管如此，我们相信这篇论文的结果直接适用于条件类型，可以用来改进 TypeScript 的类型检查器。</p><h2 id="7-结论"><a href="#7-结论" class="headerlink" title="7. 结论"></a>7. 结论</h2><p>In this paper, we introduced match types, a lightweight mechanism for type-level programming<br>that integrates seamlessly in subtyping-based programming languages. We formalized match types<br>in System FM, a calculus based on System F&lt;:, and proved it sound. Furthermore, we implemented<br>match types in the Scala 3 compiler, making them readily available to a large audience of pro-<br>grammers. A key insight for sound match types is the notion of disjointness, which complements<br>subtyping in the match type reduction algorithm. In the future, we plan to investigate inference of<br>match types to avoid code duplication in programs that operate both at the term and the type level.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是POPL2022同名文章的中文翻译，無断転載禁止。&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;关于match types的Scala文档：&lt;a href=&quot;https://docs.scala-lang.org/scala3/reference/new-types/match-types.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.scala-lang.org/scala3/reference/new-types/match-types.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Type-level programming在FP越来越流行，但type-level programming和subtyping的组合还没有充分的探索。这篇文章中的match types等价于类型层面的pattern matching，在基于system F$_{&amp;lt;:}$的一个演算上形式化了match type这个feature，证明了它的soundness。在Scala3的reference compiler上实现了match types的系统。&lt;/p&gt;
    
    </summary>
    
      <category term="PL研究" scheme="https://121.5.103.67/categories/PL%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="函数式" scheme="https://121.5.103.67/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
      <category term="类型论" scheme="https://121.5.103.67/tags/%E7%B1%BB%E5%9E%8B%E8%AE%BA/"/>
    
      <category term="PL" scheme="https://121.5.103.67/tags/PL/"/>
    
  </entry>
  
  <entry>
    <title>【类型论】五、Types dependent on terms</title>
    <link href="https://121.5.103.67/2021/11/01/%E3%80%90%E7%B1%BB%E5%9E%8B%E8%AE%BA%E3%80%91%E4%BA%94%E3%80%81Types-dependent-on-terms/"/>
    <id>https://121.5.103.67/2021/11/01/【类型论】五、Types-dependent-on-terms/</id>
    <published>2021-11-01T11:58:23.000Z</published>
    <updated>2022-03-01T07:03:07.594Z</updated>
    
    <content type="html"><![CDATA[<p>本文为<em>Type Theory and Formal Proof : An Introduction</em> 的笔记，纯个人向（</p><hr><p>之前我们遇到了以下的依赖关系：</p><ul><li><em>依赖于项的项</em>：$\lambda_\to$.</li><li>依赖于项的项$+$<em>依赖于类型的项</em>：$\lambda2$.</li><li>依赖于项的项$+$<em>依赖于类型的类型</em>：$\lambda\underline{\omega}$.</li></ul><p>显然有一个扩展缺失了：</p><ul><li>依赖于项的项$+$<em>依赖于项的类型</em>：$\lambda{\rm P}$.</li></ul><a id="more"></a><p>一个依赖于项的类型形如：<br>$$<br>\lambda x : A . M<br>$$<br>其中$M$是一个类型，$x$是一个项变量（那么$A$一定是个类型）. $\lambda x : A.M$这个抽象<em>依赖于</em>项$x$.与上文相应的，“一个依赖于项的<em>类型</em>”其实是一个以类型为值的函数（type-valued function）或称类型构造子（type constructor）.</p><p>下面从集合和命题两方面介绍依赖于项的类型的作用：</p><ol><li><p>对任意$n:nat$，设$S_n$为集合. 不严谨地说，每个集合可以看做一个类型，那么$\lambda n:nat.S_n$是依赖于项$n$的一个类型（构造子）. 也可以说$\lambda n:nat. S_n$是一个由项$n$映射到集合$S_n$的函数.</p><p>另一个术语称为<strong>类型家族</strong>（family of types）（对于每个$n:nat$的类型）或称<strong>索引类型</strong>（indexed type）（以$n:nat$为索引）. </p><p>因为$n:nat$且$S_n:\ast$，所以$\lambda n:nat.S_n$有类型$nat\to\ast$.</p><p>一个常用的例子是：设$\langle v_1,\cdots,v_n \rangle$为$n$个自然数的序列，则$V_n={\langle v_1,\cdots,v_n\rangle|v_i\in\mathbb{N}}$是所有长度为$n$的自然数序列（向量），$\lambda n:nat.V_n$把$n$映射到所有长度为$n$的向量集合.</p></li><li><p>对任意$n:nat$，设$P_n$为命题. 那么$\lambda n:nat.P_n$也是一个类型（构造子），依赖于项$n$. 也可以说$\lambda n:nat. P_n$是一个由项$n$映射到命题$P_n$的函数. 这样的函数表达了逻辑中称为<strong>谓词</strong>（predicate）的东西. 例如，设$P_n$为命题“$n$为质数”，$\lambda n:nat.P_n$则是一个自然数是质数的谓词. </p></li></ol><p>我们把这个扩展了依赖于项的类型的类型系统称为$\lambda{\rm P}$，其中的$\rm P$就是来自谓词（predicate）.</p><h2 id="lambda-rm-P-的派生规则"><a href="#lambda-rm-P-的派生规则" class="headerlink" title="$\lambda{\rm P}$的派生规则"></a>$\lambda{\rm P}$的派生规则</h2><p>$\lambda{\rm P}$的派生规则和$\lambda\underline{\omega}$很类似：<br>$$<br>\begin{align}<br>(sort)\quad&amp;\emptyset\ \vdash\ \ast:\square\\\<br>(var)\quad&amp;\dfrac{\Gamma\ \vdash\ A:s}{\Gamma,\ x:A\ \vdash\ x:A}\quad 若x\notin \Gamma\\\<br>(weak)\quad&amp;\dfrac{\Gamma\ \vdash\ A:B\quad\Gamma\ \vdash\ C:s}{\Gamma,\ x:C\ \vdash\ A:B}\quad 若 x\notin \Gamma\\\<br>(form)\quad&amp;\dfrac{\Gamma\ \vdash\ A:\ast\quad\Gamma,\ x:A\ \vdash\ B:s}{\Gamma\ \vdash\ \Pi x:A.B:s}\\\<br>(appl)\quad&amp;\dfrac{\Gamma\ \vdash\ M:\Pi x:A.B\quad\Gamma\ \vdash\ N:A}{\Gamma\ \vdash\ M\ N\ :\ B[x:=N]}\\\<br>(abst)\quad&amp;\dfrac{\Gamma,\ x:A\ \vdash\ M:B\quad\Gamma\ \vdash\ \Pi x:A.B:s}{\Gamma\ \vdash\ \lambda x:A.M:\Pi x:A.B}\\\<br>(conv)\quad&amp;\dfrac{\Gamma\ \vdash\ A:B\quad\Gamma\ \vdash\ B’:s}{\Gamma\ \vdash\ A:B’}\quad 若B=_\beta B’<br>\end{align}<br>$$<br>与$\lambda\underline{\omega}$的主要不同在：</p><ol><li>$\to$-类型的升级. 在$\lambda{\rm P}$的$(form)$，$(appl)$，$(abst)$规则里没有$\to$-类型$A\to B$，取而代之的是$\Pi$-类型$\Pi x:A.B$. 这是一种推广，因为这样$x$可以作为自由变量出现在$B$中. 因此我们不再需要一个固定的$A$类型到$B$类型的函数类型，而是一个输出类型依赖于从输入类型$A$中选出的值$x$的<strong>依赖积</strong>（dependent product）.</li><li>输入类型的降级. 在$\lambda{\rm P}$中，我们有依赖于项的类型，但没有在$\lambda\underline{\omega}$中依赖于类型的类型，如$\Pi \alpha:\ast.\alpha\to\alpha$. 因此类型$\Pi x:A.B$在$\lambda P$中有“$x$是项”的性质，所以$A$的类型只能是$\ast$而不是$\square$. 对比$\lambda{\rm P}$和$\lambda\underline{\omega}$ 的$(form)$-规则.</li></ol><p>注意在$\Pi x:A.B$中，$B$可能依赖于$x$：</p><p>对于$(form)$，我们需要扩展第二个前提的上下文，将$\Gamma$变为$\Gamma,\ x:A$.</p><p>对于$(appl)$，我们需要选择与$x$的输入值$N$对应的输出类型$B[x:=N]$.</p><p>注意规则中可以对不同level使用，例如$(form)$-规则：</p><ol><li>$s=\ast$，则$A:\ast,\ B:\ast$且$\Pi x:A.B:\ast$</li><li>$s=\square$，则$A:\ast,\ B:\square$且$\Pi x:A.B:\square$</li></ol><p><strong>表记</strong>：在$\lambda{\rm P}$中，如果确定$x$不在$B$中自由出现，我们可以把$\Pi x:A.B$记作$A\to B$. 不过，正式地说，在$\lambda{\rm P}$中只有$\Pi$-类型，没有$\to$-类型.</p><blockquote><p>如果$A$是有限类型，假设有两个元素$a_1,\ a_2$，那么$\Pi x:A.B$刚好就是$B[x:=a_1]\times B[x:=a_2]$，即笛卡尔积. 因此$\Pi$-类型既可以看成笛卡尔积的推广，也可以看成函数空间的推广（若$x\notin FV(B)$，则$\Pi x:A.B$就是$A\to B$）. </p></blockquote><h2 id="lambda-rm-P-的派生例"><a href="#lambda-rm-P-的派生例" class="headerlink" title="$\lambda{\rm P}$的派生例"></a>$\lambda{\rm P}$的派生例</h2><p>$(1)\quad\emptyset\ \vdash\ \ast:\square\quad(sort)$</p><p>$(2)\quad A:\ast\ \vdash\ A:\ast\quad对(1)用(var)$</p><p>$(3)\quad A:\ast\ \vdash\ \ast:\square\quad对(1)和(1)用(weak)$</p><p>$(4)\quad A:\ast,\ x:A\ \vdash\ \ast:\square\quad对(3)和(2)用(weak)$</p><p>$(5)\quad A:\ast\ \vdash\ A\to\ast:\square\quad对(2)和(4)用(form)$</p><p>除了最后一行，其余的在$\lambda\underline{\omega}$中也可以派生. 第$(5)$行，我们派生出了超级类型$A\to\ast$，即$\Pi x:A.\ast$. 此时我们有了$\to$两边level不同的情况，这在$\lambda\underline{\omega}$中是不可能的. 注意$A\to\ast$是一个依赖于项的kind，而$P:A\to\ast$是一个依赖于项的类型，尽管它们依赖的项$x$看不到了，它在$\Pi x:A.\ast$里. 我们假设$P:A\to\ast$：</p><p>$(6)\quad A:\ast,\ P:A\to\ast\ \vdash\ P:A\to\ast\quad对(5)用(var)$</p><p>$(7)\quad A:\ast,\ P:A\to\ast\ \vdash\ A:\ast\quad对(2)和(5)用(weak)$</p><p>$(8)\quad A:\ast,\ P:A\to\ast\ \vdash\ \ast:\square对(3)和(5)用(weak)$</p><p>我们可以把$x$应用到$P$，得到类型$P\ x$：</p><p>$(9)\quad A:\ast,\ P:A\to\ast,\ x:A\ \vdash\ x:A\quad对(7)用(var)$</p><p>$(10)\quad A:\ast,\ P:A\to\ast,\ x:A\ \vdash\ P:A\to\ast\quad对(6)和(7)用weak$</p><p>$(11)\quad A:\ast,\ P:A\to\ast,\ x:A\ \vdash\ P\ x:\ast\quad对(10)和(9)用(appl)$</p><p>我们可以构造一个“真正”的体里有变量$x$出现的依值类型$\Pi x:A.P\ x$：</p><p>$(12)\quad A:\ast,\ P:A\to\ast\ \vdash\ \Pi x:A.P\ x\quad对(7)和(11)用(form)$</p><p>我们可以证明$P\ x\to P\ x$也是可派生的，然后构造另一个$\Pi x:A.P\ x\to P\ x$.</p><p>$(13)\quad A:\ast,\ P:A\to\ast,\ x:A,\ y:P\ x\ \vdash\ P\ x:\ast\quad对(11)和(11)用(weak)$</p><p>$(14)\quad A:\ast,\ P:A\to\ast,\ x:A\ \vdash\ P\ x\to P\ x:\ast\quad对(11)和(13)用(form)$</p><p>$(15)\quad A:\ast,\ P:A\to\ast\ \vdash\ \Pi x:A.P\ x\to P\ x:\ast\quad对(7)和(14)用(form)$</p><p>最后我们可以得到$\Pi x:A.P\ x\to P\ x$类型下有项：</p><p>$(16)\quad A:\ast,\ P:A\to\ast,\ x:A,\ y:P\ x\ \vdash\ y:P\ x\quad对(11)用(var)$</p><p>$(17)\quad A:\ast,\ P:A\to\ast,\ x:A\ x\ \vdash\ \lambda y:P\ x.y:P\ x\to P\ x\quad对(16)和(14)用(abst)$</p><p>$(18)\quad A:\ast,\ P:A\to\ast\ \vdash\ \lambda x:A.\lambda y:P\ x.y:\Pi x:A.P\ x\to P\ x\quad对(17)和(15)用(abst)$</p><p>综上，我们得到了：</p><ol><li>良类型性：$\lambda x:A.\lambda y:P\ x.y$是良类型的.</li><li>类型检查：检查了$A:\ast,\ P:A\to\ast\ \vdash\ \lambda x:A.\lambda y:P\ x.y:\Pi x:A.P\ x\to P\ x$</li><li>项的寻找：找到了$\Pi x:A.P\ x\to P\ x$类型在上下文$A:\ast,\ P:A\to\ast$中的项.</li></ol><h2 id="lambda-rm-P-中的最小谓词逻辑"><a href="#lambda-rm-P-中的最小谓词逻辑" class="headerlink" title="$\lambda{\rm P}$中的最小谓词逻辑"></a>$\lambda{\rm P}$中的最小谓词逻辑</h2><p>$\lambda{\rm P}$可以编码一个称为<strong>最小谓词逻辑</strong>（minimal predicate logic）的简单逻辑系统，它的逻辑操作只有<strong>蕴含</strong>（implication）和<strong>全称量化</strong>（universal quantification）. 这一谓词逻辑的基本实体有<strong>命题</strong>（propositions）、<strong>集合</strong>（sets）和<strong>集合上的谓词</strong>（predicates over sets）.</p><p>如前文所说，一个类型系统有PAT解释：</p><ul><li>如果项$b$有类型$B$（即$b:B$），$B$解释为一个命题，则$b$可以解释为$B$的一个<strong>证明</strong>. 这样的项$b$在类型论中称为<strong>证明对象</strong>（proof object）.</li><li>而当命题$B$不存在居留元（没有$b$使得$b:B$），则$B$不存在证明，$B$为<strong>假</strong>.</li></ul><h3 id="I-集合"><a href="#I-集合" class="headerlink" title="I. 集合"></a>I. 集合</h3><p>我们将一个集合$S$编码成一个类型，即$S:\ast$，集合的元素是项. 所以如果$a$是$S$的元素，则$a:S$，例如：</p><p>$nat:\ast,\ nat\to nat:\ast;\quad 3:nat,\ \lambda n:nat.n:nat\to nat$</p><h3 id="II-命题"><a href="#II-命题" class="headerlink" title="II. 命题"></a>II. 命题</h3><p>我们把命题也编码成类型. 所以如果$A$是命题，则$A:\ast$. 根据PAT-解释，这个$A$的居留元$p$编码了一个$A$的证明. </p><h3 id="III-谓词"><a href="#III-谓词" class="headerlink" title="III. 谓词"></a>III. 谓词</h3><p>一个谓词$P$是从一个集合$S$到所有命题集合的一个函数. 所以$P:S\to\ast$. </p><p>如果$P$是$S$上的一个任意的谓词，即$P:S\to\ast$，则对每个$a:S$，都有$P\ a:\ast$. 所有的$P\ a$都是命题，即类型（level 2），所以每个$P\ a$都可能有居留元. </p><ul><li>如果$P\ a$下有居留元，即存在$t$使得$t:P\ a$，则这个谓词对$a$成立.</li><li>如果$P\ b$下没有居留元，则这个谓词对$b$不成立.</li></ul><h3 id="IV-蕴含"><a href="#IV-蕴含" class="headerlink" title="IV. 蕴含"></a>IV. 蕴含</h3><p>使用PAT-解释，我们可以把$\Rightarrow$编码成$\to$：</p><ul><li>$A\Rightarrow B$为真.</li><li>如果$A$为真，则$B$也为真.</li><li>如果$A$有居留元，则$B$也有居留元.</li><li>存在函数将$A$的居留元映射到$B$的居留元.</li><li>存在$f$使得$f:A\to B$.</li><li>$A\to B$有居留元.</li></ul><p>所以$A\Rightarrow B$和$A\to B$有居留元等价. </p><p>我们可以通过$(appl)$-规则和$\Rightarrow$-消去、$(abst)$-规则和$\Rightarrow$-引入的对应关系免费获得蕴含的构造规则和消去规则. </p><h3 id="V-全称量化"><a href="#V-全称量化" class="headerlink" title="V. 全称量化"></a>V. 全称量化</h3><p>考虑对于集合$S$上某个依赖于$x$的谓词$P$的全称量化$\forall_{x\in S}(P(x))$. </p><ul><li>$\forall_{x\in S}(P(x))$为真.</li><li>对集合$S$中任意的$x$，命题$P(x)$为真.</li><li>对集合$S$中任意的$x$，类型$P\ x$下有居留元.</li><li>存在一个将每一个$S$中的$x$映射到$P\ x$ 居留元的函数（这个函数的类型是$\Pi x:X.P\ x$）.</li><li>存在$f$使得$f:\Pi x:S.P\ x$.</li><li>$\Pi x:S.P\ x$有居留元.</li></ul><p>与蕴含类似，我们将全称量化$\forall_{x\in S}(P(x))$编码为$\Pi$-类型$\Pi x:S.P\ x$.</p><p>同样地，$\forall$的构造和消去规则也可以看做$\lambda{\rm P}$中$(appl)$-和$(abst)$-规则的特例.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为&lt;em&gt;Type Theory and Formal Proof : An Introduction&lt;/em&gt; 的笔记，纯个人向（&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;之前我们遇到了以下的依赖关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;依赖于项的项&lt;/em&gt;：$\lambda_\to$.&lt;/li&gt;
&lt;li&gt;依赖于项的项$+$&lt;em&gt;依赖于类型的项&lt;/em&gt;：$\lambda2$.&lt;/li&gt;
&lt;li&gt;依赖于项的项$+$&lt;em&gt;依赖于类型的类型&lt;/em&gt;：$\lambda\underline{\omega}$.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;显然有一个扩展缺失了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;依赖于项的项$+$&lt;em&gt;依赖于项的类型&lt;/em&gt;：$\lambda{\rm P}$.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="小课堂" scheme="https://121.5.103.67/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="函数式" scheme="https://121.5.103.67/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
      <category term="教程" scheme="https://121.5.103.67/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="类型论" scheme="https://121.5.103.67/tags/%E7%B1%BB%E5%9E%8B%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【函数式】如何使用子类型多态</title>
    <link href="https://121.5.103.67/2021/06/05/%E3%80%90%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%91%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AD%90%E7%B1%BB%E5%9E%8B%E5%A4%9A%E6%80%81/"/>
    <id>https://121.5.103.67/2021/06/05/【函数式】如何使用子类型多态/</id>
    <published>2021-06-05T05:18:58.000Z</published>
    <updated>2021-06-05T08:36:30.398Z</updated>
    
    <content type="html"><![CDATA[<p>最近在尝试用Haskell实现Peter Shirley的<em>Ray Tracing in a Weekend</em>一书，发现了这个问题，并琢磨出了一些解法，看起来像是发现了一种设计模式，不过不知道叫什么名字（</p><a id="more"></a><h1 id="子类型多态"><a href="#子类型多态" class="headerlink" title="子类型多态"></a>子类型多态</h1><p>我们知道，子类型多态是OOP中一个很好用的特性，它可以做到把满足子类型关系的值放在同一个数据结构中，统一对它们操作，实现多态的效果。在OOP中，常常用这一特性实现称为<strong>接口</strong>的抽象类，比如：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Showable</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> X <span class="title">show</span><span class="params">(Y y, Z z)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowA</span> :</span> <span class="keyword">public</span> Showable&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ShowA(A a) &#123;...&#125;</span><br><span class="line">  <span class="function">X <span class="title">f</span><span class="params">(Y y, Z z)</span> </span>&#123;...&#125;</span><br><span class="line">  A a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowBC</span> :</span> <span class="keyword">public</span> Showable&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ShowBC(B b, C c) &#123;...&#125;</span><br><span class="line">  <span class="function">X <span class="title">f</span><span class="params">(Y y, Z z)</span> </span>&#123;...&#125;</span><br><span class="line">  B b;</span><br><span class="line">  C c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;Showable*&gt; l = &#123;ShowA(a), ShowBC(b, c)&#125;;</span><br><span class="line"><span class="keyword">for</span>(Showable* x : l)&#123;</span><br><span class="line">  x-&gt;f(y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>ShowA</code>，<code>ShowBC</code>都是<code>Showable</code>的子类型，都可以支持<code>show(y, z)</code>操作，所以可以把<code>ShowA</code>，<code>ShowBC</code>的值通过<code>Showable</code>类型进行统一操作。</p><h1 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h1><p>在Haskell语言中，并没有提供上述OOP意义上的子类型多态。但是类似的对于接口的定义和实现，由typeclass这一特性提供：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Showable</span> a <span class="keyword">where</span></span></span><br><span class="line">  show :: a -&gt; <span class="type">Y</span> -&gt; <span class="type">Z</span> -&gt; <span class="type">X</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">ShowA</span> = <span class="type">ShowA</span> <span class="type">A</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Showable</span> <span class="type">ShowA</span> <span class="keyword">where</span></span></span><br><span class="line">  show (<span class="type">ShowA</span> a) x y = ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">ShowBC</span> = <span class="type">ShowBC</span> <span class="type">B</span> <span class="type">C</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Showable</span> <span class="type">ShowBC</span> <span class="keyword">where</span></span></span><br><span class="line">  show (<span class="type">ShowBC</span> b c) x y = ...</span><br><span class="line"></span><br><span class="line"><span class="title">f</span> :: <span class="type">Showable</span> a =&gt; [a] -&gt; <span class="type">F</span></span><br><span class="line"><span class="title">f</span> l = <span class="keyword">let</span> x = map show l <span class="keyword">in</span> ...</span><br></pre></td></tr></table></figure><p>这是Haskell中经典的typeclass用法，对于f的参数可以是任意实现了<code>Showable</code>的类型的值，自动调用不同的<code>show</code>实现多态。</p><p>现在问题来了：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">la</span> :: [<span class="type">ShowA</span>]</span><br><span class="line"><span class="title">la</span> = [<span class="type">ShowA</span> a1, <span class="type">ShowA</span> a2] <span class="comment">-- OK, f la</span></span><br><span class="line"></span><br><span class="line"><span class="title">lb</span> :: [<span class="type">ShowBC</span>]</span><br><span class="line"><span class="title">lb</span> = [<span class="type">ShowBC</span> b1 c1, <span class="type">ShowBC</span> b2 c2] <span class="comment">-- OK, f lb</span></span><br><span class="line"></span><br><span class="line"><span class="title">l</span> = la ++ lb  <span class="comment">-- error</span></span><br></pre></td></tr></table></figure><p>由于Haskell类型系统的规定，list中是不能存放不同类型的值的，而typeclass不是具体的类型，因此即使实现了同一个typeclass，不同类型的值也不能放在列表中统一操作。</p><h1 id="再试试"><a href="#再试试" class="headerlink" title="再试试"></a>再试试</h1><p>既然是类型阻碍了我们，一般我们可以这么做：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">ShowableT</span> = <span class="type">SA</span> <span class="type">ShowA</span> | <span class="type">SB</span> <span class="type">ShowBC</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Showable</span> <span class="type">ShowableT</span> <span class="keyword">where</span></span></span><br><span class="line">  show (<span class="type">SA</span> a) = show a</span><br><span class="line">  show (<span class="type">SB</span> b) = show b</span><br><span class="line"></span><br><span class="line"><span class="title">l</span> = [<span class="type">SA</span> (<span class="type">ShowA</span> a), <span class="type">SB</span> (<span class="type">ShowBC</span> b c)]  <span class="comment">-- OK, f l</span></span><br></pre></td></tr></table></figure><p>在<code>ShowA</code>和<code>ShowBC</code>外面再包一层类型，这样就是同一个类型了（<br>类似的，比如要实现一个DSL的时候，可能有一些不同类型的表达式，就可以用这种方法把这些类型包成一个类型。  </p><p>但是这样，每增加一个对<code>Showable</code>的实现，都要在<code>ShowableT</code>中增加一种类型，不利于维护。于是更一般地，对于子类型多态（的模拟），可以这样做：  </p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE ExistentialQuantification #-&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Showable_</span> a <span class="keyword">where</span></span></span><br><span class="line">  show :: a -&gt; <span class="type">Y</span> -&gt; <span class="type">Z</span> -&gt; <span class="type">X</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Showable</span> = forall a. <span class="type">Showable_</span> a =&gt; <span class="type">Showable</span> a</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Showable_</span> <span class="type">Showable</span> <span class="keyword">where</span></span></span><br><span class="line">  show (<span class="type">Showable</span> a) = show a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">ShowA</span> = <span class="type">ShowA</span> <span class="type">A</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Showable_</span> <span class="type">ShowA</span> <span class="keyword">where</span></span></span><br><span class="line">  show (<span class="type">ShowA</span> a) x y = ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">ShowBC</span> = <span class="type">ShowBC</span> <span class="type">B</span> <span class="type">C</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Showable_</span> <span class="type">ShowBC</span> <span class="keyword">where</span></span></span><br><span class="line">  show (<span class="type">ShowBC</span> b c) x y = ...</span><br><span class="line"></span><br><span class="line"><span class="title">l</span> :: [<span class="type">Showable</span>]</span><br><span class="line"><span class="title">l</span> = [<span class="type">Showable</span> (<span class="type">ShowA</span> a), <span class="type">Showable</span> (<span class="type">ShowBC</span> b c)] <span class="comment">-- OK</span></span><br></pre></td></tr></table></figure><p>这一操作把typeclass包了一层类型，这样这一版本的<code>Showable</code>就类似于OOP版本里的抽象类了。这样实现就比较类似上面OOP风格的子类型多态了，可以在不同类型实现同一接口，也可以把实现了同一接口的类型放在一个数据结构里统一操作。</p><h1 id="然后呢"><a href="#然后呢" class="headerlink" title="然后呢"></a>然后呢</h1><p>这说明在Haskell里，嗯是要模拟出一种类似于接口类的编程范式也不是不行。然而这个写法构造数据的时候比较繁琐，且也可能影响性能。更重要的是，这个方法看起来太刻意了，不太像是正常的FP设计。</p><p>我意识到，我在一开始想模拟OOP的时候就中计了。正确的问法不应该是：“别人在OOP里写了个接口类和几个实现，我用FP该怎么写”，而是“别人用OOP的对象和子类型多态组织了这个计算需求，我用FP该怎么组织呢”。那么OOP中使用子类型多态到底解决了什么问题？  </p><p>其实OOP的哲学是<code>对象/数据.计算()</code>，其计算是绑定在数据上的，而子类型多态，即是把计算动态绑定到不同类型的数据上（对不同的数据施加不同的计算）。<br>然而对于FP，其实计算（函数）就是数据，可以是<code>计算(数据)</code>或者就是<code>计算(计算)</code>。那么对于把计算<strong>动态地</strong>绑在不同数据上的需求，FP里应该怎么做呢？答案呼之欲出，那就是直接操作计算（函数）：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Showable</span> = <span class="type">Showable</span> &#123; <span class="title">runShow</span> :: <span class="type">Y</span> -&gt; <span class="type">Z</span> -&gt; <span class="type">X</span> &#125;</span></span><br><span class="line"><span class="title">showA</span> :: <span class="type">A</span> -&gt; <span class="type">Showable</span></span><br><span class="line"><span class="title">showA</span> a = <span class="type">Showable</span> $ \y z -&gt; ...</span><br><span class="line"></span><br><span class="line"><span class="title">showBC</span> :: <span class="type">B</span> -&gt; <span class="type">C</span> -&gt; <span class="type">Showable</span></span><br><span class="line"><span class="title">showBC</span> b c = <span class="type">Showable</span> $ \y z -&gt; ...</span><br><span class="line"></span><br><span class="line"><span class="title">f</span> :: [<span class="type">Showable</span>] -&gt; <span class="type">F</span></span><br><span class="line"><span class="title">f</span> l = <span class="keyword">let</span> map runShow l <span class="keyword">in</span> ...</span><br><span class="line"></span><br><span class="line"><span class="title">l</span> :: [<span class="type">Showable</span>]</span><br><span class="line"><span class="title">l</span> = [showA a, showBC b c]  <span class="comment">-- OK</span></span><br></pre></td></tr></table></figure><p>与上面OOP的设计对照，可以发现每个部分都可以对应：</p><ul><li>Showable是一个有<code>Y -&gt; Z -&gt; X</code>函数的接口，把它称为<code>runShow</code></li><li><code>showA</code>由一个<code>A</code>类型数据，可以构造出一个具有<code>runShow</code>计算的数据</li><li><code>showBC</code>由一个<code>B</code>、一个<code>C</code>类型数据，可以构造出一个具有<code>runShow</code>计算的数据</li><li><code>showA</code>和<code>showBC</code>对<code>runShow</code>的具体实现则在构造<code>Showable</code>的函数中  </li><li>OOP中会根据数据动态的绑定对应的计算，而在FP中，计算就是数据本身</li></ul><p>从语法的角度说，类型<code>Showable</code>只有<code>Showable</code>这一个值构造子，但这里我们可以实现<code>showA</code>，<code>showBC</code>这样的函数完成如OOP一样的不同“对象”的构造，从函数签名来看，它们也是<code>Showable</code>的构造子。如此，对于数据的构造就更加自然了。  </p><p>至少在本例中，两种方式是等价的，而第二种则更加FP。</p><p>可以说，这种对计算的直接操作才是FP中最精髓的设计模式，从各种高阶函数，<code>Reader</code>、<code>State</code>等Monad，到CPS变换对continuation的直接操作，都是以计算为数据这一设计的体现。这也体现出，FP基于一等函数的抽象是一种非常一般性的抽象，由这一最平平无奇的语言特性就可以模拟或者实现出其他语言各种千奇百怪的特性或者设计模式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在尝试用Haskell实现Peter Shirley的&lt;em&gt;Ray Tracing in a Weekend&lt;/em&gt;一书，发现了这个问题，并琢磨出了一些解法，看起来像是发现了一种设计模式，不过不知道叫什么名字（&lt;/p&gt;
    
    </summary>
    
      <category term="杂记" scheme="https://121.5.103.67/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="函数式" scheme="https://121.5.103.67/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
      <category term="Haskell" scheme="https://121.5.103.67/tags/Haskell/"/>
    
      <category term="教程" scheme="https://121.5.103.67/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【类型论】四、Types dependent on types</title>
    <link href="https://121.5.103.67/2021/03/22/%E3%80%90%E7%B1%BB%E5%9E%8B%E8%AE%BA%E3%80%91%E5%9B%9B%E3%80%81Types-dependent-on-types/"/>
    <id>https://121.5.103.67/2021/03/22/【类型论】四、Types-dependent-on-types/</id>
    <published>2021-03-22T11:00:00.000Z</published>
    <updated>2021-11-03T12:15:03.245Z</updated>
    
    <content type="html"><![CDATA[<p>本文为<em>Type Theory and Formal Proof : An Introduction</em> 的笔记，纯个人向（</p><hr><h2 id="类型构造子"><a href="#类型构造子" class="headerlink" title="类型构造子"></a>类型构造子</h2><p>之前我们从<em>项</em>$\lambda x:\sigma.x$中由类型变量抽象出$\lambda \alpha:\ast.\lambda x:\alpha.x$. 类似的，我们也可以从<em>类型</em>上抽象. 如类型$\beta\to\beta,\ \gamma\to\gamma,\ (\gamma\to\beta)\to(\gamma\to\beta),\ \dots$，都有$\Diamond\to\Diamond$这样的结构.</p><a id="more"></a><p>我们引入一种表达式表示这个结构：$\lambda\alpha:\ast.\alpha\to\alpha$，它本身不是一个类型，但是一个<em>值</em>为类型的函数，因此称为<strong>类型构造子</strong>（type constructor）。喂给它东西，我们能得到类型：</p><p>$(\lambda\alpha:\ast.\alpha\to\alpha)\beta\qquad\to_\beta\quad\beta\to\beta$</p><p>$(\lambda\alpha:\ast.\alpha\to\alpha)\gamma\qquad\to_\beta\quad\gamma\to\gamma$</p><p>$(\lambda\alpha:\ast.\alpha\to\alpha)(\gamma\to\beta)\qquad\to_\beta\quad(\gamma\to\beta)\to(\gamma\to\beta)$</p><p>同理我们也可以构造$\lambda\alpha:\ast.\lambda\beta:\ast.\alpha\to\beta$.</p><p>那么，这些类型构造子的<em>类型</em>是什么呢？$\lambda\alpha:\ast.\alpha\to\alpha$是一个将$\alpha$映射到$\alpha\to\alpha$的函数，因为$\alpha:\ast$且$\alpha\to\alpha:\ast$，我们有：</p><p>$\lambda\alpha:\ast.\alpha\to\alpha\ :\ \ast\to\ast$. 因此我们需要一个“超类型”$\ast\to\ast$.</p><p>同理有：</p><p>$\lambda\alpha:\ast.\lambda\beta:\ast.\alpha\to\beta\ :\ \ast\to(\ast\to\ast)$.</p><p>这一推广称<strong>依赖于类型的类型</strong>（types depending on types），这一系统称$\lambda\underline\omega$，包括$\ast$和带箭头的$\ast$称<strong>kind</strong>. 所有kind的集合是：</p><p>$\mathbb{K=\ast\ \mid\ (K\to K)}$.</p><p>箭头的结合性与简单类型一致.</p><p>定义<strong>所有kind的类型</strong>（type of all kinds）记作$\square$，如$\ast:\square$、$\ast\to\ast:\square$等等. </p><h3 id="构造子，真构造子，sort（Constructor-proper-constructor-sort）"><a href="#构造子，真构造子，sort（Constructor-proper-constructor-sort）" class="headerlink" title="构造子，真构造子，sort（Constructor, proper constructor, sort）"></a>构造子，真构造子，sort（Constructor, proper constructor, sort）</h3><ol><li>若$\kappa:\square$且$M:\kappa$则$M$是<strong>构造子</strong>（constructor），若$\kappa\not\equiv\ast$，则$M$是<strong>真构造子</strong>（proper constructor）.</li><li><strong>sort</strong>的集合为$\lbrace\ast,\ \square\rbrace$.</li></ol><p>我们保留符号$s$作为sort的元变量（即$s$表示$\ast$或$\square$）.</p><h3 id="Levels"><a href="#Levels" class="headerlink" title="Levels"></a>Levels</h3><p>level 1：项</p><p>level 2：构造子（即类型和真构造子）</p><p>level 3：kinds</p><p>level 4：即$\square$.</p><p>由此我们可以写出<strong>推断链</strong>（judgement chains）如$t:\sigma:\ast\to\ast$，甚至$t:\sigma:\ast\to\ast:\square$. 当$\sigma$是一个真构造子，则它下面没有值：$\sigma:\kappa:\square$，其中例如$\kappa\equiv\ast\to\ast$. </p><h2 id="lambda-underline-omega-中的Sort规则和var规则"><a href="#lambda-underline-omega-中的Sort规则和var规则" class="headerlink" title="$\lambda\underline\omega$中的Sort规则和var规则"></a>$\lambda\underline\omega$中的Sort规则和var规则</h2><p>$\lambda\underline\omega$是$\lambda{\to}$的另一种推广：</p><ul><li>$\lambda2=\lambda{\to}$加上 依赖于类型的<strong>项</strong>（<em>terms</em>-depending-on-types）</li><li>$\lambda\underline\omega=\lambda{\to}$加上 依赖于类型的<strong>类型</strong>（<em>types</em>-depending-on-types）</li></ul><h3 id="Sort规则（Sort-rule）"><a href="#Sort规则（Sort-rule）" class="headerlink" title="Sort规则（Sort-rule）"></a>Sort规则（Sort-rule）</h3><p>$(sort)\quad\emptyset\ \vdash\ \ast\ :\ \square$.</p><p>接下来我们想要所有出现在上下文中的声明都是可以从这个上下文中派生的. 在$\lambda{\to}$和$\lambda2$中，我们使用$(var)$规则. 在$\lambda\underline{\omega}$中，我们要结合上下文的声明和构造的可派生性. 这是因为$\lambda\underline{\omega}$的类型更加复杂，我们需要确保类型都是良形式的, 此时一个类型的推断与否不再是由一个外在的集合，而是由推断和它的上下文自身决定. 在当前的类型系统下的要求更严格一些，我们要求出现在推断中的类型必须都能被形式地派生出来.</p><p>因此，只有在$A$类型可以被推断的时候，我们可以用一个声明$x:A$扩展一个上下文，且可以被推断的类型可以出现在level 2或者3上，也就是一个类型或者kind. 由此得到：</p><h3 id="Var规则（Var-rule）"><a href="#Var规则（Var-rule）" class="headerlink" title="Var规则（Var-rule）"></a>Var规则（Var-rule）</h3><p>$(var)\quad\dfrac{\Gamma\ \vdash\ A:s}{\Gamma,\ x:A\ \vdash\ x:A}$，若$x\notin \Gamma$.</p><p><strong>前提</strong>是$A$为type（$s\equiv\ast$）或kind（$s\equiv\square$）. $x$既可能是个项变量，也可能是个类型变量. $(var)$规则允许我们由声明$x:A$延伸上下文$\Gamma$，并将他作为这个延伸上下文的陈述.</p><p>现在的问题是我们仅允许上下文的最后一个声明作派生，但：</p><p>$(?_1)\ \alpha:\ast,\ x:\alpha\ \vdash\ \alpha:\ast$</p><p>$(?_2)\ \alpha:\ast,\ \beta:\ast\ \vdash\ \alpha:\ast$</p><p>这些暂时是无法派生的，甚至：</p><p>$(?_3)\ \alpha:\ast,\ \beta:\ast\ \vdash\ \beta:\ast$</p><p>也不行，因为我们还不能得到$（?_3）$需要的前提</p><p>$(?_4)\ \alpha:\ast\ \vdash\ \ast:\square$</p><p>因此我们引入：</p><h2 id="lambda-underline-omega-弱化规则（weakening-rule）"><a href="#lambda-underline-omega-弱化规则（weakening-rule）" class="headerlink" title="$\lambda\underline\omega$弱化规则（weakening rule）"></a>$\lambda\underline\omega$弱化规则（weakening rule）</h2><h3 id="弱化规则（Weakening-rule）"><a href="#弱化规则（Weakening-rule）" class="headerlink" title="弱化规则（Weakening rule）"></a>弱化规则（Weakening rule）</h3><p>$(weak)\ \dfrac{\Gamma\ \vdash\ A:B\quad\Gamma\ \vdash\ C:s}{\Gamma,\ x:C\ \vdash\ A:B}$，若$x\notin\Gamma$.</p><p>如果我们派生出$\Gamma\ \vdash\ A:B$这个推断（第一个前提），那么我们可以通过在这个上下文$\Gamma$的末尾增加任意的一条声明将其弱化.</p><p>弱化规则对上下文的扩展只允许在最后，可以证明任意的扩展也都是可以的，也就是说Thinning Lemma对$\lambda\underline\omega$也成立.</p><p>这样$(?_1)$就可以这样派生：</p><p>$\dfrac{\dfrac{(1)\ \emptyset\ \vdash\ \ast:\square}{(2)\ \alpha:\ast\ \vdash\ \alpha:\ast}(var)\qquad\dfrac{(1)\ \emptyset\ \vdash\ \ast:\square}{(2)\ \alpha:\ast\ \vdash\ \alpha:\ast}(var)}{(4)\ \alpha:\ast,\ x:\alpha\ \vdash\ \alpha:\ast}(weak)$</p><p>$(?_2)$和$(?_4)$的派生如下：</p><p>$\dfrac{\dfrac{(1)\ \emptyset\ \vdash\ \ast:\square}{(2)\ \alpha:\ast\ \vdash\ \alpha:\ast}(var)\qquad\dfrac{(1)\ \emptyset\ \vdash\ \ast:\square\quad(1)\ \emptyset\ \vdash\ \ast:\square}{(5)\ \alpha:\ast\ \vdash\ \ast:\square}(weak)}{(6)\ \alpha:\ast,\ \beta:\ast\ \vdash\ \alpha:\ast}(weak)$</p><p>$(?_3)$：</p><p>$\dfrac{\dfrac{(1)\ \emptyset\ \vdash\ \ast：\square\quad(1)\ \emptyset\ \vdash\ \ast:\square}{(5)\ \alpha:\ast\ \vdash\ \ast:\square}(weak)}{(7)\ \alpha:\ast,\ \beta:\ast\ \vdash\ \beta:\ast}(var)$</p><h2 id="lambda-underline-omega-的形成规则（Formation-rule）"><a href="#lambda-underline-omega-的形成规则（Formation-rule）" class="headerlink" title="$\lambda\underline\omega$的形成规则（Formation rule）"></a>$\lambda\underline\omega$的形成规则（Formation rule）</h2><p>在$\lambda 2$中，基于$\lambda 2$类型$\mathbb{T}2$，我们有$(form)$规则来构造上下文中的类型. 同样的，对于更加复杂的$\lambda\underline{\omega}$，我们需要一个真的有前提有结论的派生规则来构造类型.</p><h3 id="形成规则（Formation-rule）"><a href="#形成规则（Formation-rule）" class="headerlink" title="形成规则（Formation rule）"></a>形成规则（Formation rule）</h3><p>$(form)\ \dfrac{\Gamma\ \vdash\ A:s\quad\Gamma\ \vdash\ B:s}{\Gamma\ \vdash\ A\to B:s}$</p><p>这包含了所有的types和kinds. （注意到$\lambda\underline{\omega}$中没有$\Pi$-类型）</p><p>例如：</p><p>对于$s\equiv\ast$：</p><p>$\dfrac{\dfrac{\cdots}{(6)\ \alpha:\ast,\ \beta:\ast\ \vdash\ \alpha:\ast}\quad\dfrac{\cdots}{(7)\ \alpha:\ast,\ \beta:\ast\ \vdash\ \beta:\ast}}{(8)\ \alpha:\ast,\ \beta:\ast\ \vdash \alpha \to\beta :\ast}(form)$</p><p>对于$s\equiv\square$：</p><p>$\dfrac{\dfrac{\cdots}{(5)\ \alpha:\ast\ \vdash\ \ast:\square}\quad\dfrac{\cdots}{(5)\ \alpha:\ast\ \vdash\ \ast:\square}}{(9)\ \alpha:\ast\ \vdash\ \ast\to\ast:\square}(form)$</p><h2 id="lambda-underline-omega-的应用和抽象规则（Application-and-abstraction-rules）"><a href="#lambda-underline-omega-的应用和抽象规则（Application-and-abstraction-rules）" class="headerlink" title="$\lambda\underline\omega$的应用和抽象规则（Application and abstraction rules）"></a>$\lambda\underline\omega$的应用和抽象规则（Application and abstraction rules）</h2><p>$(appl)\ \dfrac{\Gamma\ \vdash\ M:A\to B\quad\Gamma\ \vdash\ N:A}{\Gamma\ \vdash\ M\ N:B}$</p><p>$(abst)\ \dfrac{\Gamma,\ x:A\ \vdash\ M:B\quad\Gamma\ \vdash\ A\to B:s}{\Gamma\ \vdash\ \lambda x:A.\ M:A\to B}$  </p><p>不同的是，在抽象规则中必须保证$A\to B$是一个良形式的类型.</p><p>在引入$\lambda\underline{\omega}$的$\beta$-归约之前，先引入下例的派生：</p><p>$(\lambda\alpha:\ast.\ \alpha\to\alpha)\ \beta\quad\to_\beta\quad\beta\to\beta$</p><p>对于左边：</p><p>$(10)\quad\beta:\ast\ \vdash\ \ast:\square\quad对(1)和(1)用(weak)$</p><p>$(11)\quad\beta:\ast,\ \alpha:\ast\ \vdash\ \alpha:\ast\quad对(10)用(var)$</p><p>$(12)\quad\beta:\ast,\ \alpha:\ast\ \vdash\ \alpha\to\alpha:\ast\quad对(11)和(11)用(form)$</p><p>$(13)\quad\beta:\ast\ \vdash\ \ast\to\ast:\square\quad对(10)和(10)用(form)$</p><p>$(14)\quad\beta:\ast\ \vdash\ \lambda\alpha:\ast.\ \alpha\to\alpha:\ast\to\ast\quad对(12)和(13)用(abst)$</p><p>$(15)\quad\beta:\ast\ \vdash\ \beta:\ast\quad对(1)用(var)$</p><p>$(16)\quad\beta:\ast\ \vdash\ (\lambda\alpha:\ast.\ \alpha\to\alpha)\ \beta:\ast\quad对(14)和(15)用(appl)$</p><p>对于右边：</p><p>$(17)\quad\beta:\ast\ \vdash\ \beta\to\beta:\ast\quad对(15)和(15)用(form)$</p><h2 id="替换规则（Conversion-rules）"><a href="#替换规则（Conversion-rules）" class="headerlink" title="替换规则（Conversion rules）"></a>替换规则（Conversion rules）</h2><p>对于上面的例子，有</p><p>$\beta:\ast,\ x:(\lambda\alpha:\ast.\ \alpha\to\alpha)\ \beta\ \vdash\ x:(\lambda\alpha:\ast.\ \alpha\to\alpha)\ \beta$</p><p>我们想要得到：</p><p>$\beta:\ast,\ x:(\lambda\alpha:\ast.\ \alpha\to\alpha)\ \beta\ \vdash\ x:\beta\to\beta$  </p><p>我们需要一个推广的$\beta$-替换，使得若$M:B$且$B=_\beta B’$，则$M:B’$（$B$和$B’$都是良形式的）.  </p><h3 id="替换规则（Conversion-rule）"><a href="#替换规则（Conversion-rule）" class="headerlink" title="替换规则（Conversion rule）"></a>替换规则（Conversion rule）</h3><p>$(conv)\ \dfrac{\Gamma\ \vdash\ A:B\quad\Gamma\ \vdash\ B’:s}{\Gamma\ \vdash\ A:B’}\quad若B=_\beta B’$</p><p>第二个前提是必要的，考虑对任意$M$，$\beta \to \gamma =_\beta (\lambda\alpha: \ast.\ \beta\to\gamma)\ M$. 左边的$\beta\to\gamma$是良形式的，但当$M$没有$*$类型，右边的$(\lambda\alpha: \ast.\ \beta\to\gamma)\ M$就不是. </p><p>例如：</p><p>$\dfrac{(18)\ \Gamma\ \vdash\ x:(\lambda \alpha: \ast .\ \alpha\to\alpha)\ \beta\quad(19)\ \Gamma\ \vdash\ \beta \to \beta:\ast}{(20)\ \Gamma\ \vdash\ x:\beta\to\beta}\ (conv)$</p><p>至此所有的$\lambda\underline{\omega}$的规则：</p><p>$$<br>\begin{align}<br>(sort)&amp;\ \emptyset\ \vdash\ \ast:\square\<br>\ \<br>(var)&amp;\ \dfrac{\Gamma\ \vdash\ A:s}{\Gamma,\ x:A\ \vdash\ x:A}\quad若x\notin\Gamma \<br>\ \<br>(weak)&amp;\ \dfrac{\Gamma\ \vdash\ A:B\quad\Gamma\ \vdash\ C:s}{\Gamma,\ x:C\ \vdash\ A:B}\quad若x\notin\Gamma\<br>\ \<br>(form)&amp;\ \dfrac{\Gamma\ \vdash\ A:s\quad\Gamma\ \vdash\ B:s}{\Gamma\ \vdash\ A\to B:s}\<br>\ \<br>(appl)&amp;\ \dfrac{\Gamma\ \vdash\ M:A\to B\quad \Gamma\ \vdash\ N:A}{\Gamma\ \vdash\ M\ N:B}\<br>\ \<br>(abst)&amp;\ \dfrac{\Gamma,\ x:A\ \vdash\ M:B\quad\Gamma\ \vdash\ A\to\ B:s}{\Gamma\ \vdash\ \lambda x:A.\ M\ :\ A\to B}\<br>\ \<br>(conv)&amp;\ \dfrac{\Gamma\ \vdash\ A:B\quad\Gamma\ \vdash\ B’:s}{\Gamma\ \vdash\ A:B’}\quad若B=_\beta B’<br>\end{align}<br>$$</p><h2 id="lambda-underline-omega-的性质"><a href="#lambda-underline-omega-的性质" class="headerlink" title="$\lambda\underline{\omega}$的性质"></a>$\lambda\underline{\omega}$的性质</h2><p>$\lambda\underline{\omega}$系统满足之前系统的大部分性质，除了需要对类型唯一性作一些调整：类型不一定字面上唯一，但在替换意义上唯一.</p><h3 id="替换上类型的唯一性"><a href="#替换上类型的唯一性" class="headerlink" title="替换上类型的唯一性"></a>替换上类型的唯一性</h3><p>$若\Gamma\vdash A :B_1 且 \Gamma\vdash A:B_2，则B_1=_\beta B_2$.  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为&lt;em&gt;Type Theory and Formal Proof : An Introduction&lt;/em&gt; 的笔记，纯个人向（&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;类型构造子&quot;&gt;&lt;a href=&quot;#类型构造子&quot; class=&quot;headerlink&quot; title=&quot;类型构造子&quot;&gt;&lt;/a&gt;类型构造子&lt;/h2&gt;&lt;p&gt;之前我们从&lt;em&gt;项&lt;/em&gt;$\lambda x:\sigma.x$中由类型变量抽象出$\lambda \alpha:\ast.\lambda x:\alpha.x$. 类似的，我们也可以从&lt;em&gt;类型&lt;/em&gt;上抽象. 如类型$\beta\to\beta,\ \gamma\to\gamma,\ (\gamma\to\beta)\to(\gamma\to\beta),\ \dots$，都有$\Diamond\to\Diamond$这样的结构.&lt;/p&gt;
    
    </summary>
    
      <category term="小课堂" scheme="https://121.5.103.67/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="函数式" scheme="https://121.5.103.67/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
      <category term="教程" scheme="https://121.5.103.67/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="类型论" scheme="https://121.5.103.67/tags/%E7%B1%BB%E5%9E%8B%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【类型论】三、Second order typed lambda calculus</title>
    <link href="https://121.5.103.67/2021/03/16/%E3%80%90%E7%B1%BB%E5%9E%8B%E8%AE%BA%E3%80%91%E4%B8%89%E3%80%81Second-order-typed-lambda-calculus/"/>
    <id>https://121.5.103.67/2021/03/16/【类型论】三、Second-order-typed-lambda-calculus/</id>
    <published>2021-03-16T12:41:01.000Z</published>
    <updated>2021-04-05T12:01:49.099Z</updated>
    
    <content type="html"><![CDATA[<p>本文为<em>Type Theory and Formal Proof : An Introduction</em> 的笔记，纯个人向（</p><hr><h2 id="类型抽象和类型应用（Type-abstraction-and-type-application）"><a href="#类型抽象和类型应用（Type-abstraction-and-type-application）" class="headerlink" title="类型抽象和类型应用（Type-abstraction and type-application）"></a>类型抽象和类型应用（Type-abstraction and type-application）</h2><p>对于<em>抽象</em>这个过程，我们有项$M$，其中可能有自由变量$x$，假设$x$有类型$\sigma$，我们从$M$中抽象$x$，可以得到项$\lambda x : \sigma.M$，同时，所有在$M$中的自由变量$x$被绑定了，我们说：</p><p><em>项$\lambda x:\sigma.M$依赖于项$x$</em>.</p><p>因此，$\lambda{\to}$中可以构造<strong>依赖于项的项</strong>（terms depending on terms）.</p><p>相应的是<em>应用</em>，对于$MN$的构造，我们可以把$M$应用到$N$，也得到一个项.</p><p>这称为<em>一阶</em>（first order）抽象，或一阶依赖，因为这个抽象是在项上进行的. 同时应用也是一阶的.</p><p>现在我们引入<strong>依赖于类型的项</strong>（terms depending on types），称<em>二阶<em>运算（</em>second order</em> operations）或二阶依赖（second order dependency）.</p><p>得到的这一系统称<em>二阶类型lambda演算（second order typed lambda calculus）</em>，或$\lambda 2$.</p><a id="more"></a><p><strong>例：</strong></p><p>首先考虑<em>恒等函数（identity function）</em>，在$\lambda{\to}$中并不存在，因为我们需要一个任意的类型$\alpha$，然后构造$f \equiv \lambda x:\alpha .x$. 但这样，在应用一个自然数类型$nat$的$M$时，我们不能构造$fM$，因为$\alpha \not \equiv nat$，类型不匹配. </p><p>因此对于这样的万能类型，我们需要引入<em>另一层抽象</em>：</p><p>$\lambda \alpha:\ast.\lambda x:\alpha.x$.</p><p>这里变量$\alpha$的类型引入新记号$\ast$，指<em>所有类型的类型（the type of all types）</em>.</p><p>此时$\lambda \alpha:\ast.\lambda x:\alpha.x$也是一个项，但是一个<em>依赖于类型的项（term depending on a type）</em>. 这里依赖的类型是$\alpha$.</p><p>得到的这个项称为<em>多态（polymorphic）</em>恒等函数. 注意这还不是恒等函数本身，我们还需要进行一次（二阶）应用和Beta归约得到一个真正的恒等函数：</p><ul><li>$(\lambda \alpha :\ast.\ \lambda x:\alpha . x)nat \to_\beta \lambda x:nat.x$，为自然数上的恒等函数</li><li>$(\lambda \alpha :\ast.\ \lambda x:\alpha . x)(nat\to bool) \to_\beta \lambda x:(nat\to bool).x$，为$nat\to bool$上的.</li></ul><p>因此我们还需要增加二阶的抽象和应用，以及对于二阶项的Beta归约.</p><h2 id="Pi-类型（-Pi-types）"><a href="#Pi-类型（-Pi-types）" class="headerlink" title="$\Pi$类型（$\Pi$-types）"></a>$\Pi$类型（$\Pi$-types）</h2><p>我们引入<em>二阶lambda抽象（second order $\lambda$-abstraction）</em>或<em>类型抽象（type-abstraction）</em>，例如：</p><p>$\lambda \alpha:*.\lambda x:\alpha.x$.</p><p>在$\lambda{\to}$中，我们猜想它的类型是：</p><p>$\lambda \alpha:\ast.\lambda x:\alpha.x\quad:\quad\ast\to(\alpha\to \alpha)$.</p><p>然而问题是在上面的二阶表达式中，类型$\alpha$变成了一个绑定的变量，我们有理由认为$\lambda \alpha:\ast.\lambda x:\alpha.x$与$\lambda \beta:\ast.\lambda x:\beta.x$相同. 然而$\lambda \alpha:\ast.\lambda x:\alpha.x:\ast\to(\alpha\to\alpha)$，但$\lambda \beta:\ast.\lambda x:\beta.x:\ast\to(\beta\to\beta)$，相同的项有了不同的类型. 这是由于，我们认为左侧的$\alpha$和$\beta$是绑定的变量，而右侧的是自由变量. 因此我们引入一种新绑定：类型绑定（type-binder） 或 $\Pi$绑定（$\Pi$-binder）. 一个将<em>任意</em>类型$\alpha$到类型为$\alpha\to\alpha$的函数的类型记作$\Pi\alpha:\ast.\alpha\to\alpha$.</p><p>我们简单推广$\alpha$变换，有$\Pi\alpha:\ast.\alpha\to\alpha\equiv_\alpha\Pi\beta:\ast.\beta\to\beta$. 此时我们有：</p><p>$$<br>\lambda \alpha:\ast.\lambda x:\alpha.x\quad:\quad\Pi\alpha:\ast.\alpha\to\alpha\<br>\equiv\quad\lambda \beta:\ast.\lambda x:\beta.x\quad:\quad\Pi\beta:\ast.\beta\to\beta<br>$$</p><blockquote><p>在数学中，$\Pi$用于乘积，而$\Pi$类型也称作积类型.</p></blockquote><h2 id="二阶抽象和应用法则（Second-order-abstraction-and-application-rules）"><a href="#二阶抽象和应用法则（Second-order-abstraction-and-application-rules）" class="headerlink" title="二阶抽象和应用法则（Second order abstraction and application rules）"></a>二阶抽象和应用法则（Second order abstraction and application rules）</h2><h3 id="二阶抽象法则（Second-order-abstraction-rule）"><a href="#二阶抽象法则（Second-order-abstraction-rule）" class="headerlink" title="二阶抽象法则（Second order abstraction rule）"></a>二阶抽象法则（Second order abstraction rule）</h3><p>$(abst_2)\ \dfrac{\Gamma,\ \alpha:\ast\ \vdash\ M:A}{\Gamma\ \vdash\ \lambda \alpha:\ast.M\ :\ \Pi\alpha:\ast.A}$</p><p>当上下文中$M$有类型$A$且$\alpha$有类型$\ast$，则$\lambda \alpha:\ \ast.\ M$有类型$\Pi\alpha:\ast\ .A$. 新的地方是：我们允许二阶声明在上下文中.</p><h3 id="二阶应用法则（Second-order-application-rule）"><a href="#二阶应用法则（Second-order-application-rule）" class="headerlink" title="二阶应用法则（Second order application rule）"></a>二阶应用法则（Second order application rule）</h3><p>$(appl_2)\ \dfrac{\Gamma\ \vdash\ M\ :\ \Pi\alpha:\ast.\ A\qquad\Gamma\ \vdash\ B:\ast}{\Gamma\ \vdash\ MB\ :\ A[\alpha:=B]}$</p><h2 id="lambda2-系统（The-system-lambda2-）"><a href="#lambda2-系统（The-system-lambda2-）" class="headerlink" title="$\lambda2$系统（The system $\lambda2$）"></a>$\lambda2$系统（The system $\lambda2$）</h2><p>以下是$\lambda2$的完整定义：</p><h3 id="lambda2-类型（-lambda2-types）"><a href="#lambda2-类型（-lambda2-types）" class="headerlink" title="$\lambda2$类型（$\lambda2$-types）"></a>$\lambda2$类型（$\lambda2$-types）</h3><p>$\mathbb{T2=V\mid(T2\to T2)\mid(\Pi V:*.T2)}$，其中$\mathbb{V}$是类型变量集合.</p><h3 id="二阶预定型项（Second-order-pre-typed-lambda-terms-lambda2-terms-Lambda-mathbb-T2-）"><a href="#二阶预定型项（Second-order-pre-typed-lambda-terms-lambda2-terms-Lambda-mathbb-T2-）" class="headerlink" title="二阶预定型项（Second order pre-typed $\lambda$-terms, $\lambda2$-terms, $\Lambda_\mathbb{T2}$）"></a>二阶预定型项（Second order pre-typed $\lambda$-terms, $\lambda2$-terms, $\Lambda_\mathbb{T2}$）</h3><p>$\mathbb{\Lambda_{T2}}=V\mid(\mathbb{\Lambda_{T2}\Lambda_{T2}})\mid(\Lambda_\mathbb{T2}\mathbb{T2})\mid(\lambda V:\mathbb{T2.\Lambda_{T2}})\mid(\lambda\mathbb{V}:*.\Lambda_\mathbb{T2})$.</p><p>此时我们有两种变量：对象变量（object variables）$V$（如$x,\ y,\ \dots$）和类型变量（type variables）$\mathbb{V}$（如$\alpha,\ \beta,\ \dots$）. 我们有一阶抽象$(\lambda V:\mathbb{T2.\Lambda_{T2}})$和二阶抽象$(\lambda\mathbb{V}:*.\Lambda_\mathbb{T2})$，一阶应用$(\mathbb{\Lambda_{T2}\Lambda_{T2}})$和二阶应用$(\Lambda_\mathbb{T2}\mathbb{T2})$.</p><h3 id="陈述，声明（Statement-declaration）"><a href="#陈述，声明（Statement-declaration）" class="headerlink" title="陈述，声明（Statement, declaration）"></a>陈述，声明（Statement, declaration）</h3><ol><li><em>陈述（statement）</em>要么形如$M:\sigma$，其中$M\in\Lambda_\mathbb{T2}$且$\sigma:\mathbb{T2}$，要么形如$\sigma:\ast$，其中$\sigma \in \mathbb{T2}$.</li><li><em>声明（declaration）</em>是一个以<em>项变量（type variable）</em>或<em>类型变量（term variable）</em>为主体的陈述.</li></ol><p>在$\lambda{\to}$中，<em>上下文</em>只是一个项声明的列表. 在$\lambda2$中，所有变量在被使用之前必须声明. 所以，类型变量$\alpha$（具有类型$\ast$）这个声明必须先于$x:\alpha\to\alpha$这个声明. </p><h3 id="lambda2-上下文、定义域（-lambda2-context-domain-rm-dom-）"><a href="#lambda2-上下文、定义域（-lambda2-context-domain-rm-dom-）" class="headerlink" title="$\lambda2$上下文、定义域（$\lambda2$-context; domain; ${\rm dom}$）"></a>$\lambda2$上下文、定义域（$\lambda2$-context; domain; ${\rm dom}$）</h3><ol><li>$\emptyset$是$\lambda2$上下文；${\rm dom(\emptyset)}=(\ )$，为空列表.</li><li>若$\Gamma$是$\lambda2$上下文，$\alpha\in\mathbb{V}$且$\alpha\not\in{\rm dom}(\Gamma)$，则$\Gamma,\ \alpha:*$是$\lambda2$上下文.</li><li>若$\Gamma$是$\lambda2$上下文，若$\rho \in \mathbb{T2}$使得对$\rho$中的所有自由变量$\alpha$都有$\alpha \in {\rm dom}(\Gamma)$且$x \not \in {\rm dom}(\Gamma)$，则$\Gamma,\ x:\rho$是$\lambda2$上下文.</li></ol><blockquote><p>此定义中蕴含了$\lambda2$上下文中的变量互不相同.</p></blockquote><h3 id="lambda2-的-var-法则（Var-rule-for-lambda2-）"><a href="#lambda2-的-var-法则（Var-rule-for-lambda2-）" class="headerlink" title="$\lambda2$的$(var)$法则（Var-rule for $\lambda2$）"></a>$\lambda2$的$(var)$法则（Var-rule for $\lambda2$）</h3><p>$(var)\quad \Gamma \vdash x:\sigma$，如果$\Gamma$是$\lambda2$上下文且$x:\sigma\in\Gamma$.</p><p>$\lambda2$的$(var)$法则也是没有<strong>前提</strong>的.</p><p>对于$\lambda2$的派生，我们现在有复用$\lambda{\to}$中的$(appl)$和$(abst)$，刚刚定义的$(var)$和新加入的$(appl_2)$和$(abst_2)$.</p><p>然而当使用这五条法则时，我们将无法使用到$(appl_2)$法则，因为它的第二个<strong>前提</strong>是$\Gamma\ \vdash\ B:<em>$，而我们没有规则使得有东西具有类型$</em>$（没有形如$\dots\ \vdash\ \dots\ :\ <em>$的*</em>结论**）.</p><p>直觉告诉我们，$B:*$，只要$B$是个类型且我们已知所有$B$中的类型变量，因此有：</p><h3 id="form-法则（Formation-rule）"><a href="#form-法则（Formation-rule）" class="headerlink" title="$(form)$法则（Formation rule）"></a>$(form)$法则（Formation rule）</h3><p>$(form)\quad\Gamma\ \vdash\ B:*$，如果$\Gamma$是$\lambda2$上下文，$B\in\mathbb{T2}$且所有在$B$中的自由类型变量都在$\Gamma$有声明.</p><blockquote><p>$(form)$法则虽然有三个条件，但也没有<strong>前提</strong>，可以作为派生树的叶子</p></blockquote><p>于是$\lambda2$的所有派生法则：</p><p>$(var)\quad \Gamma \vdash x:\sigma$，如果$\Gamma$是$\lambda2$上下文且$x:\sigma\in\Gamma$.</p><p>$(appl)\ \dfrac{\Gamma\ \vdash\ M:\sigma\to\tau\quad\Gamma\ \vdash\ N:\sigma}{\Gamma\ \vdash\ MN:\tau}$</p><p>$(abst)\ \dfrac{\Gamma,\ x:\sigma\ \vdash\ M:\tau}{\Gamma\ \vdash\ \lambda x:\sigma.\ M\ :\ \sigma\to\tau}$</p><p>$(form)\quad\Gamma\ \vdash\ B:*$，如果$\Gamma$是$\lambda2$上下文，$B\in\mathbb{T2}$且所有在$B$中的自由类型变量都在$\Gamma$有声明.</p><p>$(appl_2)\ \dfrac{\Gamma\ \vdash\ M\ :\ \Pi\alpha:\ast.\ A\qquad\Gamma\ \vdash\ B:\ast}{\Gamma\ \vdash\ MB\ :\ A[\alpha:=B]}$</p><p>$(abst_2)\ \dfrac{\Gamma,\ \alpha:\ast\ \vdash\ M:A}{\Gamma\ \vdash\ \lambda \alpha:\ast.M\ :\ \Pi\alpha:\ast.A}$</p><h3 id="合法的-lambda2-项（Legal-lambda2-terms）"><a href="#合法的-lambda2-项（Legal-lambda2-terms）" class="headerlink" title="合法的$\lambda2$项（Legal $\lambda2$-terms）"></a>合法的$\lambda2$项（Legal $\lambda2$-terms）</h3><p>称$\mathbb{\Lambda_{T2}}$中的项$M$<em>合法</em>（legal），若存在$\lambda2$上下文$\Gamma$和$\mathbb{T2}$类型$\rho$使得$\Gamma\vdash M:\rho$.</p><h2 id="lambda2-中的派生例"><a href="#lambda2-中的派生例" class="headerlink" title="$\lambda2$中的派生例"></a>$\lambda2$中的派生例</h2><p>试图派生$M\equiv\lambda\alpha:*.\lambda f:\alpha\to\alpha.\lambda x:\alpha.f(f\ x)$.</p><p>即找到上下文$\Gamma$和类型$\rho$使得$\Gamma\vdash M:\rho$. 因为$M$没有自由项或类型变量，所有可以取$\Gamma\equiv\emptyset$，于是：</p><p>$(n)\quad\lambda\alpha:*.\lambda f:\alpha\to\alpha.\lambda x:\alpha.f(f\ x)\quad:\quad?$</p><p>下一个定型的项是“二阶$\lambda$”，因此使用$(abst_2)$.</p><p>$(m)\quad \alpha:*\ \vdash\ \lambda f:\alpha\to\alpha.\lambda x:\alpha.f(f\ x)\ :\ ?$</p><p>$(n)\quad\lambda\alpha:*.\lambda f:\alpha\to\alpha.\lambda x:\alpha.f(f\ x)\ :\ \dots\quad对(m)用(abst_2)$</p><p>新的目标是$\lambda f:\alpha\to\alpha.\ \dots$，是个普通的一阶抽象，使用$(abst)$：</p><p>$(k)\quad\alpha:*,\ f:\alpha\to\alpha,\ x:\alpha\ \vdash\ f(fx)\ :\ ?$</p><p>$(l)\quad\alpha:*,\ f:\alpha\to\alpha\ \vdash\ \lambda x:\alpha.f(fx)\ :\ \dots\quad对（k）用(abst)$</p><p>$(m)\quad\alpha:*\ \vdash\ \lambda f:\alpha\to\alpha.\lambda x:\alpha.f(fx)\ :\ \dots\quad对(l)用(abst)$</p><p>$(n)\quad\lambda\alpha:*.\lambda f:\alpha\to\alpha.\lambda x:\alpha.f(f\ x)\ :\ \dots\quad对(m)用(abst_2)$</p><p>剩下的就是一个$\lambda{\to}$ 的定型问题，于是给出简略版本：</p><p>$(1)\quad\alpha:*,\ f:\alpha\to\alpha,\ x:\alpha\ \vdash\ fx\ :\ \alpha$</p><p>$(2)\quad\alpha:*,\ f:\alpha\to\alpha,\ x:\alpha\ \vdash\ f(fx)\ :\ \alpha$</p><p>$(3)\quad\alpha:*,\ f:\alpha\to\alpha\ \vdash\ \lambda x:\alpha.f(fx)\ :\ type_1\quad对（2）用(abst)$</p><p>$(4)\quad\alpha:*\ \vdash\ \lambda f:\alpha\to\alpha.\lambda x:\alpha.f(fx)\ :\ type_2\quad对(3)用(abst)$</p><p>$(5)\quad\lambda\alpha:*.\lambda f:\alpha\to\alpha.\lambda x:\alpha.f(f\ x)\ :\ type_3\quad对(4)用(abst_2)$</p><p>最后填入$type_1$，$type_2$和$type_3$，使用$(abst)$和$(abst_2)$法则：</p><p>$type_1\equiv\alpha\to\alpha$</p><p>$type_2\equiv(\alpha\to\alpha)\to\alpha\to\alpha$</p><p>$type_3\equiv\Pi\alpha:*.(\alpha\to\alpha)\to\alpha\to\alpha$</p><p>填入第五行，结论是：</p><p>$(5)\quad\emptyset\vdash\lambda\alpha:\ast.\lambda f:\alpha\to\alpha.\lambda x:\alpha.f(fx):\Pi\alpha:\ast.(\alpha\to\alpha)\to\alpha\to\alpha$.</p><p>由Thinning引理（见下一节），我们可以得到，对于所有$\lambda2$上下文$\Gamma$：</p><p>$(6)\quad\Gamma\vdash\lambda\alpha:\ast.\lambda f:\alpha\to\alpha.\lambda x:\alpha.f(fx):\Pi\alpha:\ast.(\alpha\to\alpha)\to\alpha\to\alpha$.</p><p>假设我们有类型$nat$：</p><p>$(7)\quad\Gamma\vdash nat:*$</p><p>有$(6)$和$(7)$用$(appl_2)$：</p><p>$(8)\quad\Gamma\vdash(\lambda\alpha:*.\lambda f:\alpha\to\alpha.\lambda x:\alpha.f(fx))\ nat:(nat\to nat)\to nat\to nat$.</p><p>假设有：</p><p>$(9)\quad\Gamma\vdash suc\ :\ nat\to nat$，</p><p>对$(8)$和$(9)$用$(appl)$：</p><p>$(10)\quad\Gamma\vdash(\lambda\alpha:*.\lambda f:\alpha\to\alpha.\lambda x:\alpha.f(fx))\ nat \ suc:nat\to nat$.</p><p>有$\Gamma\vdash two:nat$，得到：</p><p>$(11)\quad\Gamma\vdash(\lambda\alpha:*.\lambda f:\alpha\to\alpha.\lambda x:\alpha.f(fx))\ nat \ suc\ two:nat$.</p><h2 id="lambda2-的性质"><a href="#lambda2-的性质" class="headerlink" title="$\lambda2$的性质"></a>$\lambda2$的性质</h2><h3 id="Alpha替换-Alpha等价推广（α-conversion-α-equivalence-extended）"><a href="#Alpha替换-Alpha等价推广（α-conversion-α-equivalence-extended）" class="headerlink" title="Alpha替换/Alpha等价推广（α-conversion/α-equivalence, extended）"></a>Alpha替换/Alpha等价推广（α-conversion/α-equivalence, extended）</h3><p>（1a）项变量重命名</p><p>$\lambda x:\sigma.M=_\alpha\lambda y:\sigma.M^{x\to y}$如果$y \not\in FV(M)$且$y$不是$M$中的绑定变量.</p><p>（1b）类型变量重命名</p><p>$\lambda \alpha:\ast.M=_\alpha \lambda\beta:\ast.M[\alpha:=\beta]$如果$\beta$不在$M$中出现，</p><p>$\Pi\alpha:\ast.M=_\alpha\Pi\beta:\ast.M[\alpha:=\beta]$如果$\beta$不在$M$中出现.</p><h3 id="mathbb-Lambda-2-项的单步Beta归约（One-step-beta-reduction-to-beta-for-mathbb-Lambda-2-terms）"><a href="#mathbb-Lambda-2-项的单步Beta归约（One-step-beta-reduction-to-beta-for-mathbb-Lambda-2-terms）" class="headerlink" title="$\mathbb{\Lambda_2}$项的单步Beta归约（One-step $\beta$-reduction, $\to_\beta$for $\mathbb{\Lambda_2}$-terms）"></a>$\mathbb{\Lambda_2}$项的单步Beta归约（One-step $\beta$-reduction, $\to_\beta$for $\mathbb{\Lambda_2}$-terms）</h3><p>（1a）一阶：$(\lambda x:\sigma.M)N\to_\beta M[x:=N]$</p><p>（1b）二阶：$(\lambda \alpha:*.M)T\to_\beta M[\alpha:=T]$</p><h3 id="lambda2-中依然成立的引理"><a href="#lambda2-中依然成立的引理" class="headerlink" title="$\lambda2$中依然成立的引理"></a>$\lambda2$中依然成立的引理</h3><ul><li>Free Variables Lemma</li><li>Thinning Lemma</li><li>Condensing Lemma</li><li>Generation Lemma</li><li>Subterm Lemma</li><li>Uniqueness of Types</li><li>Substitution Lemma</li><li>Church–Rosser Theorem</li><li>Subject Reduction</li><li>Strong Normalisation Theorem</li></ul><p>注意唯一不适用的引理是Permutation Lemma，因为对于上下文，后出现的声明可能依赖于前面的。而如果我们改成定义中的$\lambda2$上下文，则就仍然成立.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为&lt;em&gt;Type Theory and Formal Proof : An Introduction&lt;/em&gt; 的笔记，纯个人向（&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;类型抽象和类型应用（Type-abstraction-and-type-application）&quot;&gt;&lt;a href=&quot;#类型抽象和类型应用（Type-abstraction-and-type-application）&quot; class=&quot;headerlink&quot; title=&quot;类型抽象和类型应用（Type-abstraction and type-application）&quot;&gt;&lt;/a&gt;类型抽象和类型应用（Type-abstraction and type-application）&lt;/h2&gt;&lt;p&gt;对于&lt;em&gt;抽象&lt;/em&gt;这个过程，我们有项$M$，其中可能有自由变量$x$，假设$x$有类型$\sigma$，我们从$M$中抽象$x$，可以得到项$\lambda x : \sigma.M$，同时，所有在$M$中的自由变量$x$被绑定了，我们说：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;项$\lambda x:\sigma.M$依赖于项$x$&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;因此，$\lambda{\to}$中可以构造&lt;strong&gt;依赖于项的项&lt;/strong&gt;（terms depending on terms）.&lt;/p&gt;
&lt;p&gt;相应的是&lt;em&gt;应用&lt;/em&gt;，对于$MN$的构造，我们可以把$M$应用到$N$，也得到一个项.&lt;/p&gt;
&lt;p&gt;这称为&lt;em&gt;一阶&lt;/em&gt;（first order）抽象，或一阶依赖，因为这个抽象是在项上进行的. 同时应用也是一阶的.&lt;/p&gt;
&lt;p&gt;现在我们引入&lt;strong&gt;依赖于类型的项&lt;/strong&gt;（terms depending on types），称&lt;em&gt;二阶&lt;em&gt;运算（&lt;/em&gt;second order&lt;/em&gt; operations）或二阶依赖（second order dependency）.&lt;/p&gt;
&lt;p&gt;得到的这一系统称&lt;em&gt;二阶类型lambda演算（second order typed lambda calculus）&lt;/em&gt;，或$\lambda 2$.&lt;/p&gt;
    
    </summary>
    
      <category term="小课堂" scheme="https://121.5.103.67/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="函数式" scheme="https://121.5.103.67/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
      <category term="教程" scheme="https://121.5.103.67/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="类型论" scheme="https://121.5.103.67/tags/%E7%B1%BB%E5%9E%8B%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【类型论】二、Simply typed lambda calculus</title>
    <link href="https://121.5.103.67/2021/03/06/%E3%80%90%E7%B1%BB%E5%9E%8B%E8%AE%BA%E3%80%91%E4%BA%8C%E3%80%81Simply-typed-lambda-calculus/"/>
    <id>https://121.5.103.67/2021/03/06/【类型论】二、Simply-typed-lambda-calculus/</id>
    <published>2021-03-06T12:21:00.000Z</published>
    <updated>2021-11-01T10:35:51.914Z</updated>
    
    <content type="html"><![CDATA[<p>本文为<em>Type Theory and Formal Proof : An Introduction</em> 的笔记，纯个人向（</p><hr><h2 id="简单类型（Simple-types）"><a href="#简单类型（Simple-types）" class="headerlink" title="简单类型（Simple types）"></a>简单类型（Simple types）</h2><p>我们从一个<strong>类型变量</strong>（type variables）的无限集开始：$\mathbb{V}=\lbrace \alpha,\beta,\gamma,…\rbrace$.</p><h3 id="所有简单类型的集合-mathbb-T"><a href="#所有简单类型的集合-mathbb-T" class="headerlink" title="所有简单类型的集合$\mathbb{T}$"></a>所有简单类型的集合$\mathbb{T}$</h3><ol><li>类型变量（Type variable）若$\alpha \in \mathbb{V}$，则$\alpha \in \mathbb{T}$</li><li>箭头类型（Arrow type）若$\sigma,\tau \in \mathbb{T}$，则$(\sigma \to \tau) \in \mathbb{T}$</li></ol><p>即 $\mathbb{T= V\ \mid\ T \to T}$ .</p><a id="more"></a><p>记法：使用字母$\alpha,\beta,…$表示$\mathbb{V}$中的类型变量，$\sigma,\tau,…$（有时也用$A,B,…$）表示一个简单类型. 最外侧的括号可以省略. 箭头是右结合的.</p><p>“项$M$有类型$\tau$”，我们引入<strong>定型陈述</strong>（statements, or typing statements），形式为$M:\tau$.</p><p>我们假设对于每个类型都有无穷的变量，且每个变量的类型都是唯一的，即若$x:\sigma$且$x:\tau$，则$\sigma \equiv \tau$.</p><p>对于lambda演算的构造方法，有：</p><ol><li>应用：若$M:\sigma \to \tau$且$N:\sigma$，则$M\ N:\tau$.</li><li>抽象：若$x:\sigma$且$M:\tau$，则$\lambda x.M:\sigma \to \tau$</li></ol><h3 id="可定型的项（Typable-term）"><a href="#可定型的项（Typable-term）" class="headerlink" title="可定型的项（Typable term）"></a>可定型的项（Typable term）</h3><p>我们说一个项$M$可定型，如果存在类型$\sigma$使得$M:\sigma$.</p><h2 id="Church定型与Curry定型（Church-typing-and-Curry-typing）"><a href="#Church定型与Curry定型（Church-typing-and-Curry-typing）" class="headerlink" title="Church定型与Curry定型（Church-typing and Curry-typing）"></a>Church定型与Curry定型（Church-typing and Curry-typing）</h2><p>对于定型，有两种方法：</p><h3 id="Church定型（Typing-a-la-Church）"><a href="#Church定型（Typing-a-la-Church）" class="headerlink" title="Church定型（Typing à la Church）"></a>Church定型（Typing à la Church）</h3><p>假设$x$有类型$\alpha \to \alpha$，且$y$有类型$(\alpha \to \alpha) \to \beta$，则$yx$有类型$\beta$. 然后$z$有类型$\beta$，且$u$有类型$\gamma$，则$\lambda zu.z$有类型$\beta \to \gamma \to \beta$. 所以，如果$(\lambda zu.z)(yx)$是允许的，则有类型$\gamma \to \beta$.</p><h3 id="Curry定型（Typing-a-la-Curry）"><a href="#Curry定型（Typing-a-la-Curry）" class="headerlink" title="Curry定型（Typing à la Curry）"></a>Curry定型（Typing à la Curry）</h3><p>对于lambda项$M \equiv (\lambda zu.z)(yx)$，假设变量$x,y,z,u$的类型并没有给出. 我们注意到$M$是一个$\lambda zu.z$对$yx$的应用，所以$\lambda zu.z$应该有一个函数类型，比如$A \to B$，且$yx$必须有类型$A$，所以$M$有类型$B$. </p><p>$\lambda zu.z:A \to B$表明$z:A$且$\lambda u.z:B$. 对于后一个类型陈述，$B$是一个$\lambda$开头抽象的项，因此$B$具有函数类型$B\equiv (C \to D)$，且$u:C,z:D$. </p><p>而$yx$是一个应用，因此一定有$y:E \to F$且$x:E$，则$yx:F$. </p><p>我们有：</p><ul><li>$x:E$</li><li>$y:E\to F$</li><li>$z:A 且 z:D，所以A\equiv D$</li><li>$u:C$</li><li>$B\equiv (C \to D)$</li><li>$yx:A 且yz:F，所以A \equiv F$</li></ul><p>得到$(*)\ x:E,y:E\to A,z:A,u:C$.</p><p>我们可以将变量$x,y,z,u$赋予“真实”的类型，填入$(*)$式的样板，如：</p><ul><li>$x:\beta, y:\beta \to \alpha, z:\alpha,u:\delta, M:\delta \to \alpha$</li><li>$x:\alpha \to \alpha,y:(\alpha \to \alpha)\to \beta,z:\beta,u:\gamma,M:\gamma \to \beta$</li><li>$x:\alpha,y:\alpha\to \alpha \to \beta, z:\alpha \to \beta,u:\alpha \to \alpha$</li></ul><p>我们对于绑定的变量直接给出类型，自由变量的类型称为<strong>上下文</strong>（context）.</p><p>对于项$(\lambda zu.z)(yx)$，$z,u$是绑定的，而$x,y$是自由的. 假设$z:\beta$且$u:\gamma$，我们记作$(\lambda z:\beta.\lambda u:\gamma.z)(yx)$.</p><p>对于此例的上下文，记作：</p><p>$x:\alpha \to \alpha,y:(\alpha \to \alpha) \to \beta \ \vdash\  (\lambda z:\beta.\lambda u:\gamma.z)(yx):\gamma \to \beta$.</p><h2 id="Church的-lambda-to-的派生法则"><a href="#Church的-lambda-to-的派生法则" class="headerlink" title="Church的$\lambda{\to}$的派生法则"></a>Church的$\lambda{\to}$的派生法则</h2><h3 id="预标注类型的lambda项（Pre-typed-λ-terms-Lambda-mathbb-T-）"><a href="#预标注类型的lambda项（Pre-typed-λ-terms-Lambda-mathbb-T-）" class="headerlink" title="预标注类型的lambda项（Pre-typed λ-terms,$\Lambda_\mathbb{T}$）"></a>预标注类型的lambda项（Pre-typed λ-terms,$\Lambda_\mathbb{T}$）</h3><p>$\Lambda_\mathbb{T}=V\mid(\Lambda_\mathbb{T}\Lambda_\mathbb{T})\mid(\lambda V:\mathbb{T}.\Lambda_\mathbb{T})$.</p><h3 id="陈述，声明，上下文，推断（Statement-declaration-context-judgement）"><a href="#陈述，声明，上下文，推断（Statement-declaration-context-judgement）" class="headerlink" title="陈述，声明，上下文，推断（Statement, declaration, context, judgement）"></a>陈述，声明，上下文，推断（Statement, declaration, context, judgement）</h3><ol><li><strong>陈述</strong>（statement）具有形式$M:\sigma$，其中$M \in \Lambda_\mathbb{T}$且$\sigma \in \mathbb{T}$. 在陈述中，称$M$主体（subject），$\sigma$为类型.</li><li><strong>声明</strong>（declaration）是以变量为主体的陈述.</li><li><strong>上下文</strong>（context）是一个对于<em>不同</em>主体的声明的列表.</li><li><strong>推断</strong>（judgement）具有形式$\Gamma \ \vdash \ M:\sigma$，其中$\Gamma$是上下文，而$M:\sigma$是陈述.</li></ol><p>我们需要判断一个推断是否是可派生的，引入<strong>派生系统</strong>（derivation system）.</p><p><strong>前提-结论格式</strong>（premiss–conclusion format）：</p><p>$\dfrac{前提1\ 前提2\ …\ 前提n}{结论}$</p><p>由此给出Church的$\lambda{\to}$的三条派生法则，以此建立Church的$\lambda{\to}$的派生系统.</p><h3 id="Church的-lambda-to-的派生法则（Derivation-rules-for-lambda-to-）"><a href="#Church的-lambda-to-的派生法则（Derivation-rules-for-lambda-to-）" class="headerlink" title="Church的$\lambda{\to}$的派生法则（Derivation rules for $\lambda{\to}$）"></a>Church的$\lambda{\to}$的派生法则（Derivation rules for $\lambda{\to}$）</h3><p>$(var)\qquad \Gamma\  \vdash\ x:\sigma 若x:\sigma\in \Gamma$</p><p>$(appl)\ \dfrac{\Gamma\ \vdash \ M:\sigma\to\tau\qquad \Gamma\ \vdash\ N:\sigma}{\Gamma\ \vdash\ MN:\tau}$</p><p>$(abst)\ \dfrac{\Gamma,x:\sigma\ \vdash\ M:\tau}{\Gamma \ \vdash\ \lambda x:\sigma.M:\sigma\to\tau}$</p><p>基于派生系统可标注类型的项称<strong>合法的</strong>（legal）.</p><h3 id="合法的-lambda-to-项（Legal-lambda-to-terms）"><a href="#合法的-lambda-to-项（Legal-lambda-to-terms）" class="headerlink" title="合法的$\lambda{\to}$项（Legal $\lambda{\to}$-terms）"></a>合法的$\lambda{\to}$项（Legal $\lambda{\to}$-terms）</h3><p>在$\lambda{\to}$中，一个预标注类型的lambda项$M$是<strong>合法的</strong>，如果存在上下文$\Gamma$和类型$\rho$使得$\Gamma \vdash M:\rho$.</p><h2 id="类型论需要解决的几类问题"><a href="#类型论需要解决的几类问题" class="headerlink" title="类型论需要解决的几类问题"></a>类型论需要解决的几类问题</h2><h3 id="良类型性-可定型性（Well-typedness-Typability）"><a href="#良类型性-可定型性（Well-typedness-Typability）" class="headerlink" title="良类型性/可定型性（Well-typedness/Typability）"></a>良类型性/可定型性（Well-typedness/Typability）</h3><p>形如：</p><p>$?\  \vdash\  项:\ ?$</p><p>即判断一个项是否合法，如果合法则找到一个合适的上下文和类型，否则找出它出错的地方.</p><p>一个变体是<strong>类型赋值</strong>（Type Assignment），即给出上下文，只要找出项的类型：</p><p>$上下文\ \vdash\ 项\ :\ ?$.</p><h3 id="类型检查（Type-Checking）"><a href="#类型检查（Type-Checking）" class="headerlink" title="类型检查（Type Checking）"></a>类型检查（Type Checking）</h3><p>$上下文\ \overset{?}{\vdash}\ 项\ :\ 类型$</p><p>给出上下文、项和类型，检查是否这个项（在这个上下文中）有这个类型.</p><h3 id="项的寻找（Term-Finding-Term-Construction-Inhabitation）"><a href="#项的寻找（Term-Finding-Term-Construction-Inhabitation）" class="headerlink" title="项的寻找（Term Finding/Term Construction/Inhabitation）"></a>项的寻找（Term Finding/Term Construction/Inhabitation）</h3><p>$上下文\ \vdash\ ?\ :\ 类型$</p><p>给定上下文和类型，寻找是否存在合适的项.</p><h2 id="lambda-to-中的良类型性"><a href="#lambda-to-中的良类型性" class="headerlink" title="$\lambda{\to}$中的良类型性"></a>$\lambda{\to}$中的良类型性</h2><p>例：项$M\equiv \lambda y:\alpha \to \beta .\lambda z:\alpha.yz$是否合法. 即找到上下文$\Gamma$和类型$\rho$，使得$\Gamma \vdash M:\rho$.</p><p>首先$\Gamma\equiv\emptyset$就可以，因为$M$中没有自由变量需要定型. 其次就是找到$\rho$：</p><p>$(n)\quad \lambda y.\alpha \to \beta.\lambda z:\alpha.yz\ :\ ?$</p><p>由三条派生法则中，只有抽象法则$(abst)$可以用，这样就变成了：</p><p>$\quad\vdots$</p><p>$(m)\quad y:\alpha \to \beta\ \vdash\ \lambda z:\alpha.yz\ :\ ?$</p><p>$(n)\quad \lambda y:\alpha\to \beta.\lambda z:\alpha.yz:\dots\qquad 对(m)用(abst)$</p><p>这样问题就变成了$(m)$中的$?$. 需要找到$\lambda z:\alpha.yz$的类型，同样是$\lambda$，重复上面的操作：</p><p>$\quad\vdots$</p><p>$(l)\quad y:\alpha \to \beta,\ z:\alpha \ \vdash\  yz\ :\ ?$</p><p>$(m)\quad y:\alpha \to \beta \ \vdash\ \lambda z:\alpha.yz\ :\ \dots \qquad对(l)用(abst)$</p><p>$(n)\quad \lambda y:\alpha\to \beta.\lambda z:\alpha.yz:\dots\qquad 对(m)用(abst)$</p><p>新的要定型的项是$yz$，是一个应用，所以只能用应用法则$(appl)$. 而$(appl)$有两个前提，所以现在有两个新目标：</p><p>$\quad\vdots$</p><p>$(k_1)\quad y:\alpha \to \beta,\ z:\alpha \ \vdash\ y\ :\ ?_1$</p><p>$\quad \vdots$</p><p>$(k_2)\quad y:\alpha \to \beta,\ z:\alpha \ \vdash\ z\ :\ ?_2$</p><p>$(l)\quad y:\alpha \to \beta,\ z:\alpha \ \vdash\  yz\ :\ \dots \qquad 对(k_1)和(k_2)用(appl)$</p><p>$(m)\quad y:\alpha \to \beta \ \vdash\ \lambda z:\alpha.yz\ :\ \dots \qquad对(l)用(abst)$</p><p>$(n)\quad \lambda y:\alpha\to \beta.\lambda z:\alpha.yz:\dots\qquad 对(m)用(abst)$</p><p>现在的目标是$y$和$z$，它们是简单的<em>变量</em>，因此用变量法则$(var)$就完了. 接下来对于$(l)$的项$yz$，由于$(appl)$的条件满足了就可以得到它的类型$\beta$. 接下来的项的类型也都可以这样得到.</p><p>最终得出的结论是我们找到了一个派生，说明$\lambda y:\alpha \to \beta:\alpha.yz$是合法的.</p><h2 id="lambda-to-中的类型检查"><a href="#lambda-to-中的类型检查" class="headerlink" title="$\lambda{\to}$中的类型检查"></a>$\lambda{\to}$中的类型检查</h2><p>例：$x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta\ \vdash\ (\lambda z:\beta.\lambda u:\gamma.z)(yx):\gamma \to\beta$.</p><p>我们的目标是填入下面的点点点：</p><p>$\quad\vdots$</p><p>$(n)\quad x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta\ \vdash\ (\lambda z:\beta.\lambda u:\gamma.z)(yx):\gamma \to\beta$</p><p>因为项$(\lambda z:\beta.\lambda u:\gamma.z)(yx):\gamma \to\beta$是一个应用项，我们使用应用法则$(appl)$.</p><p>$\quad\vdots$</p><p>$(m_1)\  x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta \ \vdash\ \lambda z:\beta.\lambda u:\gamma.z\ :\ ?_1$</p><p>$\quad\vdots$</p><p>$(m_2)\  x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta \ \vdash\ yx\ :\ ?_2$</p><p>$(n)\quad x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta\ \vdash\ (\lambda z:\beta.\lambda u:\gamma.z)(yx):\gamma \to\beta \quad对(m_1)和(m_2)用(appl),(?)$</p><p>因为$(appl)$法则只有在对应的类型匹配上了才成立，所以最后一行还留了个$(?)$.</p><p>对于$?_2$可以用两次$(var)$法则然后$(appl)$法则解决，并且$y$和$x$的类型也匹配得上. 现在还剩：</p><p>$\quad\vdots$</p><p>$(m_1)\  x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta \ \vdash\ \lambda z:\beta.\lambda u:\gamma.z\ :\ ?$</p><p>对于两个$\lambda$可以使用两次$(abst)$法则解决，就得到了完整的派生：</p><p>$(a) \quad x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta,\ z:\beta,\ u:\gamma \ \vdash\ x:\alpha$<br>$(b) \quad x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta,\ z:\beta,\ u:\gamma \ \vdash\ y:(\alpha \to \alpha)\to \beta$<br>$(1) \quad x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta,\ z:\beta,\ u:\gamma \ \vdash\ z:\beta$</p><p>$(2)\quad x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta,\ z:\beta \ \vdash\ \lambda u:\gamma.z:\gamma \to \beta \quad 对(1)用(abst)$</p><p>$(m_1)\  x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta \ \vdash\ \lambda z:\beta.\lambda u:\gamma.z\ :\ \beta \to\gamma\to\beta \quad 对(2)用(abst)$</p><p>$(m_2)\  x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta \ \vdash\ yx\ :\beta \quad 对(b)和(a)用(appl)$</p><p>$(n)\quad x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta\ \vdash\ (\lambda z:\beta.\lambda u:\gamma.z)(yx):\gamma \to\beta \quad对(m_1)和(m_2)用(appl),(?)$</p><p>接下来只剩下检查$(n)$ 的$(appl)$ 的条件，显然满足了. 于是我们给出了这个推断的正确派生.</p><h2 id="lambda-to-中项的寻找"><a href="#lambda-to-中项的寻找" class="headerlink" title="$\lambda{\to}$中项的寻找"></a>$\lambda{\to}$中项的寻找</h2><p>在逻辑表达式中，我们有$A \to B \to A$，其中的$\to$读作“蕴含”，这个命题是一个“重言式”. 这很显然，因为：如果A，那么（如果B那么A）.</p><p>我们可以用$\lambda{\to}$形式化这个证明，把$A\to B\to A$作为一个类型，尝试找到一个在空上下文中的项：</p><p>$(n)\quad ?\ :\ A\to B\to A$</p><p>需要一个$\to$类型的项，所以首先用$(abst)$法则：</p><p>$(m)\quad x:A \ \vdash\ ?\ :\ B\to A$</p><p>$(n)\quad \dots\ :\ A\to B\to A\qquad 对(m)用(abst)$</p><p>现在仍然是一个$\to$类型的项，引入新变量$y$重复这个过程：</p><p>$(l)\quad x:A,\ y:B\ \vdash\ ?\ :\ A$</p><p>$(m)\quad x:A \ \vdash\ ?\ :\ B\to A\qquad 对(l)用(abst)$</p><p>$(n)\quad \dots\ :\ A\to B\to A\qquad 对(m)用(abst)$</p><p>现在$?$可以被$(var)$法则解决：</p><p>$(1)\quad x:A,\ y:B\ \vdash\ x\ :\ A$</p><p>$(2)\quad x:A \ \vdash\ \lambda y:B.\ x\ :\ B\to A\qquad 对(1)用(abst)$</p><p>$(3)\quad \lambda x:A.\ \lambda y:B.\ x\ :\ A\to B\to A\qquad 对(2)用(abst)$</p><p>就完成了. </p><p>我们将命题看做类型，把命题的inhabitants作为<em>证明</em>：</p><p>$假设x是命题A的证明，y是命题B的证明.$</p><p>$(1)\quad 那么x（仍）是A的证明.$</p><p>$(2)\quad y到x的函数是一个由B到A的证明，即\lambda y:B.\ x证明了B\to A这个蕴含.$</p><p>$(3)\quad 所以，\lambda x:A.\lambda y:B\ x证明了A\to B\to A.$</p><p>这一过程称<strong>PAT-解释</strong>（PAT-interpretation），“PAT”既指“命题作为类型”（propositions-as-types），又指“证明作为项”（proofs-as-term）. </p><h2 id="lambda-to-的性质"><a href="#lambda-to-的性质" class="headerlink" title="$\lambda{\to}$的性质"></a>$\lambda{\to}$的性质</h2><h3 id="定义域，子上下文，置换，投影（Domain-rm-dom-subcontext-subseteq-permutation-projection-upharpoonright-）"><a href="#定义域，子上下文，置换，投影（Domain-rm-dom-subcontext-subseteq-permutation-projection-upharpoonright-）" class="headerlink" title="定义域，子上下文，置换，投影（Domain, $\rm dom$, subcontext, $\subseteq$, permutation, projection, $\upharpoonright$）"></a><strong>定义域，子上下文，置换，投影</strong>（Domain, $\rm dom$, subcontext, $\subseteq$, permutation, projection, $\upharpoonright$）</h3><ol><li>如果$\Gamma \equiv x_1 : \sigma_1,\dots,x_n:\sigma_n$，则$\Gamma$的<strong>定义域</strong>（domain）或$\rm dom(\Gamma)$为列表$(x_1,\dots,x_n)$.</li><li>上下文$\Gamma’$是$\Gamma$ 的<strong>子上下文</strong>（subcontext），或$\Gamma’ \subseteq \Gamma$，如果$\Gamma’$中所有的声明也在$\Gamma$中以相同次序出现.</li><li>上下文$\Gamma’$是上下文$\Gamma$的一个<strong>置换</strong>（permutation），如果所有在$\Gamma’$中的声明也在$\Gamma$中出现，反之亦然.</li><li>如果$\Gamma$是一个上下文，$\Phi$是一个变量的集合，则$\Gamma$在$\Phi$上的<strong>投影</strong>（projection）或$\Gamma \upharpoonright\Phi$，是$\Gamma$的一个子上下文$\Gamma’$，满足${\rm dom}(\Gamma’) = {\rm dom}(\Gamma)\cap\Phi$.</li></ol><h3 id="自由变量引理-Free-Variables-Lemma"><a href="#自由变量引理-Free-Variables-Lemma" class="headerlink" title="自由变量引理 (Free Variables Lemma)"></a><strong>自由变量引理</strong> <em>(Free Variables Lemma)</em></h3><p>若$\Gamma \vdash L:\sigma$，则$FV(L)\subseteq {\rm dom}(\Gamma)$.</p><p>这说明，如果$L$有类型，则所有在$L$中出现的自由变量$x$都有类型，且作为一条声明$x:\sigma$记录在上下文$\Gamma$中.</p><h3 id="引理-Thinning-Condensing-Permutation"><a href="#引理-Thinning-Condensing-Permutation" class="headerlink" title="引理 (Thinning, Condensing, Permutation)"></a>引理 <em>(Thinning, Condensing, Permutation)</em></h3><ol><li>（Thinning）令$\Gamma’$与$\Gamma’’$是上下文，使得$\Gamma’ \subseteq \Gamma’’$. 若$\Gamma’ \vdash M:\sigma$则$\Gamma’’ \vdash M:\sigma$.</li><li>（Condensing）若$\Gamma \vdash M:\sigma$，则$\Gamma \upharpoonright FV(M) \vdash M:\sigma$.</li><li>（Permutation）若$\Gamma \vdash M:\sigma$，且$\Gamma’$是$\Gamma$的一个permutation，则$\Gamma’$也是上下文，且$\Gamma’ \vdash M:\sigma$.</li></ol><ul><li>Thinning指一个上下文加上更多声明的扩展，即与<em>子上下文</em>相反. </li><li>Condensing指仅需要保留$\Gamma$中关于$FV(M)$的部分就可以得到$M$的类型.</li><li>Permutation指上下文的顺序并不重要，上下文中的声明并没有相互依赖关系.</li></ul><p>因此在$\lambda{\to}$中，也可以用集合代替列表定义上下文，集合上下文称<strong>基</strong>（bases）. 我们用列表因为对于更复杂的系统还会有依赖的声明，此时顺序就很重要.</p><h3 id="生成引理（Generation-Lemma）"><a href="#生成引理（Generation-Lemma）" class="headerlink" title="生成引理（Generation Lemma）"></a>生成引理（Generation Lemma）</h3><ol><li>若$\Gamma \vdash x:\sigma$，则$x:\sigma \in \Gamma$.</li><li>若$\Gamma \vdash MN:\tau$，则存在类型$\sigma$使得$\Gamma \vdash M:\sigma \to \tau$且$\Gamma \vdash N:\sigma$.</li><li>若$\Gamma\vdash \lambda x:\sigma.M:\rho$，则存在$\tau$使得$\Gamma,\ x:\sigma\vdash M:\tau$且$\rho \equiv \sigma \to \tau$.</li></ol><p>就对应了三条派生法则.</p><h3 id="子项引理（Subterm-Lemma）"><a href="#子项引理（Subterm-Lemma）" class="headerlink" title="子项引理（Subterm Lemma）"></a>子项引理（Subterm Lemma）</h3><p>若$M$是合法的，则$M$的所有子项都是合法的.</p><h3 id="类型唯一性（Uniqueness-of-Types）"><a href="#类型唯一性（Uniqueness-of-Types）" class="headerlink" title="类型唯一性（Uniqueness of Types）"></a>类型唯一性（Uniqueness of Types）</h3><p>设$\Gamma \vdash M:\sigma$且$\Gamma \vdash M : \tau$，则$\sigma \equiv \tau$.</p><h3 id="可判定性定理"><a href="#可判定性定理" class="headerlink" title="可判定性定理"></a>可判定性定理</h3><p>(Decidability of Well-typedness, Type Assignment, TypeChecking and Term Finding)</p><p>在$\lambda{\to}$中，以下问题都是可判定的：</p><ol><li>Well-typedness（1a）Type Assignment</li><li>Type Checking</li><li>Term Finding</li></ol><h2 id="归约和-lambda-to"><a href="#归约和-lambda-to" class="headerlink" title="归约和$\lambda{\to}$"></a>归约和$\lambda{\to}$</h2><p>对于$\lambda{\to}$中的beta归约，我们对代换的定义进行以下调整：</p><ol start="3"><li>$(\lambda y:\sigma.P)[x:=N]\equiv \lambda z:\sigma.(P^{y \to z}[x:=N])$，若$\lambda z:\sigma.P^{y \to z}$是$\lambda y:\sigma.P$的alpha变形使得$z \notin FV(N)$.</li></ol><p>此时我们有：</p><h3 id="代换引理（Substitution-Lemma）"><a href="#代换引理（Substitution-Lemma）" class="headerlink" title="代换引理（Substitution Lemma）"></a>代换引理（Substitution Lemma）</h3><p>设$\Gamma’,\ x:\sigma,\ \Gamma’’ \vdash M:\tau$且$\Gamma’ \vdash N:\sigma$，则$\Gamma’,\Gamma’’ \vdash M[x:=N]:\tau$.</p><h3 id="对-mathbb-Lambda-T-的单步beta归约（-to-beta-for-mathbb-Lambda-T-）"><a href="#对-mathbb-Lambda-T-的单步beta归约（-to-beta-for-mathbb-Lambda-T-）" class="headerlink" title="对$\mathbb{\Lambda_T}$的单步beta归约（$\to_\beta$, for $\mathbb{\Lambda_T}$）"></a>对$\mathbb{\Lambda_T}$的单步beta归约（$\to_\beta$, for $\mathbb{\Lambda_T}$）</h3><ol><li>(Basis) $(\lambda x:\sigma.M)N\to_\beta M[x:=N]$</li><li>(Compatibility)同第一章定义</li></ol><h3 id="Church–Rosser定理"><a href="#Church–Rosser定理" class="headerlink" title="Church–Rosser定理"></a>Church–Rosser定理</h3><p>在$\lambda{\to}$上仍成立</p><h3 id="主体归约引理（Subject-Reduction）"><a href="#主体归约引理（Subject-Reduction）" class="headerlink" title="主体归约引理（Subject Reduction）"></a>主体归约引理（Subject Reduction）</h3><p>若$\Gamma \vdash L : \rho$且若$L \twoheadrightarrow_\beta L’$，则$\Gamma \vdash L’:\rho$.</p><p>即beta归约不影响类型性，且对项进行beta归约不影响项的类型. </p><h3 id="强标准定理-终止定理（Strong-Normalisation-Theorem-Termination-Theorem）"><a href="#强标准定理-终止定理（Strong-Normalisation-Theorem-Termination-Theorem）" class="headerlink" title="强标准定理/终止定理（Strong Normalisation Theorem/Termination Theorem）"></a>强标准定理/终止定理（Strong Normalisation Theorem/Termination Theorem）</h3><p>所有合法的项$M$都是强标准化的.</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>$\lambda{\to}$中没有自应用（self-application）</li><li>Beta范式的存在性得以保证</li><li>不是所有合法的项都有不动点</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为&lt;em&gt;Type Theory and Formal Proof : An Introduction&lt;/em&gt; 的笔记，纯个人向（&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;简单类型（Simple-types）&quot;&gt;&lt;a href=&quot;#简单类型（Simple-types）&quot; class=&quot;headerlink&quot; title=&quot;简单类型（Simple types）&quot;&gt;&lt;/a&gt;简单类型（Simple types）&lt;/h2&gt;&lt;p&gt;我们从一个&lt;strong&gt;类型变量&lt;/strong&gt;（type variables）的无限集开始：$\mathbb{V}=\lbrace \alpha,\beta,\gamma,…\rbrace$.&lt;/p&gt;
&lt;h3 id=&quot;所有简单类型的集合-mathbb-T&quot;&gt;&lt;a href=&quot;#所有简单类型的集合-mathbb-T&quot; class=&quot;headerlink&quot; title=&quot;所有简单类型的集合$\mathbb{T}$&quot;&gt;&lt;/a&gt;所有简单类型的集合$\mathbb{T}$&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;类型变量（Type variable）若$\alpha \in \mathbb{V}$，则$\alpha \in \mathbb{T}$&lt;/li&gt;
&lt;li&gt;箭头类型（Arrow type）若$\sigma,\tau \in \mathbb{T}$，则$(\sigma \to \tau) \in \mathbb{T}$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即 $\mathbb{T= V\ \mid\ T \to T}$ .&lt;/p&gt;
    
    </summary>
    
      <category term="小课堂" scheme="https://121.5.103.67/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="函数式" scheme="https://121.5.103.67/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
      <category term="教程" scheme="https://121.5.103.67/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="类型论" scheme="https://121.5.103.67/tags/%E7%B1%BB%E5%9E%8B%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【类型论】一、Untyped lambda calculus</title>
    <link href="https://121.5.103.67/2021/03/06/%E3%80%90%E7%B1%BB%E5%9E%8B%E8%AE%BA%E3%80%91%E4%B8%80%E3%80%81Untyped-lambda-calculus/"/>
    <id>https://121.5.103.67/2021/03/06/【类型论】一、Untyped-lambda-calculus/</id>
    <published>2021-03-06T07:23:46.000Z</published>
    <updated>2021-03-06T11:59:44.518Z</updated>
    
    <content type="html"><![CDATA[<p>本文为<em>Type Theory and Formal Proof : An Introduction</em> 的笔记，纯个人向（</p><hr><p>对于函数的抽象，有两个构造方法和一个计算规则：</p><p><strong>抽象（Abstraction）</strong></p><p>由一个表达式$M$和一个变量$x$ 可以构造表达式$\lambda x.M$，称为$M$上$x$的<strong>抽象（abstraction of x over M）</strong></p><p><strong>应用（Application）</strong></p><p>由表达式$M$和$N$可以构造表达式$M\ N$，称为$M$对$N$的<strong>应用（application of M to N）</strong></p><p><strong>Beta化简（β-reduction）</strong></p><p>形如$(\lambda x.M)N$的表达式可以被改写成$M[x:=N]$，意思是表达式中的$M$中的每个$x$换成$N$，这一过程称为由$(\lambda x.M)N$到$M[x:=N]$的<strong>Beta化简（β-reduction）</strong>.</p><p><strong>注意</strong>“应用”仅是构造另一个lambda项的过程，而真正得到结果的过程则是“Beta化简”.</p><p>以下是严格定义</p><a id="more"></a><h2 id="Lambda项（Lambda-term）"><a href="#Lambda项（Lambda-term）" class="headerlink" title="Lambda项（Lambda-term）"></a><strong>Lambda项（Lambda-term）</strong></h2><p>设$\Lambda$为所有<strong>Lambda项</strong>的集合，我们有一个<strong>变量</strong>的无限集 $V$，$V=\lbrace x,y,z,…\rbrace$</p><ol><li>（变量Variable）若$u \in V$，则$u \in \Lambda$</li><li>（应用Application）若$M,N \in \Lambda$，则$(M\ N)\in \Lambda$</li><li>（抽象Abstraction）若$u \in V$且$M \in \Lambda$，则$(\lambda u.\ M)\in \Lambda$</li></ol><p>我们使用小写字母表示$V$中的变量，用大写的字母表示$\Lambda$中的项.</p><p>如果两个lambda项$M$和$N$相同（syntactical identity），记为$M \equiv N$.</p><h2 id="子项（Subterm）"><a href="#子项（Subterm）" class="headerlink" title="子项（Subterm）"></a>子项（Subterm）</h2><p>设lambda项$M$的<strong>子项</strong>Multiset为${\rm Sub}(M)$</p><ol><li>（Basis）$\forall x \in V, {\rm Sub}(x)=\lbrace x\rbrace $</li><li>（应用）${\rm Sub}((M\ N))={\rm Sub}(M)\cup{\rm Sub}(N)\cup\lbrace (M\ N)\rbrace $</li><li>（抽象）${\rm Sub}((\lambda x.M))={\rm Sub}(M)\cup\lbrace \lambda x.M\rbrace $</li></ol><p>若$L \in {\rm Sub}(M)$，我们称$L$为$M$的子项.</p><p>子项关系有：</p><ol><li>（自反性）对所有lambda项$M$，有$M \in {\rm Sub}(M)$</li><li>（传递性）若$L \in {\rm Sub}(M)$且$M \in {\rm Sub}(N)$，则$L \in {\rm Sub}(N)$</li></ol><p>若将lambda项写成它的树形表示，我们可以直观的发现子项就是对应的子树.</p><p>若$L$是$M$的子项，且$L \not \equiv M$，称$L$是$M$的<strong>真子项</strong>（proper subterm）.</p><p>另外为了减少括号的使用，定义结合性和优先级：</p><ol><li>应用是左结合的，$M\ N\ L$为$(M(N\ L))$</li><li>应用的优先级比抽象高，$\lambda x.M\ N$为$\lambda x.(M\ N)$</li><li>连续的抽象$\lambda x.(\lambda y.M)$可以简写为，$\lambda xy.M$</li></ol><p>这些定义都与Haskell中的一致，所以挺符合直觉（？）</p><h2 id="自由和绑定变量"><a href="#自由和绑定变量" class="headerlink" title="自由和绑定变量"></a>自由和绑定变量</h2><p>lambda项中出现的变量可以分为三类：<strong>自由的</strong>（free）、<strong>被绑定的</strong>（bound）<strong>和绑定的</strong>（binding）.</p><p>其中，紧接着在$\lambda$后出现的，为绑定的变量；在项$\lambda x.M$中，$M$中的$x$即被绑定的变量；自由变量定义为：</p><p>设$FV$为一个lambda项中<strong>自由变量</strong>的集合，则</p><ol><li>（变量）$FV(x)=\lbrace x\rbrace $</li><li>（应用）$FV(M\ N)=FV(M)\cup FV(N)$</li><li>（抽象）$FV(\lambda x.M)=FV(M)-\lbrace x\rbrace $</li></ol><p>如果$FV(M)=\emptyset$，则称$M$为<strong>闭lambda项</strong>（Closed λ-term），也称<strong>组合子</strong>（combinator）. 所有闭lambda项的集合记为$\Lambda^0$.</p><h2 id="Alpha替换（Alpha-conversion）"><a href="#Alpha替换（Alpha-conversion）" class="headerlink" title="Alpha替换（Alpha conversion）"></a>Alpha替换（Alpha conversion）</h2><p>记$M^{x \rightarrow y}$为把$M$中所有自由变量$x$换成$y$.</p><ol><li><strong>重命名关系</strong>（renaming），符号为$=_\alpha$，定义为：$\lambda x.M =_\alpha \lambda y.M^{x \rightarrow y}$，其中满足$y \notin FV(M)$且$y$不是$M$中的binding变量.</li><li>若$M =_\alpha N$则$M\ L=_\alpha N\ L$，$L\ M=_\alpha L\ N$</li><li>有自反性、对称性、传递性. Alpha替换/重命名关系是一个等价关系.</li></ol><p>若$M =_\alpha N$，则称 $M$与$N$<strong>Alpha可替换</strong>（α-convertible）或<strong>Alpha等价</strong>（α-equivalent）. $M$为$N$的<strong>Alpha变形</strong>（α-variant）.</p><h2 id="代换（Substitution）"><a href="#代换（Substitution）" class="headerlink" title="代换（Substitution）"></a><strong>代换（Substitution）</strong></h2><p>将$M$中所有自由变量$x$ <strong>代换</strong>为$N$，记为$M[x:=N]$，定义为：</p><ol><li>a) $x[x:=N] \equiv N$  b) $y[x:=N] \equiv y$ ，若$x \not \equiv y$</li><li>$(PQ)[x:=N] \equiv (P[x:=N])(Q[x:=N])$</li><li>$(\lambda y.P)[x:=N] \equiv \lambda z.(P^{y \rightarrow z}[x:=N])$，若$\lambda z.P^{y \rightarrow z}$是$\lambda y.P$的Alpha变形，即$z \notin FV(N)$.</li></ol><p>注意含$[x:=N]$的项并不在lambda项的构造方法中，因此并不是lambda项，而是作为一种lambda项的“元表记”. 只有将所有$[x:=N]$全部消解了才能得到一个真的lambda项.</p><p>(1)就是对于$x$字面意义的代换. (2)普通地将替换推到应用的两边.</p><p>(3)的目的是为了防止变量名的冲突，如果$N$中有$y$的自由变量会被原本不应该的$(\lambda y.P)$的$y$绑定。因此需要引入一个不属于$N$的自由变量的$z$，替换原来的$y$. 如果$y \notin FV(N)$，则可以取$z \equiv y$，此时$(\lambda y.P[x:=N]) \equiv \lambda y.(P[x:=N])$.</p><p>引入<strong>顺序代换</strong>（sequential substitution），$M[x:=N][y:=L]$. </p><p><strong>引理：</strong></p><p>令$x \not \equiv y$，设$x \notin FV(L)$，则$M[x:=N][y:=L]\equiv M[y:=L][x:=N[y:=L]]$</p><h2 id="Lambda项模Alpha等价（Lambda-terms-modulo-α-equivalence）"><a href="#Lambda项模Alpha等价（Lambda-terms-modulo-α-equivalence）" class="headerlink" title="Lambda项模Alpha等价（Lambda-terms modulo α-equivalence）"></a><strong>Lambda项模Alpha等价（Lambda-terms modulo α-equivalence）</strong></h2><p><strong>引理：</strong></p><p>令$M_1 =_\alpha M_2$且$N_1 =_\alpha N_2$（？原文为$M_1=_\alpha N_1 \ and\  M_2 =_\alpha N_2 $），则：</p><ol><li>$M_1N_1 =_\alpha M_2N_2$</li><li>$\lambda x.M_1 =_\alpha \lambda x.M_2$</li><li>$M_1[x:=N_1] =_\alpha M_2[x:=N_2]$</li></ol><p>即lambda项构造上保持Alpha等价. 因此，我们将一个Alpha等价的等价类看作同一个抽象lambda项，将Alpha等价也视为相同，记$=_\alpha$为$\equiv$，称<strong>lambda项上模Alpha等价</strong>（λ-terms modulo α-equivalence）.</p><p><strong>Barendregt convention</strong>：我们选取绑定的变量时应使每个都不一样.</p><h2 id="Beta化简（Beta-reduction）"><a href="#Beta化简（Beta-reduction）" class="headerlink" title="Beta化简（Beta reduction）"></a>Beta化简（Beta reduction）</h2><p><strong>单步Beta化简</strong>（One-stepβ-reduction， $\rightarrow_\beta$）</p><ol><li>(Basis) $(\lambda x.M)N \rightarrow_\beta M[x:=N]$</li><li>(Compatibility)若$M \rightarrow_\beta N$，则$ML\rightarrow_\beta NL,LM\rightarrow_\beta LN$且$\lambda x.M \rightarrow_\beta \lambda x.N$</li></ol><p>其中左侧的称<strong>可化简式redex</strong>（reducible expression），右侧称（redex的）<strong>合同</strong>（contractum）.</p><p><strong>Beta化简</strong>（零步或多步，$\twoheadrightarrow_\beta$）</p><p>$M \twoheadrightarrow_\beta N$如果存在$n \geq 0$且存在项$M_0$到$M_n$使得$M_0 \equiv M,M_n \equiv N$，且任取$0 \leq i \lt n$有$M_i \rightarrow_\beta M_{i+1}$</p><p>即若$M \twoheadrightarrow_\beta N$，则存在一个从$M$开始到$N$的单步Beta化简的链：<br>$M \equiv M_0 \rightarrow_\beta M_1 \rightarrow_\beta M_2 \rightarrow_\beta … \rightarrow_\beta M_{n-1} \rightarrow_\beta M_n \equiv N $<br><strong>引理：</strong></p><ol><li>$\twoheadrightarrow_\beta$是$\rightarrow_\beta$的推广，若$M \rightarrow_\beta N$则$M \twoheadrightarrow_\beta N$</li><li>$\twoheadrightarrow_\beta$有自反性和传递性</li></ol><p>这个零步或多步的Beta化简的推广称为<strong>Beta替换</strong>（β-conversion），记作$=_\beta$.</p><p>$M =_\beta N$ </p><p>（读作“ $M与N$ <strong>Beta可替换</strong>（β-convertible）”或“<strong>Beta相等</strong>（β-equal）”）若存在$n \geq 0$且存在项$M_0$到$M_n$，使得$M_0 \equiv M,M_n \equiv N$且任取$0 \leq i \lt n$有$M_i \rightarrow_\beta M_{i+1}或M_{i+1} \rightarrow_\beta M_i$.</p><p>注意每一对$M_i$与$M_{i+1}$应该具有单步关系$\rightarrow_\beta$，但不一定要是从左到右的.</p><p> <strong>引理：</strong></p><ol><li>$=_\beta$是$\twoheadrightarrow_\beta$在两个方向上的推广，若$M \twoheadrightarrow_\beta N$或$N \twoheadrightarrow_\beta M$，则$M =_\beta N$</li><li>$=_\beta$是等价关系，有自反、对称、传递性</li></ol><h2 id="范式与汇合（Normal-forms-and-confluence）"><a href="#范式与汇合（Normal-forms-and-confluence）" class="headerlink" title="范式与汇合（Normal forms and confluence）"></a>范式与汇合（Normal forms and confluence）</h2><p><strong>Beta范式;可Beta标准化</strong>（β-normal form;β-nf;β-normalising）</p><ol><li>$M$是Beta范式，若$M$没有任何redex</li><li>$M$有Beta范式，或可Beta标准化，若存在$N$是Beta范式使得$M =_\beta N$. 这样的$N$称为$M$的Beta范式.</li></ol><p>一个lambda项的Beta范式可以看做它的输出（计算结果）.</p><p><strong>引理：</strong>当$M$是Beta范式，则$M \twoheadrightarrow_\beta N$蕴含$M \equiv N$.</p><p><strong>化简路径</strong>（Reduction path）</p><p>一个从$M$开始的<strong>有穷化简路径</strong>是一个项的有穷序列$N_0,N_1,…,N_n$，使得$N_0 \equiv M$且对任取$0 \leq i \lt n$有$N_i \rightarrow_\beta N_{i+1}$.</p><p>一个从$M$开始的<strong>无穷化简路径</strong>是一个项的无穷序列$N_0,N_1,…$，使得$N_0 \equiv M$且对任取$i \in \mathbb{N}$有$N_i \rightarrow_\beta N_{i+1}$.</p><p><strong>弱标准化，强标准化</strong>（Weak normalisation, strong normalisation）</p><ol><li>$M$可弱标准化，若存在Beta范式$N$使得$M \twoheadrightarrow_\beta N$.</li><li>$M$可强标准化，若不存在从$M$开始的无穷化简路径.</li></ol><p>如果$M$可强标准化，则任意化简路径都可以扩展到一个Beta范式为止；因此，可强标准化的也是可弱标准化.</p><p><strong>Church–Rosser定理;CR定理;汇合定理</strong>（Church–Rosser; CR; Confluence）</p><p>设对于lambda项$M$，有$M \twoheadrightarrow_\beta N_1$且$M \twoheadrightarrow_\beta N_2$，则存在lambda项$N_3$使得$N_1 \twoheadrightarrow_\beta N_3$且$N_2 \twoheadrightarrow_\beta N_3$.</p><p>这意味着一个演算结果（如果存在）与演算过程的顺序无关.</p><p><strong>推论：</strong>设$M =_\beta N$则存在$L$使得$M \twoheadrightarrow_\beta L$且$N \twoheadrightarrow_\beta L$.</p><ol><li>若$M$有Beta范式$N$，则$M \twoheadrightarrow_\beta N$</li><li>一个lambda项最多只有一个Beta范式</li></ol><h2 id="不动点定理（Fixed-Point-Theorem）"><a href="#不动点定理（Fixed-Point-Theorem）" class="headerlink" title="不动点定理（Fixed Point Theorem）"></a>不动点定理（Fixed Point Theorem）</h2><p><strong>定理：</strong> $\forall L \in \Lambda$存在$M \in \Lambda$使得$LM =_\beta M$.</p><p>证：取$M:=(\lambda x.L(xx))(\lambda x.L(xx))$，有<br>$$<br>M \equiv (\lambda x.L(xx))(\lambda x.L(xx)) \<br>\rightarrow_\beta L(,(\lambda x.L(xx))(\lambda x.L(xx)),) \<br>\equiv LM<br>$$</p><p>即$LM =_\beta M$.</p><p>我们定义<strong>不动点组合子</strong>（fixed point combinator）：</p><p>$Y \equiv \lambda y.(\lambda x.y(xx))(\lambda x.y(xx))$.</p><p>对于任意的lambda项$L$，都有$YL$是$L$的一个不动点，因为$L(YL)=_\beta YL$.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为&lt;em&gt;Type Theory and Formal Proof : An Introduction&lt;/em&gt; 的笔记，纯个人向（&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;对于函数的抽象，有两个构造方法和一个计算规则：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象（Abstraction）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由一个表达式$M$和一个变量$x$ 可以构造表达式$\lambda x.M$，称为$M$上$x$的&lt;strong&gt;抽象（abstraction of x over M）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用（Application）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由表达式$M$和$N$可以构造表达式$M\ N$，称为$M$对$N$的&lt;strong&gt;应用（application of M to N）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Beta化简（β-reduction）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;形如$(\lambda x.M)N$的表达式可以被改写成$M[x:=N]$，意思是表达式中的$M$中的每个$x$换成$N$，这一过程称为由$(\lambda x.M)N$到$M[x:=N]$的&lt;strong&gt;Beta化简（β-reduction）&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;“应用”仅是构造另一个lambda项的过程，而真正得到结果的过程则是“Beta化简”.&lt;/p&gt;
&lt;p&gt;以下是严格定义&lt;/p&gt;
    
    </summary>
    
      <category term="小课堂" scheme="https://121.5.103.67/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="函数式" scheme="https://121.5.103.67/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
      <category term="教程" scheme="https://121.5.103.67/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="类型论" scheme="https://121.5.103.67/tags/%E7%B1%BB%E5%9E%8B%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【函数式】二、单子</title>
    <link href="https://121.5.103.67/2020/09/27/%E3%80%90%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%91%E4%BA%8C%E3%80%81%E5%8D%95%E5%AD%90/"/>
    <id>https://121.5.103.67/2020/09/27/【函数式】二、单子/</id>
    <published>2020-09-27T07:54:15.000Z</published>
    <updated>2020-09-27T08:24:43.640Z</updated>
    
    <content type="html"><![CDATA[<p>单子是Haskell语言中较难理解的概念，本文将以简明的语言介绍这一概念及其应用，由于通俗性与严谨性不可兼顾，本文会牺牲一定的严谨性（）。</p><h1 id="单子"><a href="#单子" class="headerlink" title="单子"></a>单子</h1><p><strong>Monad</strong>在Haskell中是一个类型类，中文通常翻译为<strong>单子</strong>，在GHC7.10以后它的定义如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line">  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">  (&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line">  return :: a -&gt; m a</span><br><span class="line">  <span class="meta">&#123;-# MINIMAL (&gt;&gt;=) #-&#125;</span></span><br><span class="line">        <span class="comment">-- Defined in ‘GHC.Base’</span></span><br></pre></td></tr></table></figure><p>可以看出Monad是实现了一个<code>(&gt;&gt;=)</code>运算符的Applicative。而这个<code>(&gt;&gt;=)</code>运算符（<strong>Bind</strong>）类型古怪：它连接的左侧是一个Monad类型的值，右侧则是一个函数。</p><h1 id="Identity单子"><a href="#Identity单子" class="headerlink" title="Identity单子"></a>Identity单子</h1><p>我们从最基本的例子开始。</p><p>Identity单子定义在<code>Control.Monad.Identity</code>中：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Identity</span> a = <span class="type">Identity</span> &#123;<span class="title">runIdentity</span> :: <span class="title">a</span>&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单子是Haskell语言中较难理解的概念，本文将以简明的语言介绍这一概念及其应用，由于通俗性与严谨性不可兼顾，本文会牺牲一定的严谨性（）。&lt;/p&gt;
&lt;h1 id=&quot;单子&quot;&gt;&lt;a href=&quot;#单子&quot; class=&quot;headerlink&quot; title=&quot;单子&quot;&gt;&lt;/a&gt;单子&lt;
      
    
    </summary>
    
      <category term="小课堂" scheme="https://121.5.103.67/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="函数式" scheme="https://121.5.103.67/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
      <category term="Haskell" scheme="https://121.5.103.67/tags/Haskell/"/>
    
      <category term="教程" scheme="https://121.5.103.67/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【函数式】一、函子</title>
    <link href="https://121.5.103.67/2020/08/21/%E3%80%90%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%91%E4%B8%80%E3%80%81%E5%87%BD%E5%AD%90/"/>
    <id>https://121.5.103.67/2020/08/21/【函数式】一、函子/</id>
    <published>2020-08-21T08:55:17.000Z</published>
    <updated>2020-08-22T16:05:30.094Z</updated>
    
    <content type="html"><![CDATA[<p>我们已经熟悉使用map函数对列表进行操作了：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br></pre></td></tr></table></figure><p>而函子就是对这一操作进行的抽象。Haskell通过类型类提供一些抽象的接口，将一些与类型相关的操作封装在了类型（对于类型类）的实现上。</p><a id="more"></a><h1 id="函子"><a href="#函子" class="headerlink" title="函子"></a>函子</h1><p>将map函数的功能进行抽象，发现map是将具有某种结构的数据应用一个函数，类似的我们可以定义对于树等其他数据结构的map。我们把具有这种性质的类型称为<strong>函子(Functor)</strong>，通常作为数据容器的类型都可以实现函子。</p><p>函子类型类在Haskell中如此定义：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure><p>实现一个函子类型实现fmap函数。对比fmap和map的类型签名，可以发现fmap就是map函数的抽象。</p><p>列表也实现了函子类型类，对列表来说，fmap就是map：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> [] <span class="keyword">where</span></span></span><br><span class="line">fmap = map</span><br></pre></td></tr></table></figure><p>对于Maybe类型：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">fmap f <span class="type">Nothing</span> = <span class="type">Nothing</span></span><br><span class="line">fmap f (<span class="type">Just</span> x) = <span class="type">Just</span> (f x)</span><br></pre></td></tr></table></figure><p>另外，还提供了一些运算符：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(&lt;$&gt;) :: <span class="type">Functor</span> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">(&lt;$&gt;) = fmap</span><br><span class="line">(&lt;$) :: <span class="type">Functor</span> f =&gt; a -&gt; f b -&gt; f a</span><br><span class="line">(&lt;$) = fmap.const</span><br></pre></td></tr></table></figure><p>其中&lt;\$&gt;就是fmap的中缀版本，&lt;\$少见，是fmap.const：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="string">"1"</span> &lt;$ [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">[<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>]</span><br><span class="line">&gt; <span class="string">"1"</span> &lt;$ <span class="type">Just</span> <span class="number">1</span></span><br><span class="line"><span class="type">Just</span> <span class="string">"1"</span></span><br></pre></td></tr></table></figure><h2 id="Functor定律"><a href="#Functor定律" class="headerlink" title="Functor定律"></a>Functor定律</h2><p>并不是只要实现了fmap的类型就是函子，函子的fmap函数应当满足一些性质保证使用时的正确性：<br>$$<br>fmap\ id=id<br>$$<br>$$<br>fmap\ (f\circ g)= fmap\ f\circ fmap\ g<br>$$<br>第一条定律说明fmap应该保持该类型的结构，除了应用函数外不应有其他的操作。第二条说明fmap对于函数复合运算应满足分配律。</p><h1 id="可应用函子"><a href="#可应用函子" class="headerlink" title="可应用函子"></a>可应用函子</h1><p>当函子中的是函数时，显然是无法直接应用的，此时就需要实现<strong>可应用函子(Applicative Functor)</strong>。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span></span><br><span class="line">pure :: a -&gt; f a</span><br><span class="line">(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure><p>pure函数将一个a类型的值变为一个可应用函子类型f a的值，而&lt;*&gt;函数可以将函子里的函数应用于函子里的值。</p><p>与函数应用操作符\$对比，&lt;*&gt;是在对应的函子类型范围应用函数，而&lt;\$&gt;则是直接将函数应用于函子。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">($) :: (a -&gt; b) -&gt; a -&gt; b</span><br><span class="line">(&lt;$&gt;) :: <span class="type">Functor</span> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">(&lt;*&gt;) :: <span class="type">Applicative</span> f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure><p>对于Maybe类型，可以这么实现Applicative：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">pure = <span class="type">Just</span></span><br><span class="line"><span class="type">Nothing</span> &lt;*&gt; _ = <span class="type">Nothing</span></span><br><span class="line">(<span class="type">Just</span> f) &lt;*&gt; arg = fmap f arg</span><br></pre></td></tr></table></figure><p>Nothing是&lt;*&gt;运算的零元；而对于Just f，则取出函数f，使用fmap函数将它应用于函子。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="type">Just</span> (+ <span class="number">1</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">1</span></span><br><span class="line"><span class="type">Just</span> <span class="number">2</span></span><br><span class="line">&gt; <span class="type">Nothing</span> &lt;*&gt; <span class="type">Just</span> <span class="number">1</span></span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line">&gt; <span class="type">Just</span> (+ <span class="number">1</span>) &lt;*&gt; <span class="type">Nothing</span></span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure><p>而在Control.Applicative提供了函数将a -&gt; b的函数抬升为f a -&gt; f b</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">liftA</span> :: <span class="type">Applicative</span> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line"><span class="title">liftA</span> f a = pure f &lt;*&gt; a</span><br><span class="line"><span class="title">liftA2</span> :: <span class="type">Applicative</span> f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</span><br><span class="line"><span class="title">liftA2</span> f a b = f &lt;$&gt; a &lt;*&gt; b</span><br></pre></td></tr></table></figure><p>liftA用于一元函数（和fmap没啥区别？），liftA2用于二元函数。</p><p>另外还有两个运算符：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(*&gt;) :: f a -&gt; f b -&gt; f b</span><br><span class="line"><span class="title">u</span> *&gt; v = pure (const id) &lt;*&gt; u &lt;*&gt; v</span><br><span class="line">(&lt;*) :: f a -&gt; f b -&gt; f a</span><br><span class="line"><span class="title">u</span> &lt;* v = pure const &lt;*&gt; u &lt;*&gt; v</span><br></pre></td></tr></table></figure><p>与&lt;\$类似，&lt;*返回前一项，而*&gt;返回后一项</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="type">Nothing</span> &lt;* <span class="type">Just</span> <span class="number">1</span></span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line">&gt; <span class="type">Nothing</span> *&gt; <span class="type">Just</span> <span class="number">1</span></span><br><span class="line"><span class="type">Just</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>列表也实现了Applicative，效果类似于list comprehension</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> [] <span class="keyword">where</span></span></span><br><span class="line">pure x = [x]</span><br><span class="line">fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]</span><br></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; [(+ <span class="number">1</span>),(* <span class="number">2</span>)] &lt;*&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们已经熟悉使用map函数对列表进行操作了：&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;map&lt;/span&gt; :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;而函子就是对这一操作进行的抽象。Haskell通过类型类提供一些抽象的接口，将一些与类型相关的操作封装在了类型（对于类型类）的实现上。&lt;/p&gt;
    
    </summary>
    
      <category term="小课堂" scheme="https://121.5.103.67/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="函数式" scheme="https://121.5.103.67/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
      <category term="Haskell" scheme="https://121.5.103.67/tags/Haskell/"/>
    
      <category term="教程" scheme="https://121.5.103.67/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【杂记】SICP学习笔记（序）</title>
    <link href="https://121.5.103.67/2019/12/06/%E3%80%90%E6%9D%82%E8%AE%B0%E3%80%91SICP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%BA%8F%EF%BC%89/"/>
    <id>https://121.5.103.67/2019/12/06/【杂记】SICP学习笔记（序）/</id>
    <published>2019-12-06T10:15:33.000Z</published>
    <updated>2020-06-23T09:28:36.021Z</updated>
    
    <content type="html"><![CDATA[<p>大一上学期结束了，给我最大震撼的还是这门SICP课；由于过于震撼，我觉得有必要记录下来。原本打算学期结束后写一系列文章总结一下，不料下学期课业过于刺激，只好草草以一篇“序”结束。不过虽然课程结束了，学习仍要继续，所以学习笔记也会不断延伸（？）</p><a id="more"></a><p>说来惭愧，这学期初选课的时候，才第一次听说SICP课，后来到了正式上课，才渐渐了解。这是门名叫“计算机程序的构造和解释”的课程（Structure and Interpretation of Computer Programs/SICP），原书是MIT的著名教程，原课程是UC Berkeley的著名“网红课程”cs61a。这还是我们学校第一次引进这门课程，基本上就是使用的就是cs61a的教程，使用python作为主要的教学语言（然而秉着大一上保护萌新的原则，还是对其内容有一些删减，尽管如此，这也已经让我大开眼界）。</p><p>先看看这一学期都教了些什么吧：</p><ul><li>python语言</li><li>FP部分（递归、副作用、高阶函数、lambda演算）</li><li>数据抽象（用函数闭包实现的树）</li><li>OOP部分（用class重新实现数据抽象）</li><li>scheme语言</li><li>解释器原理</li><li>SQL语言</li><li>……</li></ul><p>这门课的进度我是从开学震撼到结束——实在是太快了、内容太丰富了（然而即使如此，仍然比Berkeley的进度还差一大截）。照我之前的印象中，CS系入门课永远是命令式语言的，后面过渡到OOP，像FP似乎都属于先进技术了，编译原理则更是忌讳给新手打开的黑箱、魔盒……然而，我仍然做到了，完成了上面的所有内容，学到最后的同学们都做到了（确实一开课就劝退了很多“萌新”、堪称退课率最高的一门了……）。这显然是cs61a这课程设计的功劳。</p><h1 id="CS61a"><a href="#CS61a" class="headerlink" title="CS61a"></a>CS61a</h1><p>我已经吹过无数遍cs61a，因为它实在是太精致了。每一个部分显然都是经过精心设计的：  </p><h2 id="一、课程结构"><a href="#一、课程结构" class="headerlink" title="一、课程结构"></a>一、课程结构</h2><p>课程分普通上课（Lecture）、上机实验课（Lab），作业分平时作业（Homework）和大作业（Project）。<br>有一说一，就作业的量来看，这个强度已经远远大于大一CS的传统基础课程“程序设计基础了（说是C++，不如说就是C编程）”。<br>Homework是一周一次，量不大，是与课时内容一致的练习题。值得一提的是，每次homework，都留一些附加题；这些附加题就很有深度了（似乎是课时不够塞不进，但教师真的很想传递的内容（小声））：像“匿名阶乘”（只用lambda，不递归实现阶乘，方法是不动点算子，，，）、“church numeral”（相当于让你自己发明一遍church numeral（orz））……非常震撼，都是想都不敢想会在大一接触到的内容……  </p><p>重头戏是Project,感觉真的是课程设计者的心血所在了。我们这学期做了四个project，分别是：The Game of Hog（一个掷骰子游戏）、Autocorrected Typing Software（打字软件）、Ants Vs. SomeBees（Plants Vs. Zombies复刻，，，）和Scheme Interpreter（Scheme语言的解释器！！！）<br>纯萌新、一学期、整这四个大活儿……<br>当然不是从零写起……学生只负责完成核心算法（当中的几行）的实现（<br>我想到的一个绝佳的比喻就是IKEA的家具，，，它已经为你实现了绝大多数的工作，却硬是要你去把它自己动手安装成一个能用的家具。然而，尽管只剩下一些最微小的工作，你还是不会组装这些部件。于是，它还提供了一份非常详尽的说明书，真的手把手地教你拼成。就是看说明书、一步步地拼的过程中，竟也理解了这个家具的内部结构。而最后，你得到一个能够使用的家具，还是自己动手做成的，属实很有成就感。  </p><p>回到cs61a的project，这些程序最困难的架构、UI、测试板块都已经完全提供了。另外，还附带说明书一份，整个做project的过程就是看着说明书一步步拼家具的过程。<br>之前总看到有人问：学C/C++这么长时间，为什么都只是“黑框程序”？为什么和看到的软件差别那么大？学这编程到底是做什么的？难道就是解数学题？<br>这些疑问，我肯定大部分按国内“科班编程教育”学下来的都有过。没办法，大一打基础，C++是基本功嘛。我也深知要一上来就搞图形界面显然不现实的。然而，cs61a懂学生的顾虑，在第一时间就传递给学生：编程是魔法，自己动手，什么都能创造。</p><p>不光如此，project还提供给学生<strong>阅读代码</strong>的机会，尤其是<strong>阅读优质代码</strong>的机会。这个就太难得了。据我所知，基础课“程序设计基础”就没有时间深入对代码规范的讲解——确实，比起数据类型、指针，那些“基本功”，代码风格显得不那么重要；而且，对于初学的那些几十行的小程序，也无法让学生理解为什么需要代码的规范；甚至，在上机时，为了高效a题，有种向OI/竞赛码风靠拢的倾向。<br>即使是OI时，阅读代码的唯一机会也就是那初赛码风奇异的阅读程序题……我还记得在我第一次看到DirectX的代码时有多震撼……<br>然而，cs61a的project就提供了这种“大项目”的语境，project提供的代码显然都是非常规范的，不论是命名风格还是写法，注释的量超过了有效代码。学生完成project，在填入代码前，首先要阅读；这样，就已经是“见识过好代码”的人了。</p><p>另外，project的选题也很合学生胃口啊。像讲到OOP时，就出了复刻PVZ的project，游戏物体都是一个基类派生，各种植物就是需要学生完成的各种派生类……现在，回想一下国内教科书的OOP习题……嗯，学生管理系统，，，嗯老师同学都是人，大一大二都是学生，，，   </p><h2 id="二、课程设计"><a href="#二、课程设计" class="headerlink" title="二、课程设计"></a>二、课程设计</h2><p>以下内容均为本人学习该课程后的主观推断（</p><h3 id="为什么选择python"><a href="#为什么选择python" class="headerlink" title="为什么选择python"></a>为什么选择python</h3><p>一个问题就是为什么用python作为教学语言。毕竟，对CS学生来说，一上手就python的话，一些特性可能会养成不好的习惯……（之类的吧）<br>但就这门课来说，选择python十分合理。  </p><p>首先，python是多范式的。上面提到的课程内容中，命令式的、FP、OOP都要学习，所以显然需要选择一门能够覆盖这些范式的语言。另外，python的动态解释特性（个人以为也给课程造成了一些麻烦……）使它对FP的支持比C++好了不少。  </p><p>其次，python是解释执行的，支持交互式编程。为什么这点这么重要？为了课程中最吸引人的一部分：要实现一个scheme解释器。学习python，也就理解了解释的大概过程、什么是REPL。更重要的是，scheme的许多语法与python是一一对应的，这减少了完成解释器很大的一部分工作量。做完解释器，似乎只是完成了parsing，翻译成python的数据，直接就出来了。</p><h3 id="为什么选择scheme"><a href="#为什么选择scheme" class="headerlink" title="为什么选择scheme"></a>为什么选择scheme</h3><p>可能，主要原因是语法结构简单，都是前缀的表达式，便于写解释器……另外，scheme的FP也与之前所学相契合，解释的特性也与python一致，是水到渠成：scheme竟一节课学完就可以无痛感的熟练编程了，可见其课程设计的环环相扣。而，scheme的范式也与python不同，便于将两门语言对比学习。</p><h3 id="为什么内容这么多"><a href="#为什么内容这么多" class="headerlink" title="为什么内容这么多"></a>为什么内容这么多</h3><p>我的解释是目标不一样。以“程序设计基础”为代表的国内“科班编程教育”的入门课，目的就是“打好基本功”，我认为是有道理的。CS学习计算机科学，C++是最好的材料了，正如学习音乐，钢琴是最好的材料一样。但这样“埋头走路”的方式，常常会使一些（估计是大部分）学生晕头转向，不知道在学些什么，有什么意义。就像我的导师所说，他教授的编译原理课程，有很多同学一个学期下来，都不知道学的有什么用处。<br>而同样是作为入门课的SICP，目的却是“抬头看路”。有一说一，这样的高强度“走马观花”下来，“码力”也许确实会欠缺一些，但视野却已经大不一样了：见识到的是计算机程序设计的“蓝图”——编程是什么？程序是什么？什么是编程语言？什么是编程范式？函数式的、面向对象的，命令式的、声明式的，解决什么样的问题？什么是抽象？编程能干什么？以后还要学什么？……<br>这样一来，学习热情就可想而知。</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>这里还不得不提一下我们的老师，冯新宇教授。据他讲也是“临危受命”，作为编程语言方面的专家，来开这门新课。随着课程的推进，就发现和这门课的相性真的很好（逃）。毕竟要把这门内容如此丰富的课程讲明白也非易事，尤其是到编程语言的对比、特性的设计方面，编译过程的解释方面的讲解，都让我大开眼界、受益匪浅。我课下也与老师对于程序语言特性设计方面的疑惑进行了许多探讨，老师的解答都让我醍醐灌顶，使我敬仰万分……在最后一节课，老师还夹带了些“私货”，介绍了了一门更为奇异的coq语言，讲解了证明过程，还介绍了计算机程序的形式验证方法，令我叹为观止……增加了我学习Haskell的动力（？）</p><p>接下来的学习笔记，再整理SICP这门课中学到的mind-blowing的事吧（咕咕咕）。如果有空，可能还有对冯佬Q&amp;A的番外……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大一上学期结束了，给我最大震撼的还是这门SICP课；由于过于震撼，我觉得有必要记录下来。原本打算学期结束后写一系列文章总结一下，不料下学期课业过于刺激，只好草草以一篇“序”结束。不过虽然课程结束了，学习仍要继续，所以学习笔记也会不断延伸（？）&lt;/p&gt;
    
    </summary>
    
      <category term="开发笔记" scheme="https://121.5.103.67/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://121.5.103.67/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【Fr2D开发笔记】四、图形、位图和文本渲染</title>
    <link href="https://121.5.103.67/2019/08/04/%E3%80%90%E6%9D%82%E8%AE%B0%E3%80%91Fr2D%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://121.5.103.67/2019/08/04/【杂记】Fr2D开发笔记（四）/</id>
    <published>2019-08-04T04:02:13.000Z</published>
    <updated>2020-07-02T13:27:02.199Z</updated>
    
    <content type="html"><![CDATA[<p>初始化了Direct2D之后，就可以开始绘制了。</p><a id="more"></a><h1 id="一、几何图元"><a href="#一、几何图元" class="headerlink" title="一、几何图元"></a>一、几何图元</h1><p>如上篇所示，绘制几何图形的方法都在RenderTarget对象中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawLine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    D2D1_POINT_2F point0,</span></span></span><br><span class="line"><span class="function"><span class="params">    D2D1_POINT_2F point1,</span></span></span><br><span class="line"><span class="function"><span class="params">    [in] ID2D1Brush *brush,</span></span></span><br><span class="line"><span class="function"><span class="params">    FLOAT strokeWidth = <span class="number">1.0f</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    [in, optional] ID2D1StrokeStyle *strokeStyle = <span class="literal">NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawRectangle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    [ref] <span class="keyword">const</span> D2D1_RECT_F &amp;rect,</span></span></span><br><span class="line"><span class="function"><span class="params">    [in] ID2D1Brush *brush,</span></span></span><br><span class="line"><span class="function"><span class="params">    FLOAT strokeWidth =<span class="number">1.0f</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    [in, optional] ID2D1StrokeStyle *strokeStyle = <span class="literal">NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawEllipse</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    [ref] <span class="keyword">const</span> D2D1_ELLIPSE &amp;ellipse,</span></span></span><br><span class="line"><span class="function"><span class="params">    [in] ID2D1Brush *brush,</span></span></span><br><span class="line"><span class="function"><span class="params">    FLOAT strokeWidth =<span class="number">1.0f</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    [in, optional] ID2D1StrokeStyle *strokeStyle = <span class="literal">NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>等。</p><p>其中，D2D提供结构体表示对应的图元，可以使用D2D1中的对应函数构造：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2D_RECT_F</span> &#123;</span></span><br><span class="line">    FLOAT left;</span><br><span class="line">    FLOAT top;</span><br><span class="line">    FLOAT right;</span><br><span class="line">    FLOAT bottom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2D1_ELLIPSE</span> &#123;</span></span><br><span class="line">    D2D1_POINT_2F point;</span><br><span class="line">    FLOAT radiusX;</span><br><span class="line">    FLOAT radiusY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">D2D1_RECT_F <span class="title">RectF</span><span class="params">(FLOAT left = <span class="number">0.f</span>, FLOAT top = <span class="number">0.f</span>, FLOAT right = <span class="number">0.f</span>, FLOAT bottom = <span class="number">0.f</span>)</span></span>;</span><br><span class="line"><span class="function">D2D1_ELLIPSE <span class="title">Ellipse</span><span class="params">(<span class="keyword">const</span> D2D1_POINT_2F &amp;center, FLOAT radiusX, FLOAT radiusY)</span></span>;</span><br></pre></td></tr></table></figure><p>如此，可将一些图形的绘制函数封装在Fr2D类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fr2D</span> &#123;</span><span class="comment">//as a d2d render target</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 略</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawLine</span><span class="params">(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> width)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawRectangle</span><span class="params">(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> width)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FillRectangle</span><span class="params">(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DrawEllipse</span><span class="params">(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> width)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FillEllipse</span><span class="params">(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawTriangle</span><span class="params">(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> x1, <span class="keyword">float</span> y1, <span class="keyword">float</span> x2, <span class="keyword">float</span> y2, <span class="keyword">float</span> x3, <span class="keyword">float</span> y3, <span class="keyword">float</span> width)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HWND * hwndptr;</span><br><span class="line">ID2D1Factory * d2dFactory;</span><br><span class="line">ID2D1HwndRenderTarget* hdl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Fr2D::DrawLine(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> width) &#123;</span><br><span class="line">hdl-&gt;DrawLine(D2D1::Point2F(left, top), D2D1::Point2F(right, bottom), fr2dbrush.GetBrush(), width);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Fr2D::DrawRectangle(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> width) &#123;</span><br><span class="line">hdl-&gt;DrawRectangle(</span><br><span class="line">D2D1::RectF(left, top, right, bottom),</span><br><span class="line">fr2dbrush.GetBrush(),</span><br><span class="line">width</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Fr2D::FillRectangle(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom) &#123;</span><br><span class="line">hdl-&gt;FillRectangle(</span><br><span class="line">D2D1::RectF(left, top, right, bottom),</span><br><span class="line">fr2dbrush.GetBrush()</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Fr2D::DrawEllipse(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> width) &#123;</span><br><span class="line">hdl-&gt;DrawEllipse(</span><br><span class="line">D2D1::Ellipse(&#123; (left + right) / <span class="number">2</span>,(top + bottom) / <span class="number">2</span> &#125;, (right - left) / <span class="number">2</span>, (bottom - top) / <span class="number">2</span>),</span><br><span class="line">fr2dbrush.GetBrush(),</span><br><span class="line">width</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Fr2D::FillEllipse(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom) &#123;</span><br><span class="line">hdl-&gt;FillEllipse(</span><br><span class="line">D2D1::Ellipse(&#123; (left + right) / <span class="number">2</span>,(top + bottom) / <span class="number">2</span> &#125;, (right - left) / <span class="number">2</span>, (bottom - top) / <span class="number">2</span>),</span><br><span class="line">fr2dbrush.GetBrush()</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Fr2D::DrawTriangle(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> x1, <span class="keyword">float</span> y1, <span class="keyword">float</span> x2, <span class="keyword">float</span> y2, <span class="keyword">float</span> x3, <span class="keyword">float</span> y3, <span class="keyword">float</span> width) &#123;</span><br><span class="line">hdl-&gt;DrawLine(D2D1::Point2F(x1, y1), D2D1::Point2F(x2, y2), fr2dbrush.GetBrush(), width);</span><br><span class="line">hdl-&gt;DrawLine(D2D1::Point2F(x2, y2), D2D1::Point2F(x3, y3), fr2dbrush.GetBrush(), width);</span><br><span class="line">hdl-&gt;DrawLine(D2D1::Point2F(x3, y3), D2D1::Point2F(x1, y1), fr2dbrush.GetBrush(), width);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即可使用Fr2D对象和Fr2DBrush对象绘制对应图形。</p><h1 id="二、位图"><a href="#二、位图" class="headerlink" title="二、位图"></a>二、位图</h1><p>Direct2D的位图是基于WIC（Windows Image Component）来完成的，是基于COM组件的技术。WIC组件可以支持大部分图像格式的解码。</p><h2 id="创建WIC位图"><a href="#创建WIC位图" class="headerlink" title="创建WIC位图"></a>创建WIC位图</h2><p>将WIC位图的创建封装至FrBitmap类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> FrBitmap::Create() &#123;</span><br><span class="line">    ID2D1Bitmap * pBitmap;</span><br><span class="line">IWICImagingFactory *pIWICFactory;</span><br><span class="line">IWICBitmapDecoder *pDecoder;</span><br><span class="line">IWICBitmapFrameDecode *pSource;</span><br><span class="line">IWICStream *pStream;</span><br><span class="line">IWICFormatConverter *pConverter;</span><br><span class="line">IWICBitmapScaler *pScaler;</span><br><span class="line">    </span><br><span class="line">HRESULT hr = S_OK;</span><br><span class="line">pIWICFactory = <span class="literal">NULL</span>;</span><br><span class="line">pDecoder = <span class="literal">NULL</span>;</span><br><span class="line">pSource = <span class="literal">NULL</span>;</span><br><span class="line">pStream = <span class="literal">NULL</span>;</span><br><span class="line">pConverter = <span class="literal">NULL</span>;</span><br><span class="line">pScaler = <span class="literal">NULL</span>;</span><br><span class="line">hr = CoInitializeEx(<span class="literal">NULL</span>, COINIT_MULTITHREADED);</span><br><span class="line">hr = CoCreateInstance(</span><br><span class="line">CLSID_WICImagingFactory,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">CLSCTX_INPROC_SERVER,</span><br><span class="line">IID_IWICImagingFactory,</span><br><span class="line">(LPVOID*)&amp;pIWICFactory</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">hr = pIWICFactory-&gt;CreateDecoderFromFilename(</span><br><span class="line">picname.c_str(),</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">GENERIC_READ,</span><br><span class="line">WICDecodeMetadataCacheOnLoad,</span><br><span class="line">&amp;pDecoder</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SUCCEEDED(hr))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Create the initial frame.</span></span><br><span class="line">hr = pDecoder-&gt;GetFrame(<span class="number">0</span>, &amp;pSource);</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, _T(<span class="string">"Draw 1failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SUCCEEDED(hr))</span><br><span class="line">&#123;</span><br><span class="line">hr = pIWICFactory-&gt;CreateFormatConverter(&amp;pConverter);</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, _T(<span class="string">"Draw 2failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hr = pConverter-&gt;Initialize(</span><br><span class="line">pSource,</span><br><span class="line">GUID_WICPixelFormat32bppPBGRA,</span><br><span class="line">WICBitmapDitherTypeNone,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="number">0.f</span>,</span><br><span class="line">WICBitmapPaletteTypeMedianCut</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, _T(<span class="string">"Draw 3failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处注意对多线程程序，创建时须使用参数CoInitializeEx(NULL, COINIT_MULTITHREADED);</p><h2 id="Direct2D位图"><a href="#Direct2D位图" class="headerlink" title="Direct2D位图"></a>Direct2D位图</h2><p>TODO：此处的接口设计不科学，后应改成友元类实现。</p><p>创建WIC位图后就可以创建Direct2D位图了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Fr2D::CreateBitmap(FrBitmap &amp;bmp) &#123;</span><br><span class="line">HRESULT hr;</span><br><span class="line">hr = hdl-&gt;CreateBitmapFromWicBitmap(</span><br><span class="line">bmp.GetConverter(),</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">bmp.GetBitmapPtr()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, _T(<span class="string">"Draw 4failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">bmp.Release();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的Release函数是释放使用的COM组件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAFE_RELEASE(P) <span class="meta-keyword">if</span>(P)&#123;P-&gt;Release() ; P = NULL ;&#125;</span></span><br><span class="line"><span class="keyword">void</span> FrBitmap::Release() &#123;</span><br><span class="line">SAFE_RELEASE(pDecoder);</span><br><span class="line">SAFE_RELEASE(pSource);</span><br><span class="line">SAFE_RELEASE(pStream);</span><br><span class="line">SAFE_RELEASE(pConverter);</span><br><span class="line">SAFE_RELEASE(pScaler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绘制位图"><a href="#绘制位图" class="headerlink" title="绘制位图"></a>绘制位图</h2><p>全部创建完毕，就可以绘图了，绘制方法在RenderTarget中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Fr2D::DrawBitmap(FrBitmap &amp;bmp, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom) &#123;</span><br><span class="line">hdl-&gt;DrawBitmap(</span><br><span class="line">bmp.GetBitmap(),</span><br><span class="line">D2D1::RectF(left, top, right, bottom)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、文本"><a href="#三、文本" class="headerlink" title="三、文本"></a>三、文本</h1><p>在Direct2D中，文本的绘制是通过DirectWrite来实现的，需要头文件Dwrite.h和静态库dwrite.lib。</p><h2 id="初始化Dwrite"><a href="#初始化Dwrite" class="headerlink" title="初始化Dwrite"></a>初始化Dwrite</h2><p>Dwrite这块初始化是与Direct2D的Factory类无关的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrText</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Create</span><span class="params">(<span class="keyword">float</span> left = <span class="number">0.f</span>, <span class="keyword">float</span> top = <span class="number">0.f</span>, <span class="keyword">float</span> right = <span class="number">200.f</span>, <span class="keyword">float</span> bottom = <span class="number">200.f</span>)</span></span>;</span><br><span class="line"><span class="function">IDWriteTextFormat* <span class="title">GetFormat</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetRect</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom)</span></span>;</span><br><span class="line"></span><br><span class="line">D2D1_RECT_F layoutRect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">IDWriteFactory * pDWriteFactory;</span><br><span class="line">IDWriteTextFormat* pTextFormat;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> FrText::Create(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom) &#123;</span><br><span class="line">DWriteCreateFactory(</span><br><span class="line">DWRITE_FACTORY_TYPE_SHARED,</span><br><span class="line">__uuidof(IDWriteFactory),</span><br><span class="line"><span class="keyword">reinterpret_cast</span>&lt;IUnknown**&gt;(&amp;pDWriteFactory));</span><br><span class="line"></span><br><span class="line">HRESULT hr = pDWriteFactory-&gt;CreateTextFormat(</span><br><span class="line"><span class="string">L"Arial"</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">DWRITE_FONT_WEIGHT_NORMAL,</span><br><span class="line">DWRITE_FONT_STYLE_NORMAL,</span><br><span class="line">DWRITE_FONT_STRETCH_NORMAL,</span><br><span class="line"><span class="number">20.0f</span> * <span class="number">96.0f</span> / <span class="number">72.0f</span>,</span><br><span class="line"><span class="string">L"en-US"</span>,</span><br><span class="line">&amp;pTextFormat</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">layoutRect = D2D1::RectF(left, top, right, bottom);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IDWriteTextFormat* FrText::GetFormat() &#123;</span><br><span class="line"><span class="keyword">return</span> pTextFormat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FrText::SetRect(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom) &#123;</span><br><span class="line">layoutRect.left = left;</span><br><span class="line">layoutRect.top = top;</span><br><span class="line">layoutRect.right = right;</span><br><span class="line">layoutRect.bottom = bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Fr2D::Write(FrText &amp;frText, Fr2DBrush &amp;fr2dBrush, <span class="built_in">std</span>::<span class="built_in">string</span> s) &#123;</span><br><span class="line">hdl-&gt;DrawText(</span><br><span class="line">stringToLPCWSTR(s),</span><br><span class="line">s.length(),</span><br><span class="line">frText.GetFormat(),</span><br><span class="line">frText.layoutRect,</span><br><span class="line">fr2dBrush.GetBrush()</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初始化了Direct2D之后，就可以开始绘制了。&lt;/p&gt;
    
    </summary>
    
      <category term="开发笔记" scheme="https://121.5.103.67/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Fr2D开发笔记" scheme="https://121.5.103.67/tags/Fr2D%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图形学" scheme="https://121.5.103.67/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="DirectX" scheme="https://121.5.103.67/tags/DirectX/"/>
    
  </entry>
  
  <entry>
    <title>【Fr2D开发笔记】三、Direct2D初始化</title>
    <link href="https://121.5.103.67/2019/08/03/%E3%80%90%E6%9D%82%E8%AE%B0%E3%80%91Fr2D%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://121.5.103.67/2019/08/03/【杂记】Fr2D开发笔记（三）/</id>
    <published>2019-08-03T13:25:21.000Z</published>
    <updated>2020-07-02T10:18:09.611Z</updated>
    
    <content type="html"><![CDATA[<p>创建好一个窗体后，就可以使用Direct2D绘制了。</p><p>Direct2D程序需要包含头文件d2d1.h，和静态库d2d1.lib。这里简单介绍一下Direct2D程序初始化过程。</p><a id="more"></a><h1 id="一、ID2D1Factory"><a href="#一、ID2D1Factory" class="headerlink" title="一、ID2D1Factory"></a>一、ID2D1Factory</h1><p>首先是ID2D1Factory类，是Direct2D其他对象的工厂类，需要首先创建。使用D2D1CreateFactory函数构造，第一个参数是程序线程类型。正常创建返回S_OK，否则返回的HRESULT包含错误信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ID2D1Factory * d2dFactory;</span><br><span class="line">HRESULT hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &amp;d2dFactory);</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">    MessageBox(hwnd, _T(<span class="string">"Create D2D factory failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、RenderTarget"><a href="#二、RenderTarget" class="headerlink" title="二、RenderTarget"></a>二、RenderTarget</h1><p>Direct2D的渲染都在渲染目标（？）对象中进行，创建工厂类对象后就可以使用它创建一个RenderTarget。</p><p>Direct2D提供多种RenderTarget，这里使用窗口句柄渲染目标ID2D1HwndRenderTarget可以实现在目标窗口上的渲染。</p><p>使用ID2D1Factory对象的成员函数CreateHwndRenderTarget构造，第一个参数可以通过D2D1::RenderTargetProperties函数获得，第二个参数通过D2D1::HwndRenderTargetProperties获得，提供窗口句柄和大小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ID2D1HwndRenderTarget* hdl;</span><br><span class="line">RECT rc;</span><br><span class="line">GetClientRect(hwnd, &amp;rc);</span><br><span class="line">HRESULT hr = d2dFactory-&gt;CreateHwndRenderTarget(</span><br><span class="line">    D2D1::RenderTargetProperties(),</span><br><span class="line">    D2D1::HwndRenderTargetProperties(</span><br><span class="line">        hwnd,</span><br><span class="line">        D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top)</span><br><span class="line">    ),</span><br><span class="line">    &amp;hdl</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">    MessageBox(hwnd, _T(<span class="string">"Create render target failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、固体颜色刷"><a href="#三、固体颜色刷" class="headerlink" title="三、固体颜色刷"></a>三、固体颜色刷</h1><p>固体颜色画刷ID2D1SolidColorBrush是由渲染目标对象的成员函数CreateSolidColorBrush创建的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ID2D1SolidColorBrush* brush;</span><br><span class="line">hr = hdl-&gt;CreateSolidColorBrush(</span><br><span class="line">    D2D1::ColorF(D2D1::ColorF::Red),</span><br><span class="line">    &amp;brush</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">MessageBox(hwnd, _T(<span class="string">"Create brush failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、开始画图"><a href="#四、开始画图" class="headerlink" title="四、开始画图"></a>四、开始画图</h1><p>现在，可以开始画图了。</p><p>调用渲染目标对象的成员函数BeginDraw开始绘图，Clear函数用某一颜色清屏；我们使用DrawRectangle函数用笔刷绘制一个矩形，最后调用EndDraw函数结束绘图。Direct2D的屏幕坐标以左上角为原点，x轴向右，y轴向下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hdl-&gt;BeginDraw();</span><br><span class="line">hdl-&gt;Clear(D2D1::ColorF(D2D1::ColorF::White));</span><br><span class="line">hdl-&gt;DrawRectangle(</span><br><span class="line">    D2D1::RectF(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>),</span><br><span class="line">    brush</span><br><span class="line">);</span><br><span class="line">HRESULT hr = hdl-&gt;EndDraw();</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">    MessageBox(<span class="literal">NULL</span>, _T(<span class="string">"Draw failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面展示的就是Direct2D绘图的HelloWorld程序了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"frwnd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"d2d1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (msg) &#123;</span><br><span class="line"><span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">DestroyWindow(hWnd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">PostQuitMessage(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, msg, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HWND hwnd;</span><br><span class="line">ID2D1Factory * d2dFactory;</span><br><span class="line">ID2D1HwndRenderTarget* hdl;</span><br><span class="line">ID2D1SolidColorBrush* brush;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">HRESULT hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &amp;d2dFactory);</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">MessageBox(hwnd, _T(<span class="string">"Create D2D factory failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RECT rc;</span><br><span class="line">GetClientRect(hwnd, &amp;rc);</span><br><span class="line">hr = d2dFactory-&gt;CreateHwndRenderTarget(</span><br><span class="line">D2D1::RenderTargetProperties(),</span><br><span class="line">D2D1::HwndRenderTargetProperties(</span><br><span class="line">hwnd,</span><br><span class="line">D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top)</span><br><span class="line">),</span><br><span class="line">&amp;hdl</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">MessageBox(hwnd, _T(<span class="string">"Create render target failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hr = hdl-&gt;CreateSolidColorBrush(</span><br><span class="line">D2D1::ColorF(D2D1::ColorF::Red),</span><br><span class="line">&amp;brush</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">MessageBox(hwnd, _T(<span class="string">"Create brush failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">hdl-&gt;BeginDraw();</span><br><span class="line">hdl-&gt;Clear(D2D1::ColorF(D2D1::ColorF::White));</span><br><span class="line">hdl-&gt;DrawRectangle(</span><br><span class="line">D2D1::RectF(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>),</span><br><span class="line">brush</span><br><span class="line">);</span><br><span class="line">HRESULT hr = hdl-&gt;EndDraw();</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, _T(<span class="string">"Draw failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FrWnd <span class="title">myWnd</span><span class="params">(<span class="number">640</span>, <span class="number">480</span>, WndProc, Display, <span class="string">"HelloWorld"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(WINPARAMETERS)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!myWnd.Create(INITPARAMETERS))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">hwnd = myWnd.GetHandle();</span><br><span class="line">Init();</span><br><span class="line">myWnd.Run();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画出来了：</p><p><a href="https://www.z4a.net/image/TnRpLI" target="_blank" rel="noopener"><img src="https://www.z4a.net/images/2020/06/28/fr2dhelloworld.png" alt="fr2dhelloworld.png"></a></p><h1 id="五、封装初始化过程"><a href="#五、封装初始化过程" class="headerlink" title="五、封装初始化过程"></a>五、封装初始化过程</h1><p>Fr2D封装Direct2D的初始化过程。将工厂类ID2D1Factory和ID2D1HwndRenderTarget封装到Fr2D类，是Fr2D的工厂类，完成对Fr2D中其他对象的创建；ID2D1SolidColorBrush封装为Fr2DBrush。如此，上面的HelloWorld程序就变成了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"frwnd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"fr2d.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (msg) &#123;</span><br><span class="line"><span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">DestroyWindow(hWnd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">PostQuitMessage(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, msg, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HWND hwnd;</span><br><span class="line"><span class="function">Fr2D <span class="title">fr2d</span><span class="params">(hwnd)</span></span>;</span><br><span class="line">Fr2DBrush redBrush;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">fr2d.Create();</span><br><span class="line">fr2d.CreateBrush(redBrush, _FR2DCOLOR(Red));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">fr2d.BeginDraw();</span><br><span class="line">fr2d.Clear(_FR2DCOLOR(White));</span><br><span class="line">fr2d.DrawRectangle(redBrush, <span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line">fr2d.EndDraw();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FrWnd <span class="title">myWnd</span><span class="params">(<span class="number">640</span>, <span class="number">480</span>, WndProc, Display, <span class="string">"HelloWorld"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(WINPARAMETERS)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!myWnd.Create(INITPARAMETERS))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">hwnd = myWnd.GetHandle();</span><br><span class="line">Init();</span><br><span class="line">myWnd.Run();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;创建好一个窗体后，就可以使用Direct2D绘制了。&lt;/p&gt;
&lt;p&gt;Direct2D程序需要包含头文件d2d1.h，和静态库d2d1.lib。这里简单介绍一下Direct2D程序初始化过程。&lt;/p&gt;
    
    </summary>
    
      <category term="开发笔记" scheme="https://121.5.103.67/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Fr2D开发笔记" scheme="https://121.5.103.67/tags/Fr2D%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图形学" scheme="https://121.5.103.67/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="DirectX" scheme="https://121.5.103.67/tags/DirectX/"/>
    
  </entry>
  
  <entry>
    <title>【Fr2D开发笔记】二、创建Window</title>
    <link href="https://121.5.103.67/2019/08/02/%E3%80%90%E6%9D%82%E8%AE%B0%E3%80%91Fr2D%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://121.5.103.67/2019/08/02/【杂记】Fr2D开发笔记（二）/</id>
    <published>2019-08-02T13:42:33.000Z</published>
    <updated>2020-06-28T12:46:28.589Z</updated>
    
    <content type="html"><![CDATA[<p>在完成上次的Fr2D的控制台版本后，是时候把它变成一个真正的图形库了。控制台绘制显然是不理想的，因此，我选择了Direct2D。  </p><a id="more"></a><h1 id="一、WinAPI"><a href="#一、WinAPI" class="headerlink" title="一、WinAPI"></a>一、WinAPI</h1><p>调用Direct2D的前提是创建一个渲染对象窗体。所以，我们需要先使用WindowsAPI创建一个。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HWND ghMainWnd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitWindowsApp</span><span class="params">(HINSTANCE instanceHandle, <span class="keyword">int</span> show)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR pCmdLine, <span class="keyword">int</span> nShowCmd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!InitWindowsApp(hInstance, nShowCmd))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitWindowsApp</span><span class="params">(HINSTANCE instanceHandle, <span class="keyword">int</span> show)</span> </span>&#123;</span><br><span class="line">    WNDCLASS wc;</span><br><span class="line">    wc.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    wc.lpfnWndProc = WndProc;</span><br><span class="line">    wc.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">    wc.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">    wc.hInstance = instanceHandle;</span><br><span class="line">    wc.hIcon = LoadIcon(<span class="number">0</span>, IDI_APPLICATION);</span><br><span class="line">    wc.hCursor = LoadCursor(<span class="number">0</span>, IDC_ARROW);</span><br><span class="line">    wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);</span><br><span class="line">    wc.lpszMenuName = <span class="number">0</span>;</span><br><span class="line">    wc.lpszClassName = _T(<span class="string">"BasicWndClass"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RegisterClass(&amp;wc)) &#123;</span><br><span class="line">        MessageBox(<span class="number">0</span>, _T(<span class="string">"RegisterClass FAILED"</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ghMainWnd = CreateWindow(</span><br><span class="line">        _T(<span class="string">"BasicWndClass"</span>),</span><br><span class="line">        _T(<span class="string">"Win32Basic"</span>),</span><br><span class="line">        WS_OVERLAPPEDWINDOW,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        instanceHandle,</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ghMainWnd == <span class="number">0</span>) &#123;</span><br><span class="line">        MessageBox(<span class="number">0</span>, _T(<span class="string">"CreateWindow FAILED"</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ShowWindow(ghMainWnd, show);</span><br><span class="line">    UpdateWindow(ghMainWnd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MSG msg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (msg.message != WM_QUIT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PeekMessage(&amp;msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, PM_REMOVE)) &#123;</span><br><span class="line">            TranslateMessage(&amp;msg);</span><br><span class="line">            DispatchMessage(&amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg) &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">        MessageBox(<span class="number">0</span>, _T(<span class="string">"Hello, World"</span>), _T(<span class="string">"Hello"</span>), MB_OK);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">        <span class="keyword">if</span> (wParam == VK_ESCAPE)</span><br><span class="line">            DestroyWindow(ghMainWnd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_KEYUP:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hWnd, msg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是使用WINAPI创建一个窗体的最简代码了，包括注册这个窗体，获取的窗体句柄，消息循环和窗口过程回调函数。其实在vs中创建windows应用的话，vs会直接生成这些代码，但要便于使用于是将其封装。  </p><h1 id="二、FrWnd类"><a href="#二、FrWnd类" class="headerlink" title="二、FrWnd类"></a>二、FrWnd类</h1><p>这里将创建一个窗体个过程粗暴地封装成了FrWnd类，将窗口过程和Display设计成回调函数，Display函数负责写窗体的绘制语句，在注册新窗体时传入即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINPARAMETERS HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR pCmdLine, int nShowCmd</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITPARAMETERS hInstance, nShowCmd</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrWnd</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">FrWnd();</span><br><span class="line">FrWnd(<span class="keyword">int</span> _height, <span class="keyword">int</span> _width, WNDPROC proc, <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>()&gt; callback, LPCSTR _name);</span><br><span class="line"></span><br><span class="line"><span class="function">HWND <span class="title">GetHandle</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Create</span><span class="params">(HINSTANCE instanceHandle, <span class="keyword">int</span> show)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HWND hwnd;</span><br><span class="line">LPCSTR name;</span><br><span class="line"><span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">int</span> width;</span><br><span class="line">WNDPROC proc;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>()&gt; Display;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FrWnd::FrWnd() &#123;</span><br><span class="line">height = <span class="number">800</span>;</span><br><span class="line">width = <span class="number">600</span>;</span><br><span class="line">name = _T(<span class="string">"Test"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FrWnd::FrWnd(<span class="keyword">int</span> _height, <span class="keyword">int</span> _width, WNDPROC _proc, <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>()&gt; callback, LPCSTR _name = _T(<span class="string">"Test"</span>)) &#123;</span><br><span class="line">height = _height;</span><br><span class="line">width = _width;</span><br><span class="line">Display = callback;</span><br><span class="line">name = _name;</span><br><span class="line">proc = _proc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> FrWnd::Create(HINSTANCE instanceHandle, <span class="keyword">int</span> show) &#123;</span><br><span class="line">WNDCLASS wc;</span><br><span class="line">wc.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">wc.lpfnWndProc = proc;</span><br><span class="line">wc.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wc.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">wc.hInstance = instanceHandle;</span><br><span class="line">wc.hIcon = LoadIcon(<span class="number">0</span>, IDI_APPLICATION);</span><br><span class="line">wc.hCursor = LoadCursor(<span class="number">0</span>, IDC_ARROW);</span><br><span class="line">wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);</span><br><span class="line">wc.lpszMenuName = <span class="number">0</span>;</span><br><span class="line">wc.lpszClassName = _T(<span class="string">"BasicWndClass"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!RegisterClass(&amp;wc)) &#123;</span><br><span class="line">MessageBox(<span class="number">0</span>, _T(<span class="string">"RegisterClass FAILED"</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hwnd = CreateWindow(</span><br><span class="line">_T(<span class="string">"BasicWndClass"</span>),</span><br><span class="line">name,</span><br><span class="line">WS_OVERLAPPEDWINDOW,</span><br><span class="line">CW_USEDEFAULT,</span><br><span class="line">CW_USEDEFAULT,</span><br><span class="line">height,</span><br><span class="line">width,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">instanceHandle,</span><br><span class="line"><span class="number">0</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hwnd == <span class="number">0</span>) &#123;</span><br><span class="line">MessageBox(<span class="number">0</span>, _T(<span class="string">"CreateWindow FAILED"</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ShowWindow(hwnd, show);</span><br><span class="line">UpdateWindow(hwnd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> FrWnd::Run() &#123;</span><br><span class="line">MSG msg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (msg.message != WM_QUIT) &#123;</span><br><span class="line"><span class="keyword">if</span> (PeekMessage(&amp;msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, PM_REMOVE)) &#123;</span><br><span class="line">TranslateMessage(&amp;msg);</span><br><span class="line">DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Display();<span class="comment">//此处为回调函数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HWND FrWnd::GetHandle() &#123;</span><br><span class="line"><span class="keyword">return</span> hwnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"frwnd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (msg) &#123;</span><br><span class="line"><span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">DestroyWindow(hWnd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">PostQuitMessage(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, msg, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Display</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function">FrWnd <span class="title">myWnd</span><span class="params">(<span class="number">480</span>, <span class="number">640</span>, WndProc, Display, <span class="string">"test"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(WINPARAMETERS)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!myWnd.Create(INITPARAMETERS))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">myWnd.Run();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，就创建了一个窗体。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在完成上次的Fr2D的控制台版本后，是时候把它变成一个真正的图形库了。控制台绘制显然是不理想的，因此，我选择了Direct2D。  &lt;/p&gt;
    
    </summary>
    
      <category term="开发笔记" scheme="https://121.5.103.67/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Fr2D开发笔记" scheme="https://121.5.103.67/tags/Fr2D%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图形学" scheme="https://121.5.103.67/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="DirectX" scheme="https://121.5.103.67/tags/DirectX/"/>
    
  </entry>
  
  <entry>
    <title>【杂记】博客搭建记</title>
    <link href="https://121.5.103.67/2019/08/02/%E3%80%90%E6%9D%82%E8%AE%B0%E3%80%91%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0/"/>
    <id>https://121.5.103.67/2019/08/02/【杂记】博客搭建记/</id>
    <published>2019-08-02T12:16:41.000Z</published>
    <updated>2019-08-02T13:39:30.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p>地灵殿这个博客是2017-12-26就开始了，因为当时搞OI在洛谷上刷题，旧站使用了洛谷博客。然而用着用着就发现luogu博客如果不动歪脑筋的话就很不自由，许多功能缺失都让人觉得比较难受。尤其是缺少文章归档，随着文章的增多，管理就十分复杂。</p><a id="more"></a><p>之前就一直想自己搭一个博客解决这个问题。于是就去向前段时间买了个nb域名的阿魏请教（本站友链中有他的blog链接(*/ω＼*)），给我介绍了他租服务器、买域名的故事。听完，我就咕了一段时间（等我有钱了我也……）。</p><p>直到又从阿魏得知，有一种使用Hexo+Github的赤贫套餐。嗯，正合我意。于是立即开始了搭建。</p><h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p>好在我使用GitHub，所以git相关的操作已经通了，照着hexo的教程一步步装得很顺利：<br><img src="https://www.z4a.net/images/2019/08/02/QQ20190802204950.jpg" alt="QQ20190802204950.jpg"></p><p>然后就是搭自己的博客了，将主题换成了yilia，简单在配置文件中注册了一下：<br><img src="https://www.z4a.net/images/2019/08/02/QQ20190802205023.jpg" alt="QQ20190802205023.jpg">  </p><h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><p>基本功能完成了，之后就是想办法搞各种花样了</p><ul><li>添加tag、category，实现了功能（归档功能终于实现了） </li><li>实现文章置顶、置顶级别</li><li>左侧四个个人主页/联系方式</li><li>左侧菜单嵌入音乐播放器<br>使用网易云音乐网页版生成的链接，嵌入对应位置即可<br><img src="https://www.z4a.net/images/2019/08/02/QQ20190802205051.jpg" alt="QQ20190802205051.jpg"></li><li>添加访问量统计</li><li>显示文章结构<br><img src="https://www.z4a.net/images/2019/08/02/ESR8BY3ZQTMQAI0W77.png" alt="ESR8BY3ZQTMQAI0W77.png"></li><li>添加左侧菜单栏分类，增加about页面、地灵殿旧址</li><li>添加评论系统功能<br>阿魏给我推荐了valine，然而研究后发现要实名注册，于是立即放弃了（<br>最后使用了gitment，也是github应用，相性好。<br>可以用npm，安装同样简单，然而遇到了些问题，无法评论。原来是gitment那人的服务器到期了，网上找了个，解决了。<br><img src="https://www.z4a.net/images/2019/08/02/QQ20190802211805.png" alt="QQ20190802211805.png"></li><li>修改背景色</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一&quot;&gt;&lt;a href=&quot;#一&quot; class=&quot;headerlink&quot; title=&quot;一&quot;&gt;&lt;/a&gt;一&lt;/h1&gt;&lt;p&gt;地灵殿这个博客是2017-12-26就开始了，因为当时搞OI在洛谷上刷题，旧站使用了洛谷博客。然而用着用着就发现luogu博客如果不动歪脑筋的话就很不自由，许多功能缺失都让人觉得比较难受。尤其是缺少文章归档，随着文章的增多，管理就十分复杂。&lt;/p&gt;
    
    </summary>
    
      <category term="开发笔记" scheme="https://121.5.103.67/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://121.5.103.67/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>这是好的</title>
    <link href="https://121.5.103.67/2019/08/01/%E8%BF%99%E6%98%AF%E5%A5%BD%E7%9A%84/"/>
    <id>https://121.5.103.67/2019/08/01/这是好的/</id>
    <published>2019-08-01T09:51:14.000Z</published>
    <updated>2019-08-01T12:50:45.584Z</updated>
    
    <content type="html"><![CDATA[<p>本站总访问量<span id="busuanzi_value_site_pv"></span>次<br>本站访客数<span id="busuanzi_value_site_uv"></span>人次</p><h1 id="好了"><a href="#好了" class="headerlink" title="好了"></a>好了</h1><p><em>还有什么人</em><br><strong>要提问？</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;br&gt;本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/p&gt;
&lt;h1 id=&quot;好了&quot;&gt;&lt;a href=&quot;#好了&quot; class=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【小课堂】八、算法初步</title>
    <link href="https://121.5.103.67/2019/07/24/%E3%80%90%E5%B0%8F%E8%AF%BE%E5%A0%82%E3%80%91%E5%85%AB%E3%80%81%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5/"/>
    <id>https://121.5.103.67/2019/07/24/【小课堂】八、算法初步/</id>
    <published>2019-07-24T08:52:25.000Z</published>
    <updated>2019-08-05T09:00:02.722Z</updated>
    
    <content type="html"><![CDATA[<p>至此，小课堂基础篇的语法部分就告一段落了，我们已经学习了最常用的C/C++语言语法；从哲学的角度说，现在我们已经可以使用C/C++语言的这些语句实现计算机能做的一切功能了。然而在现实的编程操作过程中却并不这么理想，好像经常会出现有一个需求却不知道如何实现的情况（如果你在之前的课程中打星号的习题上遇到过困难的话）；这就是我们学习<strong>算法</strong>的目的。<br>在这一节，我们将了解什么是算法，了解一些常用的基础算法以及实现，并初步学习计算<strong>算法复杂度</strong>的方法。  </p><a id="more"></a><h1 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h1><p>算法就是解决问题的一系列流程。<br>算法的概念始终伴随着我们的数学学习过程（只是时不时地被淡化了），现在回忆小时候学用竖式计算多位数加法的过程：从低位开始，按位相加，超过10了要进位，进位要参与下一位的运算中，直到算到某数到头了，另一个数剩余部分抄下来，算法结束。<br>这个看似简单的算法，却有着大用处——这就是<strong>高精度计算</strong>。<br>请看下例：<br><strong>例8.1</strong><br> <em>输入两个正整数a,b（a,b&lt;$10^{500}$），输出a+b的值</em>   </p><p>我们发现，在C/C++语言中数的大小受到限制，而假如我们要用C/C++语言进行上百甚至上千位的计算，使用内置的int（long long也不行）就无能为力了。而此时，使用竖式加法的算法就能解决这个问题：  </p><ul><li>使用字符串读取两个大整数  </li><li>使用竖式加法算法进行计算，结果储存在另一个字符串中   </li><li>输出结果字符串  </li></ul><p>于是，我们就可以这么写：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高精度加法算法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">1000</span>],s2[<span class="number">1000</span>],ans[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s1[<span class="number">0</span>]==<span class="string">'0'</span>&amp;&amp;s2[<span class="number">0</span>]==<span class="string">'0'</span>)&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(ans,<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> al=<span class="built_in">strlen</span>(s1),bl=<span class="built_in">strlen</span>(s2);</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;,b[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;,c[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i,j,jw=<span class="number">0</span>,t1,t2=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;al;i++)</span><br><span class="line">        a[i]=s1[al<span class="number">-1</span>-i]-<span class="string">'0'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;bl;i++)</span><br><span class="line">        b[i]=s2[bl<span class="number">-1</span>-i]-<span class="string">'0'</span>;</span><br><span class="line">    </span><br><span class="line">    t1=max(al,bl);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;t1;i++)&#123;</span><br><span class="line">        c[i]=a[i]+b[i]+jw;</span><br><span class="line">        jw=c[i]/<span class="number">10</span>;</span><br><span class="line">        c[i]%=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    c[i]=jw;</span><br><span class="line">    <span class="keyword">while</span>(c[i]==<span class="number">0</span>)i--;</span><br><span class="line">    <span class="keyword">for</span>(;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        ans[t2]=c[i]+<span class="string">'0'</span>;</span><br><span class="line">        t2++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[t2]=<span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,s1,s2);</span><br><span class="line">    add();</span><br><span class="line">    <span class="built_in">puts</span>(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>在设计出一个好的算法之前，首先要思考如何评判一个好的算法。在使用计算机的过程中，我们知道完成一个相同的任务，如果一个软件占用更小的内存，需要更少的运行时间（意味着更流畅的用户体验），那么它是更优的。这里引入<strong>空间复杂度</strong>和<strong>时间复杂度</strong>的概念。<br>由于复杂度的概念有确切的数学定义，对于给定算法也有严格的复杂度计算、证明方法；这里只是做初步介绍。<br>这里的<strong>空间</strong>就是内存空间的占用，而<strong>时间</strong>则是运算量对运行时间的占用。然而要注意，所谓<strong>复杂度</strong>并非指程序一次运行过程中占用空间或时间的多少，而是<strong>空间</strong>、<strong>时间</strong>的占用随<strong>输入规模</strong>的<strong>变化快慢</strong>。<br>如何计算时间复杂度？<br>我们可以将程序的语句执行次数可以用一个<strong>与输入有关的</strong>代数式表示，取这个代数式的最高次项且忽略此项系数作为时间复杂度。<br>例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>程序A中的cout语句执行了$5$次，与输入无关，为一个常数（也可以说最高次项是零次项），我们称这段程序的时间复杂度为$O(1)$，<strong>常数时间复杂度</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>程序B中的cin语句执行了1次，cout语句执行了$n$次，与输入n有关，运算次数是$n+1$（最高次项是n的一次项），我们称这段程序的时间复杂度为$O(n)$，<strong>线性级时间复杂度</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;j&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>程序C中的cin语句执行了1次，第一个循环cout语句执行了 $ 2*n*n $ 次，第二个循环cout语句执行了 $n$ 次，运算次数是$2n^2+n+1$（最高次项是n的二次项），我们称这段程序的时间复杂度为 $O(n^2)$ ，<strong>平方级时间复杂度</strong>。</p><p>如此定义时间复杂度的原因是：许多算法往往在输入较小的情况下都差不多（都是瞬间解决），而随着输入增大，运算需要的时间也会增加，但此时不同复杂度的算法增长快慢也不同。一个好的算法在数据量很大的情况下依然有好的表现。<br><img src="https://www.z4a.net/images/2019/08/02/740a41ac12dba81c1c5bc9bef895102a.png" alt="740a41ac12dba81c1c5bc9bef895102a.png"><br>图8.1，摘自《数据结构与算法分析：C语言描述》<br>下面将以排序算法为例体验不同算法复杂度的不同，并介绍算法复杂度计算方法。</p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>在之前学习分支、循环、数组的时候，都做过关于排序的题；而在高一信息课上也曾学过<strong>冒泡排序</strong>算法。原因一是因为它是个很好的例子；二是排序确实是个重要的算法——试想如果一本词典不按字典序，而是随机编写，那么我们每次查询都要从头翻起。排序是快速查找的基础。  </p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>那么如何得到一个有序的序列（排序）呢？比如，给定一个长度为n的数组，要求从小到大排序。我们先想简单一些：我们先找最小的，放第一个；然后找第二小的，放第二个……这样找n次，就得到了一个从小到大的序列：   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1000</span>],b[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">bool</span> visited[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;;     <span class="comment">//标记是否取过</span></span><br><span class="line">    <span class="keyword">int</span> m,position;             <span class="comment">//记录最小值</span></span><br><span class="line">    <span class="keyword">int</span> infinity=<span class="number">2147483647</span>;    <span class="comment">//这是最大的可能值（int类型的上限）</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;      <span class="comment">//找n遍</span></span><br><span class="line">        m=infinity;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)   <span class="comment">//从头找到尾</span></span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;m &amp;&amp; !visited[j])&#123;<span class="comment">//a[j]如果比当下的最小值还小，且没取过</span></span><br><span class="line">                m=a[j];         <span class="comment">//新的最小值</span></span><br><span class="line">                position=j;     <span class="comment">//记录位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        b[i]=m;                 <span class="comment">//放入第i个最小值 </span></span><br><span class="line">        visited[position]=<span class="number">1</span>;    <span class="comment">//标记 </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,b[i]); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>花了些工夫，也实现了这个功能，看上去就很复杂——看来想起来简单的算法未必是最好的。了解了复杂度的概念后，我们可以从时间复杂度和空间复杂度两个角度评判这个算法，再想办法加以改进。  </p><ul><li>时间复杂度：<br>不计输入输出，排序部分循环执行$n*n$次，时间复杂度为$O(n^2)$  </li><li>空间复杂度：<br>不计原始数组，排序部分共使用了一个长度为n的整型数组b，和长度为n的布尔型数组visited，空间复杂度为$O(n)$   </li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>如果我们从空间方面考虑优化，就会发现找到最小值之后不一定要放在另一个数组b中，而可以直接在原数组a中改变顺序：找到最小值后与原a[1]交换，找到第二小值后与原a[2]交换……最终有序序列存放在a中，上面的b数组和visited数组就节省掉了。<br>于是我们得到了以下经过优化的代码：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> m,position,t;             <span class="comment">//记录最小值</span></span><br><span class="line">    <span class="keyword">int</span> infinity=<span class="number">2147483647</span>;    <span class="comment">//这是最大的可能值（int类型的上限）</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;      <span class="comment">//找n遍</span></span><br><span class="line">        m=infinity;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)   <span class="comment">//在剩余的元素中找 </span></span><br><span class="line">            <span class="keyword">if</span>(m&gt;a[j])&#123;</span><br><span class="line">                m=a[j];</span><br><span class="line">                position=j;</span><br><span class="line">            &#125;</span><br><span class="line">        t=a[i];                 <span class="comment">//放入a[i]的位置（交换） </span></span><br><span class="line">        a[i]=a[position];</span><br><span class="line">        a[position]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：<br>不计输入输出，排序部分循环执行 $\frac{1}{2}*n*n$ 次，时间复杂度仍为$O(n^2)$（常数比之前的稍小，但仍是同一级别）  </li><li>空间复杂度：<br>不计原始数组，排序部分只使用了几个临时变量，空间复杂度为常数$O(1)$     </li></ul><p>经过上述优化的这种排序算法学名为<strong>选择排序</strong>。正如上面分析的，选择排序的时间复杂度为$O(n^2)$，空间复杂度为$O(1)$。  </p><h2 id="更进一步的优化"><a href="#更进一步的优化" class="headerlink" title="*更进一步的优化"></a>*更进一步的优化</h2><p>上述选择排序的时间复杂度$O(n^2)$仍然可以进一步优化：内层循环$O(n)$的寻找最小值操作可以借助一种叫<strong>堆</strong>的<strong>数据结构</strong>将复杂度降低至$O(logn)$，从而使整体复杂度降为$O(nlogn)$。这种排序算法名为<strong>堆排序</strong>，然而由于涉及数据结构的知识，这里不详细介绍，如感兴趣可自行搜索。  </p><p>这里介绍一种时间复杂度同样是$O(nlogn)$的算法，<strong>归并排序</strong>。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="*归并排序"></a>*归并排序</h2><p>我们先引入一种将两个有序序列合并成一个有序序列的算法：<strong>二路归并</strong>。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;        <span class="comment">//有序数组a，共6个元素 </span></span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">13</span>&#125;;    <span class="comment">//有序数组b ，共7个元素 </span></span><br><span class="line">    <span class="keyword">int</span> t[<span class="number">20</span>];                      <span class="comment">//合并的新数组 </span></span><br><span class="line">    <span class="keyword">int</span> pa=<span class="number">0</span>,pb=<span class="number">0</span>,k=<span class="number">0</span>;              <span class="comment">//a,b,t数组的当前位置，初始为0 </span></span><br><span class="line">    <span class="keyword">while</span>(pa&lt;<span class="number">6</span> &amp;&amp; pb&lt;<span class="number">7</span>)             <span class="comment">//a,b数组都没到末尾，则循环 </span></span><br><span class="line">        <span class="keyword">if</span>(a[pa]&lt;b[pb])&#123;            <span class="comment">//如果当前是a的元素小</span></span><br><span class="line">            t[k]=a[pa];             <span class="comment">//则t中放入a的当前元素 </span></span><br><span class="line">            pa++;                   <span class="comment">//指向a的下一个元素 </span></span><br><span class="line">            k++;                    <span class="comment">//指向t的下一个空位 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;                       <span class="comment">//否则是b的元素小 </span></span><br><span class="line">            t[k]=b[pb];</span><br><span class="line">            pb++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span>(pa&lt;<span class="number">6</span>)&#123;                    <span class="comment">//如果a数组还没到末尾 </span></span><br><span class="line">        t[k]=a[pa];                 <span class="comment">//将a的元素接在t数组末尾 </span></span><br><span class="line">        pa++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pb&lt;<span class="number">7</span>)&#123;                    <span class="comment">//否则将b数组接在t的末尾 </span></span><br><span class="line">        t[k]=b[pb];                 <span class="comment">//注意这两个循环不会都执行 </span></span><br><span class="line">        pb++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">13</span>;i++)           <span class="comment">//输出结果：1 2 2 3 5 6 6 7 7 8 9 12 13 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,t[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法总共只将a,b两个数组从头扫描至末尾，如果两个序列长度分别为$m,n$，则二路归并的时间复杂度为$O(m+n)$  </p><p>归并排序就是借助二路归并和递归思想实现的排序算法：<br>先将排序序列平分成左右两个部分：</p><ul><li>如果排序的序列的两个部分都是有序序列，那么我们可以用二路归并排成有序，排序完成。  </li><li>如果排序的序列左右两个部分不是有序序列，那么就继续平分成两个部分进行归并排序（递归）  </li><li>如果分割到只剩一个元素了，那左右两部分就一定是有序的，直接归并（递归的基本条件）  </li></ul><p><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=236fa62859b5c9ea76fe0bb1b450dd65/c8177f3e6709c93d673b9ed49d3df8dcd00054c3.jpg" alt><br>于是，归并排序就可以这样实现：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>],t[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;    <span class="comment">//两个参数分别为排序的左右边界</span></span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;             <span class="comment">//区间只有一个元素 </span></span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;            <span class="comment">//中间位置下标 </span></span><br><span class="line">    mergesort(l,mid);           <span class="comment">//递归排序左半边 </span></span><br><span class="line">    mergesort(mid+<span class="number">1</span>,r);         <span class="comment">//递归排序右半边 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=l,j=mid+<span class="number">1</span>,k=l;        <span class="comment">//递归结束，此时左右两序列已经有序 </span></span><br><span class="line">                                <span class="comment">//下面将两部分进行二路归并 </span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[j])&#123;</span><br><span class="line">            t[k]=a[i];i++;k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            t[k]=a[j];j++;k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">        t[k]=a[i];k++;i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r)&#123;</span><br><span class="line">        t[k]=a[j];k++;j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=l;i&lt;=r;i++)</span><br><span class="line">        a[i]=t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]); </span><br><span class="line">    </span><br><span class="line">    mergesort(<span class="number">1</span>,n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个长度为$n$的数组，每次二分区间直到单元素，一共是$logn$次（在信息学中，$log$默认的底数为2）；而上面分析二路归并的复杂度为$O(n)$级，因此，归并排序的时间复杂度为$O(nlogn)$，是一种高效的排序算法。<br>从归并排序一例中，我们也认识到递归的真正威力。  </p><h1 id="搜索算法初步"><a href="#搜索算法初步" class="headerlink" title="*搜索算法初步"></a>*搜索算法初步</h1><p>计算机的最大优势就是快速的运算能力，我们可以利用这点进行人工无法实现的大量重复劳动。然而要达到这一要求也需要算法的支持，这就是<strong>搜索算法</strong>。  </p><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p><strong>例8.2</strong><br><em>有A~E五人，和1~5五本书，每个人对每本书各有喜好（如下表所示），找出所有让每个人满意的发书方案</em><br><img src="https://www.z4a.net/images/2019/08/02/82.png" alt="82.png"><br>这题的思路很简单，把所有发书情况（$P^5_5$）全部枚举，判断是否符合要求，输出符合要求的方法。然而，怎么让计算机枚举这些情况呢？<br>我们首先使用一个二维数组like表示上面的表格，like[i][j]就表示第i个人是否喜欢第j本书（下标从1开始）：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> like[<span class="number">10</span>][<span class="number">10</span>]=&#123; &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>然后就是枚举了。这里引入<strong>深度优先搜索</strong>（<strong>dfs</strong>）算法解决这一问题。<br>我们先定义数组a，a[i]表示第i个人发到的书的编号，如a[2]=5表示第二个人发到第五本书。然后我们就可以试着按照要求填写这一数组，当a[1]到a[5]全部填满时就是满足条件的一组解了。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];<span class="comment">//记录结果</span></span><br><span class="line"><span class="keyword">bool</span> b[<span class="number">10</span>];<span class="comment">//记录书的发放情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="comment">//参数表示当前发到第i个人</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">5</span>;j++)<span class="comment">//枚举五本书</span></span><br><span class="line">        <span class="keyword">if</span>(!b[j]&amp;&amp;like[i][j])&#123;<span class="comment">//如果第j本书没有发放，并且第i人喜欢第j本书</span></span><br><span class="line">            a[i]=j;<span class="comment">//发书：将第i个人的书标记为第j本</span></span><br><span class="line">            b[j]=<span class="number">1</span>;<span class="comment">//标记第j本书已经发出</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">5</span>)write();<span class="comment">//如果到了第五个人，说明五本书都已经成功发放，就输出</span></span><br><span class="line">            <span class="keyword">else</span> book(i+<span class="number">1</span>);<span class="comment">//发下一个人的书</span></span><br><span class="line">            b[j]=<span class="number">0</span>;<span class="comment">//此时在i发第j本情况下，第i+1个人的情况已枚举完毕，于是解除第j本的标记，准备开始发第j+1本</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在请用纸笔模拟一遍上述代码的运行过程和输出。  </p><p>我们可以发现，深度优先搜索的过程就是利用了搜索时每一个阶段的相似性进行递归求解；而求解过程符合思考时的逻辑，先 <em>深度优先</em> 地寻找到一组解，找完一组解后当前递归的结束，回退以寻找下一组解，这样可以很好的检验每一组解，保证解的正确性；最后的运行次数也就是本题的枚举次数：$5!$次，保证不重不漏。</p><p>由此我们可以得到深度优先搜索的一般形式：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=maxj;j++)</span><br><span class="line">        <span class="keyword">if</span>(新节点符合条件)&#123;</span><br><span class="line">            记录新节点;</span><br><span class="line">            <span class="keyword">if</span>(到目标节点)输出;</span><br><span class="line">            <span class="keyword">else</span> dfs(i+<span class="number">1</span>);</span><br><span class="line">            删除节点;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中记录节点与删除节点的语句应为逆运算关系，保证回到原先状态，进行下一次搜索。<br>需要注意的是，深度优先搜索算法的时间复杂度是指数级的，取决于你需要枚举的种类数，可以发现上例中五个人五本书$n=5$如果换成$n=100$，枚举种数将是天文数字，也就不能使用搜索算法求解了。</p><p>搜索算法补充阅读（友情链接）：<a href="https://blog.csdn.net/qq_40892508/article/details/91420286" target="_blank" rel="noopener">比较深奥</a></p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>1、什么是算法？为什么要学习算法？算法和代码的关系是什么？<br>2、什么是算法复杂度？如何计算时间/空间复杂度？复杂度这一概念有什么作用？<br>3、既然排序算法的功能都完全一致，为什么还要发明那么多种不同的排序算法？  </p><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p>1、 输入两个正整数a,b（a,b&lt;$10^{500}$），输出a-b的值，并分析你的算法的复杂度<br>*2、  输入两个正整数a,b（a,b&lt;$10^{500}$），输出a*b的值，并分析你的算法的复杂度<br>**3、快速排序是也是一种高效的排序算法。与归并排序类似，快速排序算法也是使用了分治和递归的思想，其中一种描述如下：  </p><ul><li>取序列的正中间元素作为标准，将序列分成两部分，将比标准小的元素放在标准左边，大的元素放在右边  </li><li>对左右两部分也分别进行快速排序（递归）</li><li>直到分割成单元素（递归的基本条件）  </li></ul><p><a href="https://www.bilibili.com/video/av10076626?from=search&seid=2450896441342489123" target="_blank" rel="noopener">也可以看看这个视频帮助理解</a><br>请按照描述（可仿照归并排序）实现快速排序算法，并分析其复杂度<br>**4、八皇后问题为：国际象棋棋盘上放置8个互相不能攻击到的皇后的摆法有多少种？（国际象棋棋盘为8*8，皇后可以攻击到同行、列与两条对角线的棋子），使用<strong>深度优先搜索</strong>算法求解八皇后问题   </p><p>提示：可以使用以下方法传递数组为函数的参数，<strong>不同于普通参数的传值，数组作为参数传递的是数组自身。这意味着函数中对传入的数组进行操作将改变这个数组</strong>  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArrayProcedure</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        t[i]=i;</span><br><span class="line">    </span><br><span class="line">    ArrayProcedure(t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;t[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br>10<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;至此，小课堂基础篇的语法部分就告一段落了，我们已经学习了最常用的C/C++语言语法；从哲学的角度说，现在我们已经可以使用C/C++语言的这些语句实现计算机能做的一切功能了。然而在现实的编程操作过程中却并不这么理想，好像经常会出现有一个需求却不知道如何实现的情况（如果你在之前的课程中打星号的习题上遇到过困难的话）；这就是我们学习&lt;strong&gt;算法&lt;/strong&gt;的目的。&lt;br&gt;在这一节，我们将了解什么是算法，了解一些常用的基础算法以及实现，并初步学习计算&lt;strong&gt;算法复杂度&lt;/strong&gt;的方法。  &lt;/p&gt;
    
    </summary>
    
      <category term="小课堂" scheme="https://121.5.103.67/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="教程" scheme="https://121.5.103.67/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="C++" scheme="https://121.5.103.67/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【小课堂】七、文件</title>
    <link href="https://121.5.103.67/2019/07/23/%E3%80%90%E5%B0%8F%E8%AF%BE%E5%A0%82%E3%80%91%E4%B8%83%E3%80%81%E6%96%87%E4%BB%B6/"/>
    <id>https://121.5.103.67/2019/07/23/【小课堂】七、文件/</id>
    <published>2019-07-23T02:54:52.000Z</published>
    <updated>2019-08-01T16:24:32.866Z</updated>
    
    <content type="html"><![CDATA[<p>使用控制台输入会对我们输入量个大小产生限制，也不利于输出数据的永久保存。因此，我们时常使用程序进行<strong>文件操作</strong>解决这一问题。   </p><a id="more"></a><h1 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h1><p>我们首先需要头文件stdio.h（C++则是cstdio）<br>在还未学习指针时，我们可以先将文件指针理解为操作文件的一种特殊的数据类型。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *myFileIn, *myFileOut;</span><br></pre></td></tr></table></figure><p>如此便声明了两个文件指针变量myFileIn和myFileOut，然后我们需要使用fopen函数，将它们指向硬盘中的真实的文件，以实现对文件的操作：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE* <span class="title">fopen</span><span class="params">(文件名,操作类型)</span></span>;</span><br></pre></td></tr></table></figure><p>如：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myFileIn = fopen(<span class="string">"testIn.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line">myFileOut = fopen(<span class="string">"testOut.txt"</span>,<span class="string">"w"</span>);</span><br></pre></td></tr></table></figure><p>我们让myFileIn指向与程序同目录的testIn.txt文件，并注册为只读”r”;让myFileOut指向与程序同目录的testOut.txt文件，并注册为只写”w”。操作类型为写入，而路径下还没有此文件，程序就会创建这个文件；而如果此文件已经存在，程序则会<strong>覆盖</strong>它。<br>fopen还有其他的操作类型，用于不同的文件使用场合，这里不作介绍，可自行查询。  </p><p>这样就完成了文件指针的初始化，在程序的编写中，我们就可以通过myFileIn使用硬盘中的testIn.txt文件，我们称此文件指针为一个<strong>文件句柄</strong>（<strong>file handle</strong>）。  </p><h1 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h1><p>有了文件句柄，就可以使用文件进行输入输出了：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">fscanf</span>(myFileIn,<span class="string">"%d"</span>,&amp;a);</span><br><span class="line"><span class="built_in">fprintf</span>(myFileOut,<span class="string">"%d\n"</span>,a+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>先在同目录下创建一个文件testIn.txt，输入一个数，然后运行程序。我们发现目录下生成了一个文件testOut.txt，输出了这个数加一。  </p><p>fscanf、fprintf函数与scanf、printf函数类似，唯一的区别就是需要一个提供操作的文件句柄。  </p><h1 id="文件的结束（EOF）"><a href="#文件的结束（EOF）" class="headerlink" title="文件的结束（EOF）"></a>文件的结束（EOF）</h1><p>fscanf函数还可以返回文件的结束信息（End Of File，<strong>EOF</strong>），在读完文件时给予反馈：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>],i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>( <span class="built_in">fscanf</span>(myFileIn,<span class="string">"%d"</span>,&amp;a)!=EOF )i++;</span><br></pre></td></tr></table></figure><p>即可实现读取直到读完文件停止。</p><h1 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h1><p>文件使用完毕后，需要使用fclose函数关闭文件，解除此程序对文件的占用。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fclose(myFileIn);</span><br><span class="line">fclose(myFileOut);</span><br></pre></td></tr></table></figure><p>以上是对于文本文件（ascii）的基本操作，C/C++语言还提供更多丰富的文件操作，如对于二进制文件的fread/fwrite，涉及一些文件编码知识，可自行探索。  </p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>1、我们为什么要引进文件操作？<br>2、什么是文件句柄？使用文件为什么要引入文件句柄？  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用控制台输入会对我们输入量个大小产生限制，也不利于输出数据的永久保存。因此，我们时常使用程序进行&lt;strong&gt;文件操作&lt;/strong&gt;解决这一问题。   &lt;/p&gt;
    
    </summary>
    
      <category term="小课堂" scheme="https://121.5.103.67/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="教程" scheme="https://121.5.103.67/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="C++" scheme="https://121.5.103.67/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【小课堂】六、字符串</title>
    <link href="https://121.5.103.67/2019/07/17/%E3%80%90%E5%B0%8F%E8%AF%BE%E5%A0%82%E3%80%91%E5%85%AD%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://121.5.103.67/2019/07/17/【小课堂】六、字符串/</id>
    <published>2019-07-17T04:31:46.000Z</published>
    <updated>2019-08-03T16:25:08.949Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常需要使用计算机处理大量的字符，因而C/C++引入<strong>字符串</strong>(string)以支持对大量字符操作。<br>其中，C++语言提供了<strong>C风格字符串</strong>和<strong>C++风格字符串</strong>（STL）两种选择：C风格的字符串操作与C语言完全一致，而C++风格的字符串则以面向对象的范式支持了更多操作。  </p><a id="more"></a><h1 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h1><p>C/C++中的字符串常量就是以英文双引号括起来的一段字符：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello,world"</span></span><br></pre></td></tr></table></figure><p>像scanf，printf函数，传的参数也就是字符串常量。</p><h1 id="C风格的字符串"><a href="#C风格的字符串" class="headerlink" title="C风格的字符串"></a>C风格的字符串</h1><p>在C语言中，字符串就是一种特殊的<strong>字符型数组</strong>，唯一与普通字符型数组不同的是，字符串以一个特殊字符’\0’（ASCII码也为0）结尾。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;<span class="comment">//这是一个字符型数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> b[<span class="number">100</span>]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'\0'</span>&#125;;<span class="comment">//这是一个C风格字符串</span></span><br></pre></td></tr></table></figure><p>由于数组初始化时会将未赋值的空间赋为0，因此字符数组a也可以看做一个字符串，而b[3]==’\0’就是一个字符串。但为了区分，我们有必要在字符串结尾加一个’\0’做标志。   </p><h2 id="C风格输入输出"><a href="#C风格输入输出" class="headerlink" title="C风格输入输出"></a>C风格输入输出</h2><p>引入字符串概念后，就可以对字符进行整体的输入输出操作了。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,s);</span><br></pre></td></tr></table></figure><p>输入：<br>abc<br>输出：<br>abc<br>使用scanf将字符串”abc”整体读入字符串s，并使用printf进行整体的输出。  </p><p>这里有个重要的细节：用scanf输入变量时，需要使用取地址运算符&amp;进行操作，而输入字符串时则不加，这一差异需要用心记忆。（原因则较为复杂不必深究，与数组类型的本质有关。数组名实际上是指向首元素的一个特殊指针，因而字符串传入时相当于直接传入了地址。）  </p><h2 id="C风格字符串的操作"><a href="#C风格字符串的操作" class="headerlink" title="C风格字符串的操作"></a>C风格字符串的操作</h2><p>另外，C语言还提供了更多现成的字符串操作（即定义了许多现成的字符串函数），都在头文件string.h中；如果使用C++，头文件则是cstring，里面的内容是完全一样的。这里只是简单介绍常用的一些操作，更多操作如有需要可以自行查询。  </p><h3 id="gets、puts"><a href="#gets、puts" class="headerlink" title="gets、puts"></a>gets、puts</h3><p>与scanf，printf类似，是字符串的输入输出函数。只是scanf读取字符串和其他数据一样，遇到空白符号即停止（空格、回车），而gets允许读取代空格的字符串：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：<br>abc def<br>输出：<br>abc  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    gets(a);</span><br><span class="line">    <span class="built_in">puts</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：<br>abc def<br>输出：<br>abc def  </p><h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3><p>和数组一样，C风格的字符串不允许直接赋值为一个字符串常量：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//禁止： s="hello";</span></span><br></pre></td></tr></table></figure><p>要赋值一个字符串，需要使用函数strcpy（string copy）：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s1,<span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">puts</span>(s1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s2[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s2,s1);</span><br><span class="line"><span class="built_in">puts</span>(s2);</span><br></pre></td></tr></table></figure><p>输出：<br>hello<br>hello  </p><h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h3><p>用于比较两个字符串的大小（也就是<strong>字典序</strong>，就是英文字典中单词的排序方式）。<br>strcmp(s1,s2)：如果s1&gt;s2返回正整数，s1=s2返回0，s1&lt;s2返回负整数：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">20</span>],s2[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s1,<span class="string">"apple"</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(s2,<span class="string">"application"</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(s1,s2)&gt;<span class="number">0</span>) <span class="built_in">puts</span>(s1);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(s2);</span><br></pre></td></tr></table></figure><p>输出：<br>application  </p><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><p>返回一个字符串的长度（字符数，’\0’不计在内）：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">strlen</span>(<span class="string">"apple"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s,<span class="string">"ball"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">strlen</span>(s));</span><br></pre></td></tr></table></figure><p>输出：<br>5<br>4  </p><h3 id="字符串的一般操作"><a href="#字符串的一般操作" class="headerlink" title="字符串的一般操作"></a>字符串的一般操作</h3><p>和数组一样，我们也可以使用下标访问、操作字符串的每一个字符：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line"><span class="keyword">int</span> length=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    s[i]++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,s);</span><br></pre></td></tr></table></figure><p>输入：<br>abcde<br>输出：<br>bcdef  </p><p>我们发现，字符串中的每一个字符，都通过访问下标的方式加一，最后整体输出。</p><h3 id="其它字符串函数"><a href="#其它字符串函数" class="headerlink" title="其它字符串函数"></a>其它字符串函数</h3><p>以上列出的是最常用的一些字符串函数，而string.h（C++中cstring）还提供更多字符串函数供使用。这里不作要求，只是简单列出，如在编写过程中有需要可以自行查询。  </p><ul><li>strcat(s1,s2):将参数s2字符串拷贝到参数s1字符串尾   </li><li>strlwr(s):将字符串中的大写字母转化为小写</li><li>strupr(s):将字符串中的小写字母转化为大写</li><li>strchr(s,c):在一个串中查找给定字符的第一个匹配之处</li><li>strrev(s):将一个字符串反向</li></ul><h1 id="C-风格的字符串"><a href="#C-风格的字符串" class="headerlink" title="C++风格的字符串"></a>C++风格的字符串</h1><p>C++除了支持使用C风格字符串和所有的C字符串函数外，还提供另一种“C++风格的字符串”。（与C风格的最大区别是，C++字符串是建立在面向对象的基础上的一个字符串类，属于C++的<strong>标准模板库</strong>（<strong>STL</strong>），除了提供更多操作和封装带来更好的稳定性外，字符串作为一个类型还可以与STL中的其他容器协同工作）  </p><h3 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h3><p>在学习<strong>面向对象编程</strong>的概念之前，我们只需知道，C++风格的字符串是C++内置的一种类型：<strong>string类型</strong>。<br>要使用string类型，我们首先要使用头文件string（不是C语言的string.h，也不是C++的cstring）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s1,s2=<span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><p>这样，就简单完成了两个字符串s1,s2的定义，并给字符串s2赋了初值”hello”。我们发现：string类型是可以用字符串常量赋值的。  </p><h3 id="string操作"><a href="#string操作" class="headerlink" title="string操作"></a>string操作</h3><p>和C++的其他类型一样，string也可以使用cin/cout进行简单的输入输出：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s1;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1;</span><br></pre></td></tr></table></figure><p>输入：<br>1234<br>输出：<br>1234   </p><p>string之间、string和字符串常量可以进行赋值：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1,s2=<span class="string">"hello"</span>;</span><br><span class="line">s1=s2;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">s1=<span class="string">"abc"</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出：<br>hello<br>abc  </p><p>string类型提供一些简单的运算，简化了字符串处理的流程：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运算符有：</span><br><span class="line">+    += <span class="comment">//连接</span></span><br><span class="line">&gt;=   &lt;=   &gt;  &lt;  ==  !=  <span class="comment">//比较字典序</span></span><br></pre></td></tr></table></figure><p>如：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1=<span class="string">"aaa"</span>,s2=<span class="string">"bbb"</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1+s2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">s2+=s1;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出：<br>aaabbb<br>bbbaaa  </p><p>与C风格一样，string类型也可以通过下标访问每一个字符，<strong>下标从0开始</strong>：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"abcde"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    s[i]++;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s;</span><br></pre></td></tr></table></figure><p>输出：<br>bcdef  </p><p>string还能以一个C风格字符串为初值，还可以转换成一个C风格字符串（这里的语法还没有涉及，不作要求，如有需要须强行记忆，可了解面向对象编程的<strong>构造函数</strong>、<strong>成员函数</strong>等知识）   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">10</span>]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">//将C风格的s1作为string s2构造函数的参数进行初始化</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s2;</span><br><span class="line">s2=<span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(s1,s2.c_str());<span class="comment">//调用s2的成员函数，返回一个C风格的字符串</span></span><br><span class="line"><span class="built_in">puts</span>(s1);</span><br></pre></td></tr></table></figure><p>输出：<br>abc<br>hello  </p><p>这样，我们可以通过两种字符串操作的转化实现按需求灵活使用。  </p><h3 id="string类型的成员函数"><a href="#string类型的成员函数" class="headerlink" title="string类型的成员函数"></a>string类型的成员函数</h3><p><strong>成员函数</strong>这个概念在学习面向对象编程之前还有再放一放，我们只需知道，string类型和C风格一样使用函数支持很多的字符串操作，只是并不是使用C语言中（也就是我们之前学过）的那种函数。<br>比如，类似于strlen函数，string类型则有：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1=<span class="string">"apple"</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1.length();</span><br></pre></td></tr></table></figure><p>输出：<br>5  </p><p>成员函数的调用方式如上。  </p><p>由于string类型的面向对象特性已超出本教程的范围，更多的string类型成员函数有余力可自行查询。  </p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>1、什么是字符串，字符串和字符型数组有什么共同点？有什么区别？<br>2、C风格的字符串和C++风格的字符串有什么区别？<br>3、区分头文件string.h、cstring、string</p><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p>1、<a href="https://www.luogu.org/problemnew/show/P1914" target="_blank" rel="noopener">密码</a><br>2、<a href="https://www.luogu.org/problemnew/show/P1739" target="_blank" rel="noopener">表达式括号匹配</a><br>*3、实现一个能计算一位正整数+、-运算表达式的计算器<br>例：<br>输入：<br>1+3+2-5-7<br>输出：<br>-6<br>**4、实现一个能计算一位正整数+、-、*、/运算表达式的计算器<br>例：<br>输入：<br>1+3*5-4<br>输出：<br>12<br>***5、实现一个能计算正整数+、-、*、/运算表达式的计算器<br>例：<br>输入：<br>12+3*5-45<br>输出：<br>-18  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常需要使用计算机处理大量的字符，因而C/C++引入&lt;strong&gt;字符串&lt;/strong&gt;(string)以支持对大量字符操作。&lt;br&gt;其中，C++语言提供了&lt;strong&gt;C风格字符串&lt;/strong&gt;和&lt;strong&gt;C++风格字符串&lt;/strong&gt;（STL）两种选择：C风格的字符串操作与C语言完全一致，而C++风格的字符串则以面向对象的范式支持了更多操作。  &lt;/p&gt;
    
    </summary>
    
      <category term="小课堂" scheme="https://121.5.103.67/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="教程" scheme="https://121.5.103.67/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="C++" scheme="https://121.5.103.67/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【小课堂】五、函数（2）</title>
    <link href="https://121.5.103.67/2019/07/14/%E3%80%90%E5%B0%8F%E8%AF%BE%E5%A0%82%E3%80%91%E4%BA%94%E3%80%81%E5%87%BD%E6%95%B0%EF%BC%882%EF%BC%89/"/>
    <id>https://121.5.103.67/2019/07/14/【小课堂】五、函数（2）/</id>
    <published>2019-07-14T12:21:47.000Z</published>
    <updated>2019-08-02T14:31:42.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="声明与定义"><a href="#声明与定义" class="headerlink" title="声明与定义"></a>声明与定义</h2><p>由于作用域是从声明开始的，所以在声明之前，一个名字是无法被使用的：</p><a id="more"></a>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//此处全局a未声明，不在作用域内，无法使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;<span class="comment">//声明全局量a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//此处全局a已声明，在作用域内，可使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之类似的，一个函数也有作用域，一个函数名也只在它被声明之后才能使用：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//此处函数a未声明，不在作用域内，无法调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//此处函数a已声明，在作用域内，可调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，如果函数f1中也需要调用函数a该怎么处理呢？显然，一种办法是更改声明顺序：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//此处函数a已声明，在作用域内，可调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//此处函数a已声明，在作用域内，可调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这里介绍另一种方法解决这一问题，我们引入一组之前一直混用的概念：<strong>声明</strong>（declaration）和<strong>定义</strong>（definition）  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>;<span class="comment">//声明函数a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//此处函数a已声明，在作用域内，可调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>&#123;<span class="comment">//定义函数a</span></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//此处函数a已声明，在作用域内，可调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明：我们让函数a先提前出现，扩大了定义域，但并不需给出具体的函数实现（需要有除函数体外的其它部分）<br>定义：真正实现函数a的功能，需要完整的函数信息（包括函数体）<br><strong>须注意，一个函数在代码中可以声明任意次，但只能定义一次；而声明过的函数如果没有完整定义也无法调用。</strong>  </p><p>类似的，对于变量其实也存在<strong>声明</strong>与<strong>定义</strong>之分（有时须借助extern关键字，这句话可跳过）：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;<span class="comment">//声明变量a</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">4</span>;<span class="comment">//定义变量b，赋初值为4</span></span><br><span class="line"><span class="keyword">int</span> m[<span class="number">100</span>];<span class="comment">//声明数组m</span></span><br><span class="line"><span class="keyword">int</span> n[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//定义数组n，并初始化</span></span><br></pre></td></tr></table></figure><p>其中的区别是：声明只是告诉编译器这个变量的出现，而定义则会为这个变量分配内存，此区别在使用数组时会更为明显——如果只是声明一个变量，却一直没有使用的话，在程序运行的过程中是不会消耗内存的。<br>虽然因为C/C++语言中写法区别不大，也是一些（不合格）程序员都容易混淆的概念，但确实是很有必要区分的；而在之后学习<strong>递归</strong>时会遇到的<strong>互调递归</strong>则更离不开声明、定义分离的写法。  </p><h2 id="递归（1）"><a href="#递归（1）" class="headerlink" title="递归（1）"></a>递归（1）</h2><p> <em>从前有座山，山上有座庙，庙里有个老和尚给小和尚讲故事，讲的是：从前有座山，山上有座庙，庙里有个老和尚给小和尚讲故事，讲的是：……</em><br>这段著名的神秘小故事，最迷人的部分就在于：老和尚讲的故事，就是它这个故事本身。<br>这种自我指涉的现象随处可见：树枝的分叉上还是分叉、分形曲线、汉诺塔……<br>类似地，C/C++的函数可以调用自身，我们把函数调用自身的操作称为<strong>递归</strong>，把调用了自身的函数称为<strong>递归函数</strong>。<br>然而，正如 <em>老和尚的故事</em> 一样，如果调用自身不加限制，便会无穷无尽循环下去（然而计算机空间并非无限，于是程序就会崩溃）。因此，递归也必须加以限制。  </p><p>考察以下阶乘定义：<br>$n! = n ×(n-1)!,n&gt;0$<br>$0! = 1$<br>第一行定义n的阶乘等于n乘以n-1的阶乘。发现在阶乘的定义中出现了阶乘本身，我们称阶乘是<strong>递归定义的</strong>。然而，n-1的阶乘又是多少呢？是n-1乘以n-2的阶乘……如果不加以控制，就必然会坠入负无穷，重演老和尚的悲剧。<br>因此，第二行，定义0的阶乘为1，这是其它所有自然数递归的终点，我们称之为<strong>递归的基本条件</strong>。<br>这样一来，所有自然数的阶乘都有了明确定义。我们可以以此为依据编写阶乘函数的另一种写法（第一种见例5.1）：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//递归的基本条件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>);<span class="comment">//递归求解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应上面的定义，发现代码的写法是完全一致的。但是在调用这个阶乘函数时，计算机内又发生了什么呢？（以下为重点，前方高能，请反复观察）<br><img src="https://www.z4a.net/images/2019/08/02/97015ab86aa887ce87b698d9011c78f0.png" alt="97015ab86aa887ce87b698d9011c78f0.png"><br>现在请反复观察这张深度好图（）<br>我们发现计算机执行方法和普通函数并无不同，遇到调用自身则视为调用了另一个函数（新建了另一个局部量n，原n不变），一直调用到factorial(0)，此时共有5个局部量n，值分别为4,3,2,1,0。到factorial(0)执行return语句，也是将值1代回到调用它的地方factorial(1)的return语句中，然后factorial(1)执行return语句……直到回到factorial(4)，计算得出factorial(4)=24，递归调用结束。  </p><p>递归是初学时相当难掌握的概念，极可能会出现一头雾水或自以为理解却并非正确的情况发生。我们现在需要先充分理解上面的阶乘一例，接下来再分析更多的递归程序进行归纳，之后再通过作业习题进行训练检验。毕竟，递归概念<strong>极其</strong>重要，是将来程序设计中不可避免使用的技术，也是衡量程序设计水平高下的重要标尺之一。<br>我们对递归这一节的要求是：  </p><ul><li>理解什么是递归</li><li>能读懂一段递归代码的含义</li><li>能分析出一个递归函数在计算机内部的执行过程</li><li>能正确计算出给定递归函数的返回值</li><li>能编写递归函数正确实现某一功能，不出现故障（<strong>bug</strong>）  </li></ul><p>下面继续我们的探险：  </p><h2 id="递归（2）"><a href="#递归（2）" class="headerlink" title="递归（2）"></a>递归（2）</h2><p>还有一种形式的递归：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    a();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：此处的递归的基本条件未补全<br>这种函数自身未调用自身，但调用了调用自身的函数，也是一种特殊的递归，称为<strong>互调递归</strong>；由于C/C++作用域限制，需要先进行声明，先定义的函数才能调用后定义的函数。<br>下面是一个例子：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">odd</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">even</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> odd(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">odd</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> even(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>even函数返回整数n是否为偶数，odd函数返回整数n是否为奇数。利用n与n-1奇偶性相反进行递推，0为偶数作为基本条件，即可实现。  </p><h2 id="对递归函数效率的思考"><a href="#对递归函数效率的思考" class="headerlink" title="对递归函数效率的思考"></a>对递归函数效率的思考</h2><p>考察以下斐波那契数列定义：<br>注：$fib(n)$表示斐波那契数列的第n项<br>$fib(n) = fib(n-1) + fib(n-2), n&gt;2$<br>$fib(1)=fib(2)=1$<br>fib的定义同样用到了自身，所以它也是递归定义的。因此我们也可以用递归的方法计算。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在布置第一个任务：仿照上面分析阶乘函数图片的形式，试着分析调用函数fib(5)时的计算过程。<br><img src="https://www.z4a.net/images/2019/08/02/fib.png" alt="fib.png"><br>我们发现，计算fib(5)时调用了fib(4)和fib(3)；计算fib(4)时调用了fib(3)和fib(2)；计算fib(3)时调用了fib(2)和fib(1)；其中fib(3)被计算了2次，在fib(4)的左侧和fib(5)的右侧，fib(3)被反复计算。而随着n的增大，这张树形图将迅速增大。现在请尝试让你的计算机计算fib(45)的值，记录运算时间，并与之前你编写的循环结构求解斐波那契数列第45项的程序进行对比。（你想尝试更大的数可能要等很久很久）<br>循环结构求解斐波那契数列只执行45次，是瞬间即可得出结果；而递归求解却花了5秒（仔细观察发现递归求解斐波那契数列就是一个个1加出来的，运算量等于fib(n)，之后会知道此算法复杂度$O(2^n)$ ，为指数级），运算量差了许多数量级。<br>究其原因就是上面说的重复计算（称为<strong>冗余计算</strong>）大大浪费了算力；在递归求斐波那契数列的算法时出现的反复计算被称为<strong>重叠子问题</strong>。因此，在编写递归函数时，估算它的运算量也是必要的一个环节，而像上面的存在重叠子问题的递归算法则一定要警惕，并想办法优化，下面提供一种可行的优化方法供参考（此方法是解决递归时重复计算的常规方法：<strong>记忆化</strong>）：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1005</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[n]!=<span class="number">0</span>)<span class="keyword">return</span> f[n];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        f[n]= fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fib(<span class="number">45</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此程序将递归过程中已经计算过的结果保存在f数组中（记忆化），重复调用时将直接返回结果，避免了重复计算，运算量也大大降低了。   </p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>1、什么是声明？什么是定义？C/C++中为什么要区分这两者？<br>2、什么是递归？这种写法的好处是什么？可能的坏处是什么？<br>3、如何计算调用一个递归函数的执行次数？（即复杂度）  </p><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p>1、</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> func(n<span class="number">-2</span>)-func(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pj2014T2</span></span><br></pre></td></tr></table></figure><p>计算func(7)的值（不使用计算机）  </p><p>*2、</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">r</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">5</span>)<span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(r(n-i)&lt;<span class="number">0</span>)<span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tg2010T3</span></span><br></pre></td></tr></table></figure><p>计算r(16)的值（不使用计算机）<br>3、编程计算$Ackermann$函数$(m≤3)$，其中：<br>$Ackermann(m,n)=$<br>&emsp;&emsp;&emsp;&emsp;$n+1,(m=0)$<br>&emsp;&emsp;&emsp;&emsp;$Ackermann(m-1,n+1),(n=0)$<br>&emsp;&emsp;&emsp;&emsp;$Ackermann(m-1,Ackermann(m,n-1)),(m,n≠0)$<br>4、编写一个<strong>递归函数</strong>，传入一个正整数参数n，返回数列$a_n=2n+1$的前n项和<br>*5、编写一个<strong>递归过程</strong>，转入一个正整数参数、倒序输出其各数位的数字<br>要求主函数：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    func(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：<br>123456<br>输出：<br>654321<br>**6、编写一个<strong>递归过程</strong>，传入一个正整数参数、输出其二进制形式   </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;声明与定义&quot;&gt;&lt;a href=&quot;#声明与定义&quot; class=&quot;headerlink&quot; title=&quot;声明与定义&quot;&gt;&lt;/a&gt;声明与定义&lt;/h2&gt;&lt;p&gt;由于作用域是从声明开始的，所以在声明之前，一个名字是无法被使用的：&lt;/p&gt;
    
    </summary>
    
      <category term="小课堂" scheme="https://121.5.103.67/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="教程" scheme="https://121.5.103.67/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="C++" scheme="https://121.5.103.67/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【小课堂】五、函数（1）</title>
    <link href="https://121.5.103.67/2019/07/11/%E3%80%90%E5%B0%8F%E8%AF%BE%E5%A0%82%E3%80%91%E4%BA%94%E3%80%81%E5%87%BD%E6%95%B0%EF%BC%881%EF%BC%89/"/>
    <id>https://121.5.103.67/2019/07/11/【小课堂】五、函数（1）/</id>
    <published>2019-07-11T09:00:10.000Z</published>
    <updated>2019-08-03T16:48:42.691Z</updated>
    
    <content type="html"><![CDATA[<p><strong>函数</strong>是C/C++语言的核心概念，也是学习的重点所在。然而此函数与数学上的函数有所不同（也有称<strong>方法</strong>的），要理解掌握必须下些工夫。  </p><a id="more"></a><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>C/C++中的函数与C/C++语言的程序设计理念密切相关，在引入函数之前先看一个例子：<br><strong>例5.1：</strong><br>输入十个整数，输出他们的绝对值的阶乘  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) x = -x;<span class="comment">//求x的绝对值</span></span><br><span class="line">        s = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=x;j++)<span class="comment">//求x的阶乘</span></span><br><span class="line">            s *= j;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：<br>1 -2 3 -4 5 -6 7 -8 9 -10<br>输出：<br>1 2 6 24 120 720 5040 40320 362880 3628800   </p><p>随着需求功能的增加，将各个功能写在一起的代码将变得不利阅读和修改；而如果能将代码模块化，就可以解决这一问题。C/C++语言为此引入<strong>函数</strong>。  </p><h2 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h2><p>函数是一个命名的语句序列，能够返回计算结果（称为返回值）。<br>函数的定义语法如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;返回值类型&gt; 函数名(&lt;参数类型<span class="number">1</span>&gt; 参数<span class="number">1</span>,&lt;参数类型<span class="number">2</span>&gt; 参数<span class="number">2</span>,……)&#123;</span><br><span class="line">    语句;</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以抽象为：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;返回值类型&gt; 函数名(参数表)函数体</span><br></pre></td></tr></table></figure><p>这样，上面的例5.1就可以改写成（请先带着疑惑看完）：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">absolute</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)<span class="keyword">return</span> -x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=x;i++)</span><br><span class="line">        s *= i;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;factorial(absolute(x))&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，绝对值模块、阶乘模块被分开实现了，使用时只需调用即可，这样的编程设计思路（<strong>编程范式</strong>）更接近人类自然的解题思维。</p><p>下面将一一解释以上语法的每个部分。<br>以计算一个数的平方为例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行：<br>定义一个名为square的函数，需要一个整型参数（并命名为x），返回一个整型返回值<br>第二行：<br>函数体部分为一个return语句，即返回值为表达式x * x的结果。  </p><p>需要注意的是，函数的定义是写在main函数外面的（可以观察例5.1的代码）。毕竟main也是函数，在C/C++代码中的地位与其它函数一样；更一般地、在C/C++语言中，一个函数不能定义在另一个函数内（暂不考虑lambda表达式）。  </p><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>完成了函数的定义，我们就可以<strong>调用</strong>（diào）这个函数了。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;square(a)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：<br>6<br>输出：<br>36<br>6  </p><p>我们分析一下在调用过程中发生了什么：<br>程序从main函数开始执行，分别执行了int a;cin&gt;&gt;a;两行。<br>在执行cout&lt;&lt;square(a);时调用函数square，变量a作为被调用的参数。<br>于是，square函数中的变量x被赋值为变量a的值，并开始执行square函数：<br>返回x * x的值（即36），函数执行结束，<strong>回到调用的地方</strong>。<br>执行cout&lt;&lt;36;最后输出36。<br>操作后a的值没有改变。  </p><p>我们称调用时传递给函数的值（上例中的a）为<strong>实际参数</strong>（简称<strong>实参</strong>）；称接受该值的变量（上例中的x）为<strong>形式参数</strong>（简称<strong>形参</strong>）。<br>形参是函数中接受传入数值的特殊变量：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;add1(a)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：<br>6<br>输出：<br>7<br>6<br>函数调用过程中，a的值被赋给了形参x，x在函数中+1并返回；而a的值仍为6：操作后a的值没有改变。  </p><p>试试看在main函数中为上例的x赋值，或者输出x，看看会发生什么——</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>考察以下代码：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会告诉你，这个代码是错误的：x没有定义。square函数中定义了变量x，到main函数中却没有了，因为main函数超出了变量x的<strong>作用域</strong>。  </p><p>要解释作用域这一概念，我认为最好的类比就是数学题中出现的前提条件：<br>19.已知函数$f(x)=x^2,g(x)$<br>(1)若$g(x)=2^x$，设$h(x)=…$……<br>(2)……<br>发现:<br>总条件是$f(x)=x^2$，在整道题中不会改变，且都能使用<br>第一小问中：$g(x)=2^x$，但只能在第一问中使用；另定义了$h(x)$<br>第二小问中：没有关于$g(x)$的条件，因此它可以为任意函数，$h(x)$甚至没有出现，自然无法使用。  </p><p>与之类比，C/C++有<strong>全局量</strong>与<strong>局部量</strong>的概念，定义在<strong>所有</strong>函数外的变量为全局量，作用域为从声明变量开始，到代码的末尾；而定义在函数内的变量为局部量（包括形参也是特殊的局部量），作用域仅在该函数内。因此，上例中的main函数无法使用square中的x。<br>全局量和局部量可以同名，但同一作用域不能出现两个同名全局量或局部量，请看下例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    x = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;add1(<span class="number">10</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;add1(x)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br>11<br>21  </p><p>我们先在所有函数外定义了一个变量x，所以这个x为全局量；然后定义了一个函数add1，参数表中也声明了一个变量x作为形式参数，而这个x在函数内，故为局部量，作用域仅在add1函数内；<br>程序从main函数开始运行：<br>先将x赋值为20：此时main函数中没有x的定义，因此这个x是指全局量x（全局量x赋值为20）。<br>调用add1(10)：局部量x（形参）被赋值为10，执行add1函数，return x+1;那么这个x是10（局部量）还是20（全局量）呢？输出结果告诉我们，此处的x是函数内的局部量——一般地，如果有同名的局部量和全局量，那个变量名将会优先定向到局部量，只有没有这个局部量时，它才代指那个全局量。<br>调用add1(x)：此时的x是局部量，因此值为20，并传给形参x，最后返回21。  </p><p>C/C++的这一特性保证了函数是一个安全的小环境，在里面定义、使用任何名字都不用担心与外面的代码冲突，也让我们能够在定义多个函数时放心的使用诸如x等一些简单的名字而不冲突。</p><h2 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h2><p>return语句控制着函数的返回值，写在函数体中，语法为：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> 返回值;</span><br></pre></td></tr></table></figure><p>因此，return后的返回值类型必须与函数定义时写的类型一致。  </p><p>同时，return语句也控制着函数的退出，函数体执行到return语句就会立即退出，<strong>销毁所有局部量</strong>（包括形参和在函数体内定义的局部量），并将return后的返回值代回调用处：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+<span class="number">1</span>;</span><br><span class="line">    t++;</span><br><span class="line">    <span class="keyword">return</span> t+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数f将返回t+1，而后面的语句将永远不会执行。  </p><h2 id="无返回值函数（过程）"><a href="#无返回值函数（过程）" class="headerlink" title="无返回值函数（过程）"></a>无返回值函数（过程）</h2><p>特别地，一个C/C++函数也可以没有返回值，在定义函数时返回值类型为void（空类型），如：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，函数也可以没有参数，即参数为void（也可以省略）：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g1</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，一个没有返回值的函数有什么用呢？  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan_t</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tadd</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    t+=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_t</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">scan_t</span>();</span><br><span class="line">    tadd(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">print_t</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    execute();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：<br>9<br>输出：<br>14</p><p>而如例4.5，就可以写成：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printline</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"*"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">       printline(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，无返回值函数仍然能实现一段有功用的代码，这也使得代码模块化了，因而无返回值函数也被称为<strong>过程</strong>（procedure）。因为没有返回值，一个过程中可以在任何地方使用return语句退出，但禁止return语句后带返回值。然而限于目前工具有限，我们目前仅能够通过全局量让过程修改一个变量，给代码的其他部分使用；在学习了<strong>指针</strong>、<strong>引用</strong>后，过程将能够发挥更大作用。  </p><p>我们发现，main函数就是一个无参数（也可以有参数）、返回值为int（正常运行是返回0）的函数。</p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h3 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h3><p>1、什么是C/C++函数，它与数学中的函数有什么不同？<br>2、我们为什么要引入函数？使用函数编程有什么好处？<br>3、什么是形参？什么是实参？C/C++语言函数为什么需要形参？<br>4、什么是作用域？为什么要引入作用域？<br>5、执行一句return语句会发生哪些事情？<br>6、什么是过程？  </p><h3 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h3><p>（以下习题，除main外应至少编写一个函数实现）<br>1、输入整数n，输出$[2,n]$中的所有质数<br>2、输入整数n，输出$[2,n]$中所有回文质数<br>3、计算组合数$C^m_n$的值<br>4、输入整数n，和n个整数，输入两个整数i，j，将位置i到j间的数升序排列，其余不变<br>例：<br>输入：<br>5<br>3 5 2 8 6<br>2 4<br>输出：<br>3 2 5 8 6<br>*5、输入十进制正整数n，转化二进制输出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;函数&lt;/strong&gt;是C/C++语言的核心概念，也是学习的重点所在。然而此函数与数学上的函数有所不同（也有称&lt;strong&gt;方法&lt;/strong&gt;的），要理解掌握必须下些工夫。  &lt;/p&gt;
    
    </summary>
    
      <category term="小课堂" scheme="https://121.5.103.67/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="教程" scheme="https://121.5.103.67/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="C++" scheme="https://121.5.103.67/tags/C/"/>
    
  </entry>
  
</feed>
